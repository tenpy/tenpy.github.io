
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Introduction to models &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fermions and the Jordan-Wigner transformation" href="intro_JordanWigner.html" />
    <link rel="prev" title="Introduction to np_conserved" href="intro_npc.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro_JordanWigner.html" title="Fermions and the Jordan-Wigner transformation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="intro_npc.html" title="Introduction to np_conserved"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="userguide.html" accesskey="U">User Guide</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction-to-models">
<h1>Introduction to models<a class="headerlink" href="#introduction-to-models" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-a-model">
<h2>What is a model?<a class="headerlink" href="#what-is-a-model" title="Permalink to this headline">¶</a></h2>
<p>Abstractly, a <strong>model</strong> stands for some physical (quantum) system to be described.
For tensor networks algorithms, the model is usually specified as a Hamiltonian written in terms of second quantization.
For example, let us consider a spin-1/2 Heisenberg model described by the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = J \sum_i S^x_i S^x_{i+1} + S^y_i S^y_{i+1} + S^z_i S^z_{i+1}\]</div>
<p>Note that a few things are defined more or less implicitly.</p>
<ul class="simple">
<li>The local Hilbert space: it consists of Spin-1/2 degrees of freedom with the usual spin-1/2 operators <span class="math notranslate nohighlight">\(S^x, S^y, S^z\)</span>.</li>
<li>The geometric (lattice) strucuture: above, we spoke of a 1D “chain”.</li>
<li>The boundary conditions: do we have open or periodic boundary conditions?
The “chain” suggests open boundaries, which are in most cases preferable for MPS-based methods.</li>
<li>The range of <cite>i</cite>: How many sites do we consider (for a 2D system: in each direction)?</li>
</ul>
<p>Obviously, these things need to be specified in TeNPy in one way or another, if we want to define a model.</p>
<p>Ultimately, our goal is to run some algorithm. Each algorithm requires the model and Hamiltonian to be specified in a particular form.
We have one class for each such required form.
For example <a class="reference internal" href="reference/tenpy.algorithms.dmrg.html#module-tenpy.algorithms.dmrg" title="tenpy.algorithms.dmrg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dmrg</span></code></a> requires an <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a>,
which contains the Hamiltonian written as an <a class="reference internal" href="reference/tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>.
On the other hand, if we want to evolve a state with <a class="reference internal" href="reference/tenpy.algorithms.tebd.html#module-tenpy.algorithms.tebd" title="tenpy.algorithms.tebd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tebd</span></code></a>
we need a <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>, in which the Hamiltonian is written in terms of
two-site bond-terms to allow a Suzuki-Trotter decomposition of the time-evolution operator.</p>
<p>Implmenting you own model ultimatley means to get an instance of <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a> or <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
The predefined classes in the other modules under <a class="reference internal" href="reference/tenpy.models.html#module-tenpy.models" title="tenpy.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">models</span></code></a> are subclasses of at least one of those,
you will see examples later down below.</p>
</div>
<div class="section" id="the-hilbert-space">
<h2>The Hilbert space<a class="headerlink" href="#the-hilbert-space" title="Permalink to this headline">¶</a></h2>
<p>The <strong>local Hilbert</strong> space is represented by a <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> (read its doc-string!).
In particular, the <cite>Site</cite> contains the local <a class="reference internal" href="reference/tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> and hence the meaning of each
basis state needs to be defined.
Beside that, the site contains the local operators - those give the real meaning to the local basis.
Having the local operators in the site is very convenient, because it makes them available by name for example when you want to calculate expectation values.
The most common sites (e.g. for spins, spin-less or spin-full fermions, or bosons) are predefined
in the module <a class="reference internal" href="reference/tenpy.networks.site.html#module-tenpy.networks.site" title="tenpy.networks.site"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.networks.site</span></code></a>, but if necessary you can easily extend them
by adding further local operators or completely write your own subclasses of <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a>.</p>
<p>The full Hilbert space is a tensor product of the local Hilbert space on each site.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="reference/tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> of all involved sites need to have a common
<a class="reference internal" href="reference/tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> in order to allow the contraction of tensors acting on the various sites.
This can be ensured with the function <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.multi_sites_combine_charges" title="tenpy.networks.site.multi_sites_combine_charges"><code class="xref py py-func docutils literal notranslate"><span class="pre">multi_sites_combine_charges()</span></code></a>.</p>
</div>
<p>An example where <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.multi_sites_combine_charges" title="tenpy.networks.site.multi_sites_combine_charges"><code class="xref py py-func docutils literal notranslate"><span class="pre">multi_sites_combine_charges()</span></code></a> is needed would be a coupling of different
types of sites, e.g., when a tight binding chain of fermions is coupled to some local spin degrees of freedom.
Another use case of this function would be a model with a $U(1)$ symmetry involving only half the sites, say <span class="math notranslate nohighlight">\(\sum_{i=0}^{L/2} n_{2i}\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you don’t know about the charges and <cite>np_conserved</cite> yet, but want to get started with models right away,
you can set <code class="docutils literal notranslate"><span class="pre">conserve=None</span></code> in the existing sites or use
<code class="docutils literal notranslate"><span class="pre">leg</span> <span class="pre">=</span> <span class="pre">tenpy.linalg.np_conserved.LegCharge.from_trivial(d)</span></code> for an implementation of your custom site,
where <cite>d</cite> is the dimension of the local Hilbert space.
Alternatively, you can find some introduction to the charges in the <a class="reference internal" href="intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
</div>
</div>
<div class="section" id="the-geometry-lattices">
<h2>The geometry : lattices<a class="headerlink" href="#the-geometry-lattices" title="Permalink to this headline">¶</a></h2>
<p>The geometry is usually given by some kind of <strong>lattice</strong> structure how the sites are arranged,
e.g. implicitly with the sum over nearest neighbours <span class="math notranslate nohighlight">\(\sum_{&lt;i, j&gt;}\)</span>.
In TeNPy, this is specified by a <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a> class, which contains a unit cell of
a few <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> which are shifted periodically by its basis vectors to form a regular lattice.
Again, we have pre-defined some basic lattices like a <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Chain" title="tenpy.models.lattice.Chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chain</span></code></a>,
two chains coupled as a <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Ladder" title="tenpy.models.lattice.Ladder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ladder</span></code></a> or 2D lattices like the
<a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Square" title="tenpy.models.lattice.Square"><code class="xref py py-class docutils literal notranslate"><span class="pre">Square</span></code></a>, <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Honeycomb" title="tenpy.models.lattice.Honeycomb"><code class="xref py py-class docutils literal notranslate"><span class="pre">Honeycomb</span></code></a> and
<a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Kagome" title="tenpy.models.lattice.Kagome"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kagome</span></code></a> lattices; but you are also free to define your own generalizations.
(More details on that can be found in the doc-string of <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a>, read it!)</p>
<p><strong>Visualization</strong> of the lattice can help a lot to understand which sites are connected by what couplings.
The methods <code class="docutils literal notranslate"><span class="pre">plot_...</span></code> of the <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a> can do a good job for a quick illustration.
We include a small image in the documation of each of the lattices.
For example, the following small script can generate the image of the Kagome lattice shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">tenpy.models.lattice</span> <span class="k">import</span> <span class="n">Kagome</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">lat</span> <span class="o">=</span> <span class="n">Kagome</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;periodic&#39;</span><span class="p">)</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_coupling</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_order</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_sites</span><span class="p">()</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_basis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/Kagome.png" src="_images/Kagome.png" />
<p>The lattice contains also the <strong>boundary conditions</strong> <cite>bc</cite> in each direction. It can be one of the usual <code class="docutils literal notranslate"><span class="pre">'open'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'periodic'</span></code> in each direcetion. Instead of just saying “periodic”, you can also specify a <cite>shift</cite> (except in the
first direction). This is easiest to understand at its standard usecase: DMRG on a infinite cylinder.
Going around the cylinder, you have a degree of freedom which sites to connect.
The orange markers in the following figures illustrates sites identified for a Square lattice with <code class="docutils literal notranslate"><span class="pre">bc=['periodic',</span> <span class="pre">shift]</span></code> (see <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bc_shift()</span></code>):</p>
<img alt="_images/square_bc_shift.png" src="_images/square_bc_shift.png" />
<p>Note that the “cylinder” axis (and direction for <span class="math notranslate nohighlight">\(k_x\)</span>) is perpendicular to the orange line connecting these
sites. The line where the cylinder is “cut open” therefore winds around the the cylinder for a non-zero <cite>shift</cite> (or
more complicated lattices without perpendicular basis).</p>
<p>MPS based algorithms like DMRG always work on purely 1D systems. Even if our model “lives” on a 2D lattice,
these algorithms require to map it onto a 1D chain (probably at the cost of longer-range interactions).
This mapping is also done in by the lattice, as it defines an <strong>order</strong> (<a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice.order" title="tenpy.models.lattice.Lattice.order"><code class="xref py py-attr docutils literal notranslate"><span class="pre">order</span></code></a>) of the sites.
The methods <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice.mps2lat_idx" title="tenpy.models.lattice.Lattice.mps2lat_idx"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps2lat_idx()</span></code></a> and <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice.lat2mps_idx" title="tenpy.models.lattice.Lattice.lat2mps_idx"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lat2mps_idx()</span></code></a> map
indices of the MPS to and from indices of the lattice. If you obtained and array with expectation values for a given MPS,
you can use <a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Lattice.mps2lat_values" title="tenpy.models.lattice.Lattice.mps2lat_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps2lat_values()</span></code></a> to map it to lattice indices, thereby reverting the ordering.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A suitable ordering is critical for the efficiency of MPS-based algorithms.
On one hand, different orderings can lead to different MPO bond-dimensions, with direct impact on the complexity scaling.
Moreover, it influences how much entanglement needs to go through each bonds of the underlying MPS,
e.g., the ground strate to be found in DMRG, and therefore influence the required MPS bond dimensions.
For the latter reason, the “optimal” bond dimension can not be known a priori, but one needs to try different
orderings.</p>
</div>
<p>Performing this mapping of the Hamiltonain from a 2D lattice to a 1D chain by hand can be a tideous process.
Therefore, we have automated this mapping in TeNPy as explained in the next section.
(Nevertheless it’s a good exercise you should do at least once in your life to understand how it works!)</p>
</div>
<div class="section" id="implementing-you-own-model">
<h2>Implementing you own model<a class="headerlink" href="#implementing-you-own-model" title="Permalink to this headline">¶</a></h2>
<p>When you want to simulate a model not provided in <a class="reference internal" href="reference/tenpy.models.html#module-tenpy.models" title="tenpy.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">models</span></code></a>, you need to implement your own model class,
lets call it <code class="docutils literal notranslate"><span class="pre">MyNewModel</span></code>.
The idea is that you define a new subclass of one or multiple of the model base classes.
For example, when you plan to do DMRG, you have to provide an MPO in a <code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code>,
so your model class should look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNewModel</span><span class="p">(</span><span class="n">MPOModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General strucutre for a model suitable for DMRG.</span>

<span class="sd">    Here is a good place to document the represented Hamiltonian and parameters.</span>

<span class="sd">    In the models of TeNPy, we usually take a single dictionary `model_params`</span>
<span class="sd">    containing all parameters, and read values out with ``tenpy.tools.params.get_parameter(...)``,</span>
<span class="sd">    The model needs to provide default values if the parameters was not specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="c1"># some code here to read out model parameters and generate H_MPO</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">somehow_generate_lattice</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="n">H_MPO</span> <span class="o">=</span> <span class="n">somehow_generate_MPO</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>
        <span class="c1"># initialize MPOModel</span>
        <span class="n">MPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">H_MPO</span><span class="p">)</span>
</pre></div>
</div>
<p>TEBD requires another representation of H in terms of bond terms <cite>H_bond</cite> given to a
<code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code>, so in this case it would look so like this instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNewModel2</span><span class="p">(</span><span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General strucutre for a model suitable for TEBD.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="c1"># some code here to read out model parameters and generate H_bond</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">somehow_generate_lattice</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="n">H_bond</span> <span class="o">=</span> <span class="n">somehow_generate_H_bond</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>
        <span class="c1"># initialize MPOModel</span>
        <span class="n">NearestNeighborModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">H_bond</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, the difficult part in these examples is to generate the <code class="docutils literal notranslate"><span class="pre">H_MPO</span></code> and <code class="docutils literal notranslate"><span class="pre">H_bond</span></code>.
Moreover, it’s quite annoying to write every model multiple times,
just because we need different representations of the same Hamiltonian.
Luckily, there is a way out in TeNPy: the CouplingModel!</p>
</div>
<div class="section" id="the-easy-way-to-new-models-the-multi-couplingmodel">
<h2>The easy way to new models: the (Multi)CouplingModel<a class="headerlink" href="#the-easy-way-to-new-models-the-multi-couplingmodel" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> provides a general, quite abstract way to specify a Hamiltonian
of two-site couplings on a given lattice.
Once initialized, its methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_onsite()</span></code> and
<a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a> allow to add onsite and coupling terms repeated over the different
unit cells of the lattice.
In that way, it basically allows a straight-forward translation of the Hamiltonian given as a math forumla
<span class="math notranslate nohighlight">\(H = \sum_{i} A_i B_{i+dx} + ...\)</span> with onsite operators <cite>A</cite>, <cite>B</cite>,… into a model class.</p>
<p>To use this model, you</p>
<p>In the initialization method <code class="docutils literal notranslate"><span class="pre">__init__(self,</span> <span class="pre">...)</span></code> of this class you can then follow these basic steps:</p>
<ol class="arabic" start="0">
<li><p class="first">Read out the parameters.</p>
</li>
<li><p class="first">Given the parameters, determine the charges to be conserved.
Initialize the <a class="reference internal" href="reference/tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> of the local sites accordingly.</p>
</li>
<li><p class="first">Define (additional) local operators needed.</p>
</li>
<li><p class="first">Initialize the needed <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Using pre-defined sites like the <a class="reference internal" href="reference/tenpy.networks.site.html#tenpy.networks.site.SpinHalfSite" title="tenpy.networks.site.SpinHalfSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHalfSite</span></code></a> is recommended and
can replace steps 1-3.</p>
</div>
</li>
<li><p class="first">Initialize the lattice (or if you got the lattice as a parameter, set the sites in the unit cell).</p>
</li>
<li><p class="first">Initialize the <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> with <code class="docutils literal notranslate"><span class="pre">CouplingModel.__init__(self,</span> <span class="pre">lat)</span></code>.</p>
</li>
<li><p class="first">Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_onsite()</span></code> and <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
to add all terms of the Hamiltonian. Here, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">nearest_neighbors</span></code> of the lattice
(and its friends for next nearest neighbors) can come in handy, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a> adds the coupling only in one direction, i.e.
not switching <cite>i</cite> and <cite>j</cite> in a <span class="math notranslate nohighlight">\(\sum_{\langle i, j\rangle}\)</span>.
If you have terms like <span class="math notranslate nohighlight">\(c^\dagger_i c_j\)</span> in your Hamiltonian, you <em>need</em> to add it in both directions to get
a hermitian Hamiltonian! Simply add another line <code class="docutils literal notranslate"><span class="pre">self.add_coupling(J,</span> <span class="pre">u1,</span> <span class="pre">'Sz',</span> <span class="pre">u2,</span> <span class="pre">'Sz',</span> <span class="pre">-dx)</span></code>.</p>
</div>
<p>Note that the <cite>strength</cite> arguments of these functions can be (numpy) arrays for site-dependent couplings.
If you need to add or multipliy some parameters of the model for the <cite>strength</cite> of certain terms,
it is recommended use <code class="docutils literal notranslate"><span class="pre">np.asarray</span></code> beforehand – in that way lists will also work fine.</p>
</li>
<li><p class="first">Finally, if you derived from the <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a>, you can call
<a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel.calc_H_MPO" title="tenpy.models.model.CouplingModel.calc_H_MPO"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_H_MPO()</span></code></a> to build the MPO and use it for the initialization
as <code class="docutils literal notranslate"><span class="pre">MPOModel.__init__(self,</span> <span class="pre">lat,</span> <span class="pre">self.calc_H_MPO())</span></code>.</p>
</li>
<li><p class="first">Similarly, if you derived from the <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>, you can call
<a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel.calc_H_MPO" title="tenpy.models.model.CouplingModel.calc_H_MPO"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_H_MPO()</span></code></a> to initialze it
as <code class="docutils literal notranslate"><span class="pre">NearestNeighborModel.__init__(self,</span> <span class="pre">lat,</span> <span class="pre">self.calc_H_bond())</span></code>.
Calling <code class="docutils literal notranslate"><span class="pre">self.calc_H_bond()</span></code> will fail for models which are not nearest-neighbors (with respect to the MPS ordering),
so you should only subclass the <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a> if the lattice is a simple
<a class="reference internal" href="reference/tenpy.models.lattice.html#tenpy.models.lattice.Chain" title="tenpy.models.lattice.Chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chain</span></code></a>.</p>
</li>
</ol>
<p>The <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> works for Hamiltonians which are a sum of terms involving at most two sites.
The generalization <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.MultiCouplingModel" title="tenpy.models.model.MultiCouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCouplingModel</span></code></a> can be used for Hamlitonians with
coupling terms acting on more than 2 sites at once.
A prototypical example is the exactly solvable <a class="reference internal" href="reference/tenpy.models.toric_code.html#tenpy.models.toric_code.ToricCode" title="tenpy.models.toric_code.ToricCode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricCode</span></code></a>.</p>
</div>
<div class="section" id="some-final-remarks">
<h2>Some final remarks<a class="headerlink" href="#some-final-remarks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Needless to say that we have also various predefined models under <a class="reference internal" href="reference/tenpy.models.html#module-tenpy.models" title="tenpy.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.models</span></code></a>.</li>
<li>Of course, an MPO is all you need to initialize a <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a> to be used for DMRG; you don’t have to use the <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a>.
For example an exponentially decaying long-range interactions are not supported by the coupling model but straight-forward to include to an MPO, as demonstrated in the example <code class="docutils literal notranslate"><span class="pre">examples/mpo_exponentially_decaying.py</span></code>.</li>
<li>If the model you’re interested in contains Fermions, you should read the <a class="reference internal" href="intro_JordanWigner.html"><span class="doc">Fermions and the Jordan-Wigner transformation</span></a>.</li>
<li>We suggest writing the model to take a single parameter dicitionary for the initialization, which is to be read out
inside the class with <a class="reference internal" href="reference/tenpy.tools.params.html#tenpy.tools.params.get_parameter" title="tenpy.tools.params.get_parameter"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_parameter()</span></code></a>.
Read the doc-string of this function for more details on why this is a good idea.
Calling <a class="reference internal" href="reference/tenpy.tools.params.html#tenpy.tools.params.unused_parameters" title="tenpy.tools.params.unused_parameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">unused_parameters()</span></code></a> is usefull to avoid typos in the specified parameters.</li>
<li>When you write a model and want to include a test that it can be at least constructed,
take a look at <code class="docutils literal notranslate"><span class="pre">tests/test_model.py</span></code>.</li>
</ul>
</div>
<div class="section" id="full-examples">
<h2>Full examples<a class="headerlink" href="#full-examples" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="reference/tenpy.models.xxz_chain.html#tenpy.models.xxz_chain.XXZChain" title="tenpy.models.xxz_chain.XXZChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.xxz_chain.XXZChain</span></code></a> demonstrates nicely how a new model can be defined using the <a class="reference internal" href="reference/tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a>.
The complete source code for this model is included in the following and should be straight-forward to understand and
generalize.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Prototypical example of a 1D quantum model: the spin-1/2 XXZ chain.</span>

<span class="sd">The XXZ chain is contained in the more general :class:`~tenpy.models.spins.SpinChain`;</span>
<span class="sd">the idea of this module is more to serve as a pedagogical example for a model.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">from</span> <span class="nn">.lattice</span> <span class="k">import</span> <span class="n">Site</span><span class="p">,</span> <span class="n">Chain</span>
<span class="kn">from</span> <span class="nn">.model</span> <span class="k">import</span> <span class="n">CouplingModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">,</span> <span class="n">MPOModel</span><span class="p">,</span> <span class="n">CouplingMPOModel</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">np_conserved</span> <span class="k">as</span> <span class="n">npc</span>
<span class="kn">from</span> <span class="nn">..tools.params</span> <span class="k">import</span> <span class="n">get_parameter</span><span class="p">,</span> <span class="n">unused_parameters</span>
<span class="kn">from</span> <span class="nn">..networks.site</span> <span class="k">import</span> <span class="n">SpinHalfSite</span>  <span class="c1"># if you want to use the predefined site</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;XXZChain&#39;</span><span class="p">,</span> <span class="s1">&#39;XXZChain2&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">XXZChain</span><span class="p">(</span><span class="n">CouplingModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">,</span> <span class="n">MPOModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Spin-1/2 XXZ chain with Sz conservation.</span>

<span class="sd">    The Hamiltonian reads:</span>

<span class="sd">    .. math ::</span>
<span class="sd">        H = \sum_i \mathtt{Jxx}/2 (S^{+}_i S^{-}_{i+1} + S^{-}_i S^{+}_{i+1})</span>
<span class="sd">                 + \mathtt{Jz} S^z_i S^z_{i+1} \\</span>
<span class="sd">            - \sum_i \mathtt{hz} S^z_i</span>

<span class="sd">    All parameters are collected in a single dictionary `model_param` and read out with</span>
<span class="sd">    :func:`~tenpy.tools.params.get_parameter`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        Length of the chain.</span>
<span class="sd">    Jxx, Jz, hz : float | array</span>
<span class="sd">        Couplings as defined for the Hamiltonian above.</span>
<span class="sd">    bc_MPS : {&#39;finite&#39; | &#39;infinte&#39;}</span>
<span class="sd">        MPS boundary conditions. Coupling boundary conditions are chosen appropriately.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="c1"># 0) read out/set default parameters</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;XXZChain&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Jxx</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;Jxx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Jz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;Jz&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">hz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">bc_MPS</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;bc_MPS&#39;</span><span class="p">,</span> <span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">unused_parameters</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>  <span class="c1"># checks for mistyped parameters</span>
        <span class="c1"># 1-3):</span>
        <span class="n">USE_PREDEFINED_SITE</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">USE_PREDEFINED_SITE</span><span class="p">:</span>
            <span class="c1"># 1) charges of the physical leg. The only time that we actually define charges!</span>
            <span class="n">leg</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">ChargeInfo</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;2*Sz&#39;</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># 2) onsite operators</span>
            <span class="n">Sp</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
            <span class="n">Sm</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
            <span class="n">Sz</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]]</span>
            <span class="c1"># (Can&#39;t define Sx and Sy as onsite operators: they are incompatible with Sz charges.)</span>
            <span class="c1"># 3) local physical site</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">],</span> <span class="n">Sp</span><span class="o">=</span><span class="n">Sp</span><span class="p">,</span> <span class="n">Sm</span><span class="o">=</span><span class="n">Sm</span><span class="p">,</span> <span class="n">Sz</span><span class="o">=</span><span class="n">Sz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># there is a site for spin-1/2 defined in TeNPy, so just we can just use it</span>
            <span class="c1"># replacing steps 1-3)</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">SpinHalfSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
        <span class="c1"># 4) lattice</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="s1">&#39;periodic&#39;</span> <span class="k">if</span> <span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span> <span class="k">else</span> <span class="s1">&#39;open&#39;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">bc_MPS</span><span class="o">=</span><span class="n">bc_MPS</span><span class="p">)</span>
        <span class="c1"># 5) initialize CouplingModel</span>
        <span class="n">CouplingModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># 6) add terms of the Hamiltonian</span>
        <span class="c1"># (u is always 0 as we have only one site in the unit cell)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">hz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 7) initialize H_MPO</span>
        <span class="n">MPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_H_MPO</span><span class="p">())</span>
        <span class="c1"># 8) initialize H_bond (the order of 7/8 doesn&#39;t matter)</span>
        <span class="n">NearestNeighborModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_H_bond</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">XXZChain2</span><span class="p">(</span><span class="n">CouplingMPOModel</span><span class="p">,</span><span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Another implementation of the Spin-1/2 XXZ chain with Sz conservation.</span>

<span class="sd">    This implementation takes the same parameters as the :class:`XXZChain`, but is implemented</span>
<span class="sd">    based on the :class:`~tenpy.models.model.CouplingMPOModel`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="n">model_param</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lattice&#39;</span><span class="p">,</span> <span class="s2">&quot;Chain&quot;</span><span class="p">)</span>
        <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SpinHalfSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>  <span class="c1"># use predefined Site</span>

    <span class="k">def</span> <span class="nf">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="c1"># read out parameters</span>
        <span class="n">Jxx</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;Jxx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">Jz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;Jz&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">hz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># add terms</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">hz</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jz</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>Another standard example is the transverse field Ising model. Below, it is defined
in one dimension on a chain, or any of the predefined lattice in two dimensions, illustrating how easily geometries can be changed in TeNPy.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Prototypical example of a quantum model: the transverse field Ising model.</span>

<span class="sd">Like the :class:`~tenpy.models.xxz_chain.XXZChain`, the transverse field ising chain</span>
<span class="sd">:class:`TFIChain` is contained in the more general :class:`~tenpy.models.spins.SpinChain`;</span>
<span class="sd">the idea is more to serve as a pedagogical example for a &#39;model&#39;.</span>
<span class="sd">Choosing the field along z allow to preserve parity, if desired, at the expense of a larger MPO</span>
<span class="sd">bond dimension for the Hamiltion.</span>

<span class="sd">The :class:`TFIModel2D` contains the same couplings but on a square lattice in 2D</span>
<span class="sd">(with chooseable boundary conditions).</span>
<span class="sd">As such, it illustrates the correct usage of the :class:`~tenpy.models.lattice.Lattice` classes.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">from</span> <span class="nn">.model</span> <span class="k">import</span> <span class="n">CouplingMPOModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span>
<span class="kn">from</span> <span class="nn">..tools.params</span> <span class="k">import</span> <span class="n">get_parameter</span>
<span class="kn">from</span> <span class="nn">..networks.site</span> <span class="k">import</span> <span class="n">SpinHalfSite</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TFIModel&#39;</span><span class="p">,</span> <span class="s1">&#39;TFIChain&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TFIModel</span><span class="p">(</span><span class="n">CouplingMPOModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transverse field Ising model on a general lattice.</span>

<span class="sd">    The Hamiltonian reads:</span>

<span class="sd">    .. math ::</span>
<span class="sd">        H = - \sum_{\langle i,j\rangle, i &lt; j} \mathtt{J} \sigma^x_i \sigma^x_{j}</span>
<span class="sd">            - \sum_{i} \mathtt{g} \sigma^z_i</span>

<span class="sd">    Here, :math:`\langle i,j \rangle, i&lt; j` denotes nearest neighbor pairs, each pair appearing</span>
<span class="sd">    exactly once.</span>
<span class="sd">    All parameters are collected in a single dictionary `model_param` and read out with</span>
<span class="sd">    :func:`~tenpy.tools.params.get_parameter`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    conserve : None | &#39;parity&#39;</span>
<span class="sd">        What should be conserved. See :class:`~tenpy.networks.Site.SpinHalfSite`.</span>
<span class="sd">    J, g : float | array</span>
<span class="sd">        Couplings as defined for the Hamiltonian above.</span>
<span class="sd">    lattice : str | :class:`~tenpy.models.lattice.Lattice`</span>
<span class="sd">        Instance of a lattice class for the underlaying geometry.</span>
<span class="sd">        Alternatively a string being the name of one of the Lattices defined in</span>
<span class="sd">        :mod:`~tenpy.models.lattice`, e.g. ``&quot;Chain&quot;, &quot;Square&quot;, &quot;HoneyComb&quot;, ...``.</span>
<span class="sd">    bc_MPS : {&#39;finite&#39; | &#39;infinte&#39;}</span>
<span class="sd">        MPS boundary conditions along the x-direction.</span>
<span class="sd">        For &#39;infinite&#39; boundary conditions, repeat the unit cell in x-direction.</span>
<span class="sd">        Coupling boundary conditions in x-direction are chosen accordingly.</span>
<span class="sd">        Only used if `lattice` is a string.</span>
<span class="sd">    order : string</span>
<span class="sd">        Ordering of the sites in the MPS, e.g. &#39;default&#39;, &#39;snake&#39;;</span>
<span class="sd">        see :meth:`~tenpy.models.lattice.Lattice.ordering`.</span>
<span class="sd">        Only used if `lattice` is a string.</span>
<span class="sd">    L : int</span>
<span class="sd">        Lenght of the lattice.</span>
<span class="sd">        Only used if `lattice` is the name of a 1D Lattice.</span>
<span class="sd">    Lx, Ly : int</span>
<span class="sd">        Length of the lattice in x- and y-direction.</span>
<span class="sd">        Only used if `lattice` is the name of a 2D Lattice.</span>
<span class="sd">    bc_y : &#39;ladder&#39; | &#39;cylinder&#39;</span>
<span class="sd">        Boundary conditions in y-direction.</span>
<span class="sd">        Only used if `lattice` is the name of a 2D Lattice.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="n">conserve</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;conserve&#39;</span><span class="p">,</span> <span class="s1">&#39;parity&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">conserve</span> <span class="o">!=</span> <span class="s1">&#39;Sz&#39;</span>
        <span class="k">if</span> <span class="n">conserve</span> <span class="o">==</span> <span class="s1">&#39;best&#39;</span><span class="p">:</span>
            <span class="n">conserve</span> <span class="o">=</span> <span class="s1">&#39;parity&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;: set conserve to&quot;</span><span class="p">,</span> <span class="n">conserve</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">SpinHalfSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="n">conserve</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">site</span>

    <span class="k">def</span> <span class="nf">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_param</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;Sigmaz&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="o">-</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sigmax&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sigmax&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        <span class="c1"># done</span>


<span class="k">class</span> <span class="nc">TFIChain</span><span class="p">(</span><span class="n">TFIModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The :class:`TFIModel` on a Chain, suitable for TEBD.</span>

<span class="sd">    See the :class:`TFIModel` for the documentation of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="n">model_param</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lattice&#39;</span><span class="p">,</span> <span class="s2">&quot;Chain&quot;</span><span class="p">)</span>
        <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction to models</a><ul>
<li><a class="reference internal" href="#what-is-a-model">What is a model?</a></li>
<li><a class="reference internal" href="#the-hilbert-space">The Hilbert space</a></li>
<li><a class="reference internal" href="#the-geometry-lattices">The geometry : lattices</a></li>
<li><a class="reference internal" href="#implementing-you-own-model">Implementing you own model</a></li>
<li><a class="reference internal" href="#the-easy-way-to-new-models-the-multi-couplingmodel">The easy way to new models: the (Multi)CouplingModel</a></li>
<li><a class="reference internal" href="#some-final-remarks">Some final remarks</a></li>
<li><a class="reference internal" href="#full-examples">Full examples</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="intro_npc.html"
                        title="previous chapter">Introduction to np_conserved</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="intro_JordanWigner.html"
                        title="next chapter">Fermions and the Jordan-Wigner transformation</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="userguide.html">User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="userguide.html#library-overview">Library overview</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="userguide.html#content">Content</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference/tenpy.html">tenpy package</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro_JordanWigner.html" title="Fermions and the Jordan-Wigner transformation"
             >next</a> |</li>
        <li class="right" >
          <a href="intro_npc.html" title="Introduction to np_conserved"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="userguide.html" >User Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2018, TeNPy Developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>