
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Introduction to models &#8212; TeNPy 0.4.1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="_static/logo.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fermions and the Jordan-Wigner transformation" href="intro_JordanWigner.html" />
    <link rel="prev" title="Introduction to np_conserved" href="intro_npc.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro_JordanWigner.html" title="Fermions and the Jordan-Wigner transformation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="intro_npc.html" title="Introduction to np_conserved"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="userguide.html" accesskey="U">User Guide</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction-to-models">
<h1>Introduction to models<a class="headerlink" href="#introduction-to-models" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-a-model">
<h2>What is a model?<a class="headerlink" href="#what-is-a-model" title="Permalink to this headline">¶</a></h2>
<p>Abstractly, a <strong>model</strong> stands for some physical (quantum) system to be described.
For tensor networks algorithms, the model is usually specified as a Hamiltonian written in terms of second quantization.
For example, let us consider a spin-1/2 Heisenberg model described by the Hamiltonian</p>
<div class="math notranslate nohighlight">
\[H = J \sum_i S^x_i S^x_{i+1} + S^y_i S^y_{i+1} + S^z_i S^z_{i+1}\]</div>
<p>Note that a few things are defined more or less implicitly.</p>
<ul class="simple">
<li><p>The local Hilbert space: it consists of Spin-1/2 degrees of freedom with the usual spin-1/2 operators <span class="math notranslate nohighlight">\(S^x, S^y, S^z\)</span>.</p></li>
<li><p>The geometric (lattice) strucuture: above, we spoke of a 1D “chain”.</p></li>
<li><p>The boundary conditions: do we have open or periodic boundary conditions?
The “chain” suggests open boundaries, which are in most cases preferable for MPS-based methods.</p></li>
<li><p>The range of <cite>i</cite>: How many sites do we consider (for a 2D system: in each direction)?</p></li>
</ul>
<p>Obviously, these things need to be specified in TeNPy in one way or another, if we want to define a model.</p>
<p>Ultimately, our goal is to run some algorithm. Each algorithm requires the model and Hamiltonian to be specified in a particular form.
We have one class for each such required form.
For example <a class="reference internal" href="reference/tenpy.algorithms.dmrg.html#module-tenpy.algorithms.dmrg" title="tenpy.algorithms.dmrg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dmrg</span></code></a> requires an <a class="reference internal" href="reference/tenpy.models.model.MPOModel.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a>,
which contains the Hamiltonian written as an <a class="reference internal" href="reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>.
On the other hand, if we want to evolve a state with <a class="reference internal" href="reference/tenpy.algorithms.tebd.html#module-tenpy.algorithms.tebd" title="tenpy.algorithms.tebd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tebd</span></code></a>
we need a <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>, in which the Hamiltonian is written in terms of
two-site bond-terms to allow a Suzuki-Trotter decomposition of the time-evolution operator.</p>
<p>Implmenting you own model ultimatley means to get an instance of <a class="reference internal" href="reference/tenpy.models.model.MPOModel.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a> or <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
The predefined classes in the other modules under <a class="reference internal" href="reference/tenpy.models.html#module-tenpy.models" title="tenpy.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">models</span></code></a> are subclasses of at least one of those,
you will see examples later down below.</p>
</div>
<div class="section" id="the-hilbert-space">
<h2>The Hilbert space<a class="headerlink" href="#the-hilbert-space" title="Permalink to this headline">¶</a></h2>
<p>The <strong>local Hilbert</strong> space is represented by a <a class="reference internal" href="reference/tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> (read its doc-string!).
In particular, the <cite>Site</cite> contains the local <a class="reference internal" href="reference/tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> and hence the meaning of each
basis state needs to be defined.
Beside that, the site contains the local operators - those give the real meaning to the local basis.
Having the local operators in the site is very convenient, because it makes them available by name for example when you want to calculate expectation values.
The most common sites (e.g. for spins, spin-less or spin-full fermions, or bosons) are predefined
in the module <a class="reference internal" href="reference/tenpy.networks.site.html#module-tenpy.networks.site" title="tenpy.networks.site"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.networks.site</span></code></a>, but if necessary you can easily extend them
by adding further local operators or completely write your own subclasses of <a class="reference internal" href="reference/tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a>.</p>
<p>The full Hilbert space is a tensor product of the local Hilbert space on each site.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="reference/tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> of all involved sites need to have a common
<code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> in order to allow the contraction of tensors acting on the various sites.
This can be ensured with the function <a class="reference internal" href="reference/tenpy.networks.site.multi_sites_combine_charges.html#tenpy.networks.site.multi_sites_combine_charges" title="tenpy.networks.site.multi_sites_combine_charges"><code class="xref py py-func docutils literal notranslate"><span class="pre">multi_sites_combine_charges()</span></code></a>.</p>
</div>
<p>An example where <a class="reference internal" href="reference/tenpy.networks.site.multi_sites_combine_charges.html#tenpy.networks.site.multi_sites_combine_charges" title="tenpy.networks.site.multi_sites_combine_charges"><code class="xref py py-func docutils literal notranslate"><span class="pre">multi_sites_combine_charges()</span></code></a> is needed would be a coupling of different
types of sites, e.g., when a tight binding chain of fermions is coupled to some local spin degrees of freedom.
Another use case of this function would be a model with a $U(1)$ symmetry involving only half the sites, say <span class="math notranslate nohighlight">\(\sum_{i=0}^{L/2} n_{2i}\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you don’t know about the charges and <cite>np_conserved</cite> yet, but want to get started with models right away,
you can set <code class="docutils literal notranslate"><span class="pre">conserve=None</span></code> in the existing sites or use
<code class="docutils literal notranslate"><span class="pre">leg</span> <span class="pre">=</span> <span class="pre">tenpy.linalg.np_conserved.LegCharge.from_trivial(d)</span></code> for an implementation of your custom site,
where <cite>d</cite> is the dimension of the local Hilbert space.
Alternatively, you can find some introduction to the charges in the <a class="reference internal" href="intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
</div>
</div>
<div class="section" id="the-geometry-lattices">
<h2>The geometry : lattices<a class="headerlink" href="#the-geometry-lattices" title="Permalink to this headline">¶</a></h2>
<p>The geometry is usually given by some kind of <strong>lattice</strong> structure how the sites are arranged,
e.g. implicitly with the sum over nearest neighbours <span class="math notranslate nohighlight">\(\sum_{&lt;i, j&gt;}\)</span>.
In TeNPy, this is specified by a <a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a> class, which contains a unit cell of
a few <a class="reference internal" href="reference/tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> which are shifted periodically by its basis vectors to form a regular lattice.
Again, we have pre-defined some basic lattices like a <a class="reference internal" href="reference/tenpy.models.lattice.Chain.html#tenpy.models.lattice.Chain" title="tenpy.models.lattice.Chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chain</span></code></a>,
two chains coupled as a <a class="reference internal" href="reference/tenpy.models.lattice.Ladder.html#tenpy.models.lattice.Ladder" title="tenpy.models.lattice.Ladder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ladder</span></code></a> or 2D lattices like the
<a class="reference internal" href="reference/tenpy.models.lattice.Square.html#tenpy.models.lattice.Square" title="tenpy.models.lattice.Square"><code class="xref py py-class docutils literal notranslate"><span class="pre">Square</span></code></a>, <a class="reference internal" href="reference/tenpy.models.lattice.Honeycomb.html#tenpy.models.lattice.Honeycomb" title="tenpy.models.lattice.Honeycomb"><code class="xref py py-class docutils literal notranslate"><span class="pre">Honeycomb</span></code></a> and
<a class="reference internal" href="reference/tenpy.models.lattice.Kagome.html#tenpy.models.lattice.Kagome" title="tenpy.models.lattice.Kagome"><code class="xref py py-class docutils literal notranslate"><span class="pre">Kagome</span></code></a> lattices; but you are also free to define your own generalizations.
(More details on that can be found in the doc-string of <a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a>, read it!)</p>
<p><strong>Visualization</strong> of the lattice can help a lot to understand which sites are connected by what couplings.
The methods <code class="docutils literal notranslate"><span class="pre">plot_...</span></code> of the <a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a> can do a good job for a quick illustration.
We include a small image in the documation of each of the lattices.
For example, the following small script can generate the image of the Kagome lattice shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">tenpy.models.lattice</span> <span class="k">import</span> <span class="n">Kagome</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">lat</span> <span class="o">=</span> <span class="n">Kagome</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;periodic&#39;</span><span class="p">)</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_coupling</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">3.</span><span class="p">)</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_order</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_sites</span><span class="p">()</span>
<span class="n">lat</span><span class="o">.</span><span class="n">plot_basis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="_images/Kagome.png" src="_images/Kagome.png" />
<p>The lattice contains also the <strong>boundary conditions</strong> <cite>bc</cite> in each direction. It can be one of the usual <code class="docutils literal notranslate"><span class="pre">'open'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'periodic'</span></code> in each direcetion. Instead of just saying “periodic”, you can also specify a <cite>shift</cite> (except in the
first direction). This is easiest to understand at its standard usecase: DMRG on a infinite cylinder.
Going around the cylinder, you have a degree of freedom which sites to connect.
The orange markers in the following figures illustrates sites identified for a Square lattice with <code class="docutils literal notranslate"><span class="pre">bc=['periodic',</span> <span class="pre">shift]</span></code> (see <code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_bc_shift()</span></code>):</p>
<img alt="_images/square_bc_shift.png" src="_images/square_bc_shift.png" />
<p>Note that the “cylinder” axis (and direction for <span class="math notranslate nohighlight">\(k_x\)</span>) is perpendicular to the orange line connecting these
sites. The line where the cylinder is “cut open” therefore winds around the the cylinder for a non-zero <cite>shift</cite> (or
more complicated lattices without perpendicular basis).</p>
<p>MPS based algorithms like DMRG always work on purely 1D systems. Even if our model “lives” on a 2D lattice,
these algorithms require to map it onto a 1D chain (probably at the cost of longer-range interactions).
This mapping is also done in by the lattice, as it defines an <strong>order</strong> (<a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.order" title="tenpy.models.lattice.Lattice.order"><code class="xref py py-attr docutils literal notranslate"><span class="pre">order</span></code></a>) of the sites.
The methods <a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps2lat_idx" title="tenpy.models.lattice.Lattice.mps2lat_idx"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps2lat_idx()</span></code></a> and <a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.lat2mps_idx" title="tenpy.models.lattice.Lattice.lat2mps_idx"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lat2mps_idx()</span></code></a> map
indices of the MPS to and from indices of the lattice. If you obtained and array with expectation values for a given MPS,
you can use <a class="reference internal" href="reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps2lat_values" title="tenpy.models.lattice.Lattice.mps2lat_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps2lat_values()</span></code></a> to map it to lattice indices, thereby reverting the ordering.</p>
<p>Performing this mapping of the Hamiltonain from a 2D lattice to a 1D chain by hand can be a tideous process.
Therefore, we have automated this mapping in TeNPy as explained in the next section.
(Nevertheless it’s a good exercise you should do at least once in your life to understand how it works!)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A suitable order is critical for the efficiency of MPS-based algorithms.
On one hand, different orderings can lead to different MPO bond-dimensions, with direct impact on the complexity scaling.
On the other hand, it influences how much entanglement needs to go through each bonds of the underlying MPS,
e.g., the ground strate to be found in DMRG, and therefore influences the required MPS bond dimensions.
For the latter reason, the “optimal” ordering can not be known a priori and might even depend on your coupling
parameters (and the phase you are in).
In the end, you can just try different orderings and see which one works best.</p>
</div>
</div>
<div class="section" id="implementing-you-own-model">
<h2>Implementing you own model<a class="headerlink" href="#implementing-you-own-model" title="Permalink to this headline">¶</a></h2>
<p>When you want to simulate a model not provided in <a class="reference internal" href="reference/tenpy.models.html#module-tenpy.models" title="tenpy.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">models</span></code></a>, you need to implement your own model class,
lets call it <code class="docutils literal notranslate"><span class="pre">MyNewModel</span></code>.
The idea is that you define a new subclass of one or multiple of the model base classes.
For example, when you plan to do DMRG, you have to provide an MPO in a <code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code>,
so your model class should look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNewModel</span><span class="p">(</span><span class="n">MPOModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General strucutre for a model suitable for DMRG.</span>

<span class="sd">    Here is a good place to document the represented Hamiltonian and parameters.</span>

<span class="sd">    In the models of TeNPy, we usually take a single dictionary `model_params`</span>
<span class="sd">    containing all parameters, and read values out with ``tenpy.tools.params.get_parameter(...)``,</span>
<span class="sd">    The model needs to provide default values if the parameters was not specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="c1"># some code here to read out model parameters and generate H_MPO</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">somehow_generate_lattice</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="n">H_MPO</span> <span class="o">=</span> <span class="n">somehow_generate_MPO</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>
        <span class="c1"># initialize MPOModel</span>
        <span class="n">MPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">H_MPO</span><span class="p">)</span>
</pre></div>
</div>
<p>TEBD requires another representation of H in terms of bond terms <cite>H_bond</cite> given to a
<code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code>, so in this case it would look so like this instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNewModel2</span><span class="p">(</span><span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General strucutre for a model suitable for TEBD.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="c1"># some code here to read out model parameters and generate H_bond</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">somehow_generate_lattice</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="n">H_bond</span> <span class="o">=</span> <span class="n">somehow_generate_H_bond</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>
        <span class="c1"># initialize MPOModel</span>
        <span class="n">NearestNeighborModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">H_bond</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, the difficult part in these examples is to generate the <code class="docutils literal notranslate"><span class="pre">H_MPO</span></code> and <code class="docutils literal notranslate"><span class="pre">H_bond</span></code>.
Moreover, it’s quite annoying to write every model multiple times,
just because we need different representations of the same Hamiltonian.
Luckily, there is a way out in TeNPy: the CouplingModel!</p>
</div>
<div class="section" id="the-easy-way-to-new-models-the-multi-couplingmodel">
<h2>The easy way to new models: the (Multi)CouplingModel<a class="headerlink" href="#the-easy-way-to-new-models-the-multi-couplingmodel" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> provides a general, quite abstract way to specify a Hamiltonian
of two-site couplings on a given lattice.
Once initialized, its methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_onsite()</span></code> and
<a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a> allow to add onsite and coupling terms repeated over the different
unit cells of the lattice.
In that way, it basically allows a straight-forward translation of the Hamiltonian given as a math forumla
<span class="math notranslate nohighlight">\(H = \sum_{i} A_i B_{i+dx} + ...\)</span> with onsite operators <cite>A</cite>, <cite>B</cite>,… into a model class.</p>
<p>The general structure for a new model based on the <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> is then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyNewModel3</span><span class="p">(</span><span class="n">CouplingModel</span><span class="p">,</span><span class="n">MPOModel</span><span class="p">,</span><span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="o">...</span>  <span class="c1"># follow the basic steps explained below</span>
</pre></div>
</div>
<p>In the initialization method <code class="docutils literal notranslate"><span class="pre">__init__(self,</span> <span class="pre">...)</span></code> of this class you can then follow these basic steps:</p>
<ol class="arabic" start="0">
<li><p>Read out the parameters.</p></li>
<li><p>Given the parameters, determine the charges to be conserved.
Initialize the <a class="reference internal" href="reference/tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> of the local sites accordingly.</p></li>
<li><p>Define (additional) local operators needed.</p></li>
<li><p>Initialize the needed <a class="reference internal" href="reference/tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using pre-defined sites like the <a class="reference internal" href="reference/tenpy.networks.site.SpinHalfSite.html#tenpy.networks.site.SpinHalfSite" title="tenpy.networks.site.SpinHalfSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHalfSite</span></code></a> is recommended and
can replace steps 1-3.</p>
</div>
</li>
<li><p>Initialize the lattice (or if you got the lattice as a parameter, set the sites in the unit cell).</p></li>
<li><p>Initialize the <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> with <code class="docutils literal notranslate"><span class="pre">CouplingModel.__init__(self,</span> <span class="pre">lat)</span></code>.</p></li>
<li><p>Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_onsite()</span></code> and <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
to add all terms of the Hamiltonian. Here, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">nearest_neighbors</span></code> of the lattice
(and its friends for next nearest neighbors) can come in handy, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a> adds the coupling only in one direction, i.e.
not switching <cite>i</cite> and <cite>j</cite> in a <span class="math notranslate nohighlight">\(\sum_{\langle i, j\rangle}\)</span>.
If you have terms like <span class="math notranslate nohighlight">\(c^\dagger_i c_j\)</span> in your Hamiltonian, you <em>need</em> to add it in both directions to get
a hermitian Hamiltonian! Simply add another line with switched, conjugated operatores, switched (<cite>u1</cite>, <cite>u2</cite>),
and negative <cite>dx</cite>, for example when using the <a class="reference internal" href="reference/tenpy.networks.site.SpinHalfFermionSite.html#tenpy.networks.site.SpinHalfFermionSite" title="tenpy.networks.site.SpinHalfFermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHalfFermionSite</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cdu&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cdd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># h.c.</span>
<span class="c1"># (&#39;Cdd&#39; is h.c. of &#39;Cd&#39;, and &#39;Cu&#39; is h.c. of &#39;Cdu&#39;!)</span>
</pre></div>
</div>
<p>See also the other examples in <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</div>
<p>Note that the <cite>strength</cite> arguments of these functions can be (numpy) arrays for site-dependent couplings.
If you need to add or multipliy some parameters of the model for the <cite>strength</cite> of certain terms,
it is recommended use <code class="docutils literal notranslate"><span class="pre">np.asarray</span></code> beforehand – in that way lists will also work fine.</p>
</li>
<li><p>Finally, if you derived from the <a class="reference internal" href="reference/tenpy.models.model.MPOModel.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a>, you can call
<a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.calc_H_MPO" title="tenpy.models.model.CouplingModel.calc_H_MPO"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_H_MPO()</span></code></a> to build the MPO and use it for the initialization
as <code class="docutils literal notranslate"><span class="pre">MPOModel.__init__(self,</span> <span class="pre">lat,</span> <span class="pre">self.calc_H_MPO())</span></code>.</p></li>
<li><p>Similarly, if you derived from the <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>, you can call
<a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.calc_H_MPO" title="tenpy.models.model.CouplingModel.calc_H_MPO"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_H_MPO()</span></code></a> to initialze it
as <code class="docutils literal notranslate"><span class="pre">NearestNeighborModel.__init__(self,</span> <span class="pre">lat,</span> <span class="pre">self.calc_H_bond())</span></code>.
Calling <code class="docutils literal notranslate"><span class="pre">self.calc_H_bond()</span></code> will fail for models which are not nearest-neighbors (with respect to the MPS ordering),
so you should only subclass the <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a> if the lattice is a simple
<a class="reference internal" href="reference/tenpy.models.lattice.Chain.html#tenpy.models.lattice.Chain" title="tenpy.models.lattice.Chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chain</span></code></a>.</p></li>
</ol>
<p>The <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> works for Hamiltonians which are a sum of terms involving at most two sites.
The generalization <a class="reference internal" href="reference/tenpy.models.model.MultiCouplingModel.html#tenpy.models.model.MultiCouplingModel" title="tenpy.models.model.MultiCouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCouplingModel</span></code></a> can be used for Hamlitonians with
coupling terms acting on more than 2 sites at once. Follow the exact same steps in the initialization, and just use the
<a class="reference internal" href="reference/tenpy.models.model.MultiCouplingModel.html#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_multi_coupling()</span></code></a> instead or in addition to the
<a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.
A prototypical example is the exactly solvable <a class="reference internal" href="reference/tenpy.models.toric_code.ToricCode.html#tenpy.models.toric_code.ToricCode" title="tenpy.models.toric_code.ToricCode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricCode</span></code></a>.</p>
<p>The code of the module <a class="reference internal" href="reference/tenpy.models.xxz_chain.html#module-tenpy.models.xxz_chain" title="tenpy.models.xxz_chain"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.models.xxz_chain</span></code></a> is included below as an illustrative example how to implemnet a
Model. The implementation of the <a class="reference internal" href="reference/tenpy.models.xxz_chain.XXZChain.html#tenpy.models.xxz_chain.XXZChain" title="tenpy.models.xxz_chain.XXZChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">XXZChain</span></code></a> directly follows the steps
outline above.
The <a class="reference internal" href="reference/tenpy.models.xxz_chain.XXZChain2.html#tenpy.models.xxz_chain.XXZChain2" title="tenpy.models.xxz_chain.XXZChain2"><code class="xref py py-class docutils literal notranslate"><span class="pre">XXZChain2</span></code></a> implements the very same model, but based on the
<a class="reference internal" href="reference/tenpy.models.model.CouplingMPOModel.html#tenpy.models.model.CouplingMPOModel" title="tenpy.models.model.CouplingMPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingMPOModel</span></code></a> explained in the next section.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Prototypical example of a 1D quantum model: the spin-1/2 XXZ chain.</span>

<span class="sd">The XXZ chain is contained in the more general :class:`~tenpy.models.spins.SpinChain`; the idea of</span>
<span class="sd">this module is more to serve as a pedagogical example for a model.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018-2019 TeNPy Developers, GNU GPLv3</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.lattice</span> <span class="k">import</span> <span class="n">Site</span><span class="p">,</span> <span class="n">Chain</span>
<span class="kn">from</span> <span class="nn">.model</span> <span class="k">import</span> <span class="n">CouplingModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">,</span> <span class="n">MPOModel</span><span class="p">,</span> <span class="n">CouplingMPOModel</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">np_conserved</span> <span class="k">as</span> <span class="n">npc</span>
<span class="kn">from</span> <span class="nn">..tools.params</span> <span class="k">import</span> <span class="n">get_parameter</span><span class="p">,</span> <span class="n">unused_parameters</span>
<span class="kn">from</span> <span class="nn">..networks.site</span> <span class="k">import</span> <span class="n">SpinHalfSite</span>  <span class="c1"># if you want to use the predefined site</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;XXZChain&#39;</span><span class="p">,</span> <span class="s1">&#39;XXZChain2&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">XXZChain</span><span class="p">(</span><span class="n">CouplingModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">,</span> <span class="n">MPOModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Spin-1/2 XXZ chain with Sz conservation.</span>

<span class="sd">    The Hamiltonian reads:</span>

<span class="sd">    .. math ::</span>
<span class="sd">        H = \sum_i \mathtt{Jxx}/2 (S^{+}_i S^{-}_{i+1} + S^{-}_i S^{+}_{i+1})</span>
<span class="sd">                 + \mathtt{Jz} S^z_i S^z_{i+1} \\</span>
<span class="sd">            - \sum_i \mathtt{hz} S^z_i</span>

<span class="sd">    All parameters are collected in a single dictionary `model_params` and read out with</span>
<span class="sd">    :func:`~tenpy.tools.params.get_parameter`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        Length of the chain.</span>
<span class="sd">    Jxx, Jz, hz : float | array</span>
<span class="sd">        Couplings as defined for the Hamiltonian above.</span>
<span class="sd">    bc_MPS : {&#39;finite&#39; | &#39;infinte&#39;}</span>
<span class="sd">        MPS boundary conditions. Coupling boundary conditions are chosen appropriately.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="c1"># 0) read out/set default parameters</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;XXZChain&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Jxx</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;Jxx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">asarray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Jz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;Jz&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">hz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">bc_MPS</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;bc_MPS&#39;</span><span class="p">,</span> <span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">unused_parameters</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>  <span class="c1"># checks for mistyped parameters</span>
        <span class="c1"># 1-3):</span>
        <span class="n">USE_PREDEFINED_SITE</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">USE_PREDEFINED_SITE</span><span class="p">:</span>
            <span class="c1"># 1) charges of the physical leg. The only time that we actually define charges!</span>
            <span class="n">leg</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">ChargeInfo</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;2*Sz&#39;</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># 2) onsite operators</span>
            <span class="n">Sp</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
            <span class="n">Sm</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>
            <span class="n">Sz</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]]</span>
            <span class="c1"># (Can&#39;t define Sx and Sy as onsite operators: they are incompatible with Sz charges.)</span>
            <span class="c1"># 3) local physical site</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">],</span> <span class="n">Sp</span><span class="o">=</span><span class="n">Sp</span><span class="p">,</span> <span class="n">Sm</span><span class="o">=</span><span class="n">Sm</span><span class="p">,</span> <span class="n">Sz</span><span class="o">=</span><span class="n">Sz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># there is a site for spin-1/2 defined in TeNPy, so just we can just use it</span>
            <span class="c1"># replacing steps 1-3)</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">SpinHalfSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
        <span class="c1"># 4) lattice</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="s1">&#39;periodic&#39;</span> <span class="k">if</span> <span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span> <span class="k">else</span> <span class="s1">&#39;open&#39;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">bc_MPS</span><span class="o">=</span><span class="n">bc_MPS</span><span class="p">)</span>
        <span class="c1"># 5) initialize CouplingModel</span>
        <span class="n">CouplingModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># 6) add terms of the Hamiltonian</span>
        <span class="c1"># (u is always 0 as we have only one site in the unit cell)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">hz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># h.c.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 7) initialize H_MPO</span>
        <span class="n">MPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_H_MPO</span><span class="p">())</span>
        <span class="c1"># 8) initialize H_bond (the order of 7/8 doesn&#39;t matter)</span>
        <span class="n">NearestNeighborModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_H_bond</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">XXZChain2</span><span class="p">(</span><span class="n">CouplingMPOModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Another implementation of the Spin-1/2 XXZ chain with Sz conservation.</span>

<span class="sd">    This implementation takes the same parameters as the :class:`XXZChain`, but is implemented</span>
<span class="sd">    based on the :class:`~tenpy.models.model.CouplingMPOModel`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="n">model_params</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lattice&#39;</span><span class="p">,</span> <span class="s2">&quot;Chain&quot;</span><span class="p">)</span>
        <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SpinHalfSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>  <span class="c1"># use predefined Site</span>

    <span class="k">def</span> <span class="nf">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="c1"># read out parameters</span>
        <span class="n">Jxx</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;Jxx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">Jz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;Jz&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">hz</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># add terms</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">hz</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Jxx</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># h.c.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">Jz</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-easy-easy-way-the-couplingmpomodel">
<h2>The easy easy way: the CouplingMPOModel<a class="headerlink" href="#the-easy-easy-way-the-couplingmpomodel" title="Permalink to this headline">¶</a></h2>
<p>Since many of the basic steps above are always the same, we don’t need to repeat them all the time.
So we have yet another class helping to structure the initialization of models: the <a class="reference internal" href="reference/tenpy.models.model.CouplingMPOModel.html#tenpy.models.model.CouplingMPOModel" title="tenpy.models.model.CouplingMPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingMPOModel</span></code></a>.
The general structure of the  class is like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CouplingMPOModel</span><span class="p">(</span><span class="n">CouplingModel</span><span class="p">,</span><span class="n">MPOModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="c1"># ... follow the basic steps 1-8 using the methods</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">)</span>  <span class="c1"># for step 4</span>
        <span class="c1"># ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">)</span> <span class="c1"># for step 6</span>
        <span class="c1"># ...</span>

    <span class="k">def</span> <span class="nf">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="c1"># You should overwrite this</span>

    <span class="k">def</span> <span class="nf">init_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">)</span> <span class="c1"># for steps 1-3</span>
        <span class="c1"># initialize an arbitrary pre-defined lattice</span>
        <span class="c1"># using model_params[&#39;lattice&#39;]</span>

    <span class="k">def</span> <span class="nf">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_param</span><span class="p">):</span>
        <span class="c1"># does nothing.</span>
        <span class="c1"># You should overwrite this</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="reference/tenpy.models.xxz_chain.XXZChain2.html#tenpy.models.xxz_chain.XXZChain2" title="tenpy.models.xxz_chain.XXZChain2"><code class="xref py py-class docutils literal notranslate"><span class="pre">XXZChain2</span></code></a> included above illustrates, how it can be used.
You need to implement steps 1-3) by overwriting the method <a class="reference internal" href="reference/tenpy.models.model.CouplingMPOModel.html#tenpy.models.model.CouplingMPOModel.init_sites" title="tenpy.models.model.CouplingMPOModel.init_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_sites()</span></code></a>
Step 4) is performed in the method <a class="reference internal" href="reference/tenpy.models.model.CouplingMPOModel.html#tenpy.models.model.CouplingMPOModel.init_lattice" title="tenpy.models.model.CouplingMPOModel.init_lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_lattice()</span></code></a>, which initializes arbitrary 1D or 2D
lattices; by default a simple 1D chain.
If your model only works for specific lattices, you can overwrite this method in your own class.
Step 6) should be done by overwriting the method <a class="reference internal" href="reference/tenpy.models.model.CouplingMPOModel.html#tenpy.models.model.CouplingMPOModel.init_terms" title="tenpy.models.model.CouplingMPOModel.init_terms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_terms()</span></code></a>.
Steps 5,7,8 and calls to the <cite>init_…</cite> methods for the other steps are done automatically if you just call the
<code class="docutils literal notranslate"><span class="pre">CouplingMPOModel.__init__(self,</span> <span class="pre">model_param)</span></code>.</p>
<p>The <a class="reference internal" href="reference/tenpy.models.xxz_chain.XXZChain.html#tenpy.models.xxz_chain.XXZChain" title="tenpy.models.xxz_chain.XXZChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">XXZChain</span></code></a> and <a class="reference internal" href="reference/tenpy.models.xxz_chain.XXZChain2.html#tenpy.models.xxz_chain.XXZChain2" title="tenpy.models.xxz_chain.XXZChain2"><code class="xref py py-class docutils literal notranslate"><span class="pre">XXZChain2</span></code></a> work only with the
<a class="reference internal" href="reference/tenpy.models.lattice.Chain.html#tenpy.models.lattice.Chain" title="tenpy.models.lattice.Chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chain</span></code></a> as lattice, since they are derived from the <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
This allows to use them for TEBD in 1D (yeah!), but we can’t get the MPO for DMRG on a e.g. a <a class="reference internal" href="reference/tenpy.models.lattice.Square.html#tenpy.models.lattice.Square" title="tenpy.models.lattice.Square"><code class="xref py py-class docutils literal notranslate"><span class="pre">Square</span></code></a>
lattice cylinder - although it’s intuitively clear, what the hamiltonian there should be: just put the nearest-neighbor
coupling on each bond of the 2D lattice.</p>
<p>It’s not possible to generalize a <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a> to an arbitrary lattice where it’s
no longer nearest Neigbors in the MPS sense, but we can go the other way around:
first write the model on an arbitrary 2D lattice and then restrict it to a 1D chain to make it a <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.</p>
<p>Let me illustrate this with another standard example model: the transverse field Ising model, imlemented in the module
<a class="reference internal" href="reference/tenpy.models.tf_ising.html#module-tenpy.models.tf_ising" title="tenpy.models.tf_ising"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.models.tf_ising</span></code></a> included below.
The <a class="reference internal" href="reference/tenpy.models.tf_ising.TFIModel.html#tenpy.models.tf_ising.TFIModel" title="tenpy.models.tf_ising.TFIModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIModel</span></code></a> works for arbitrary 1D or 2D lattices.
The <a class="reference internal" href="reference/tenpy.models.tf_ising.TFIChain.html#tenpy.models.tf_ising.TFIChain" title="tenpy.models.tf_ising.TFIChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">TFIChain</span></code></a> is then taking the exact same model making a <a class="reference internal" href="reference/tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>,
which only works for the 1D chain.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Prototypical example of a quantum model: the transverse field Ising model.</span>

<span class="sd">Like the :class:`~tenpy.models.xxz_chain.XXZChain`, the transverse field ising chain</span>
<span class="sd">:class:`TFIChain` is contained in the more general :class:`~tenpy.models.spins.SpinChain`;</span>
<span class="sd">the idea is more to serve as a pedagogical example for a &#39;model&#39;.</span>

<span class="sd">We choose the field along z to allow to conserve the parity, if desired.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018-2019 TeNPy Developers, GNU GPLv3</span>

<span class="kn">from</span> <span class="nn">.model</span> <span class="k">import</span> <span class="n">CouplingMPOModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span>
<span class="kn">from</span> <span class="nn">..tools.params</span> <span class="k">import</span> <span class="n">get_parameter</span>
<span class="kn">from</span> <span class="nn">..networks.site</span> <span class="k">import</span> <span class="n">SpinHalfSite</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TFIModel&#39;</span><span class="p">,</span> <span class="s1">&#39;TFIChain&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TFIModel</span><span class="p">(</span><span class="n">CouplingMPOModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transverse field Ising model on a general lattice.</span>

<span class="sd">    The Hamiltonian reads:</span>

<span class="sd">    .. math ::</span>
<span class="sd">        H = - \sum_{\langle i,j\rangle, i &lt; j} \mathtt{J} \sigma^x_i \sigma^x_{j}</span>
<span class="sd">            - \sum_{i} \mathtt{g} \sigma^z_i</span>

<span class="sd">    Here, :math:`\langle i,j \rangle, i&lt; j` denotes nearest neighbor pairs, each pair appearing</span>
<span class="sd">    exactly once.</span>
<span class="sd">    All parameters are collected in a single dictionary `model_params` and read out with</span>
<span class="sd">    :func:`~tenpy.tools.params.get_parameter`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    conserve : None | &#39;parity&#39;</span>
<span class="sd">        What should be conserved. See :class:`~tenpy.networks.Site.SpinHalfSite`.</span>
<span class="sd">    J, g : float | array</span>
<span class="sd">        Couplings as defined for the Hamiltonian above.</span>
<span class="sd">    lattice : str | :class:`~tenpy.models.lattice.Lattice`</span>
<span class="sd">        Instance of a lattice class for the underlaying geometry.</span>
<span class="sd">        Alternatively a string being the name of one of the Lattices defined in</span>
<span class="sd">        :mod:`~tenpy.models.lattice`, e.g. ``&quot;Chain&quot;, &quot;Square&quot;, &quot;HoneyComb&quot;, ...``.</span>
<span class="sd">    bc_MPS : {&#39;finite&#39; | &#39;infinte&#39;}</span>
<span class="sd">        MPS boundary conditions along the x-direction.</span>
<span class="sd">        For &#39;infinite&#39; boundary conditions, repeat the unit cell in x-direction.</span>
<span class="sd">        Coupling boundary conditions in x-direction are chosen accordingly.</span>
<span class="sd">        Only used if `lattice` is a string.</span>
<span class="sd">    order : string</span>
<span class="sd">        Ordering of the sites in the MPS, e.g. &#39;default&#39;, &#39;snake&#39;;</span>
<span class="sd">        see :meth:`~tenpy.models.lattice.Lattice.ordering`.</span>
<span class="sd">        Only used if `lattice` is a string.</span>
<span class="sd">    L : int</span>
<span class="sd">        Lenght of the lattice.</span>
<span class="sd">        Only used if `lattice` is the name of a 1D Lattice.</span>
<span class="sd">    Lx, Ly : int</span>
<span class="sd">        Length of the lattice in x- and y-direction.</span>
<span class="sd">        Only used if `lattice` is the name of a 2D Lattice.</span>
<span class="sd">    bc_y : &#39;ladder&#39; | &#39;cylinder&#39;</span>
<span class="sd">        Boundary conditions in y-direction.</span>
<span class="sd">        Only used if `lattice` is the name of a 2D Lattice.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="n">conserve</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;conserve&#39;</span><span class="p">,</span> <span class="s1">&#39;parity&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">conserve</span> <span class="o">!=</span> <span class="s1">&#39;Sz&#39;</span>
        <span class="k">if</span> <span class="n">conserve</span> <span class="o">==</span> <span class="s1">&#39;best&#39;</span><span class="p">:</span>
            <span class="n">conserve</span> <span class="o">=</span> <span class="s1">&#39;parity&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;: set conserve to&quot;</span><span class="p">,</span> <span class="n">conserve</span><span class="p">)</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">SpinHalfSite</span><span class="p">(</span><span class="n">conserve</span><span class="o">=</span><span class="n">conserve</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">site</span>

    <span class="k">def</span> <span class="nf">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_onsite</span><span class="p">(</span><span class="o">-</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;Sigmaz&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="o">-</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sigmax&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sigmax&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        <span class="c1"># done</span>


<span class="k">class</span> <span class="nc">TFIChain</span><span class="p">(</span><span class="n">TFIModel</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The :class:`TFIModel` on a Chain, suitable for TEBD.</span>

<span class="sd">    See the :class:`TFIModel` for the documentation of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="n">model_params</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lattice&#39;</span><span class="p">,</span> <span class="s2">&quot;Chain&quot;</span><span class="p">)</span>
        <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="some-final-remarks">
<h2>Some final remarks<a class="headerlink" href="#some-final-remarks" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Needless to say that we have also various predefined models under <a class="reference internal" href="reference/tenpy.models.html#module-tenpy.models" title="tenpy.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.models</span></code></a>.</p></li>
<li><p>Of course, an MPO is all you need to initialize a <a class="reference internal" href="reference/tenpy.models.model.MPOModel.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a> to be used for DMRG; you don’t have to use the <a class="reference internal" href="reference/tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a>
or <a class="reference internal" href="reference/tenpy.models.model.CouplingMPOModel.html#tenpy.models.model.CouplingMPOModel" title="tenpy.models.model.CouplingMPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingMPOModel</span></code></a>.
For example an exponentially decaying long-range interactions are not supported by the coupling model but straight-forward to include to an MPO, as demonstrated in the example <code class="docutils literal notranslate"><span class="pre">examples/mpo_exponentially_decaying.py</span></code>.</p></li>
<li><p>If the model of your interest contains Fermions, you should read the <a class="reference internal" href="intro_JordanWigner.html"><span class="doc">Fermions and the Jordan-Wigner transformation</span></a>.</p></li>
<li><p>We suggest writing the model to take a single parameter dicitionary for the initialization, which is to be read out
inside the class with <a class="reference internal" href="reference/tenpy.tools.params.get_parameter.html#tenpy.tools.params.get_parameter" title="tenpy.tools.params.get_parameter"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_parameter()</span></code></a>.
Read the doc-string of this function for more details on why this is a good idea.
The <code class="docutils literal notranslate"><span class="pre">CouplingMPOModel.__init__(...)</span></code> calls <a class="reference internal" href="reference/tenpy.tools.params.unused_parameters.html#tenpy.tools.params.unused_parameters" title="tenpy.tools.params.unused_parameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">unused_parameters()</span></code></a>, helping to avoid typos in the specified parameters.</p></li>
<li><p>When you write a model and want to include a test that it can be at least constructed,
take a look at <code class="docutils literal notranslate"><span class="pre">tests/test_model.py</span></code>.</p></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction to models</a><ul>
<li><a class="reference internal" href="#what-is-a-model">What is a model?</a></li>
<li><a class="reference internal" href="#the-hilbert-space">The Hilbert space</a></li>
<li><a class="reference internal" href="#the-geometry-lattices">The geometry : lattices</a></li>
<li><a class="reference internal" href="#implementing-you-own-model">Implementing you own model</a></li>
<li><a class="reference internal" href="#the-easy-way-to-new-models-the-multi-couplingmodel">The easy way to new models: the (Multi)CouplingModel</a></li>
<li><a class="reference internal" href="#the-easy-easy-way-the-couplingmpomodel">The easy easy way: the CouplingMPOModel</a></li>
<li><a class="reference internal" href="#some-final-remarks">Some final remarks</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="intro_npc.html"
                        title="previous chapter">Introduction to np_conserved</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="intro_JordanWigner.html"
                        title="next chapter">Fermions and the Jordan-Wigner transformation</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="userguide.html">User Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="userguide.html#content">Content</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="INSTALL.html">Installation instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="literature.html">Literature</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro_npc.html">Introduction to np_conserved</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Introduction to models</a></li>
<li class="toctree-l3"><a class="reference internal" href="intro_JordanWigner.html">Fermions and the Jordan-Wigner transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l3"><a class="reference internal" href="todo.html">To-Do list</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html">CHANGELOG</a></li>
<li class="toctree-l3"><a class="reference internal" href="license.html">TeNPy developer team</a></li>
<li class="toctree-l3"><a class="reference internal" href="license.html#license">License</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Tenpy Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="intro_JordanWigner.html" title="Fermions and the Jordan-Wigner transformation"
             >next</a> |</li>
        <li class="right" >
          <a href="intro_npc.html" title="Introduction to np_conserved"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="userguide.html" >User Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Nov 18, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>