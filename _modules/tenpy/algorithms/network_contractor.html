
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tenpy.algorithms.network_contractor &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tenpy.algorithms.network_contractor</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Network Contractor</span>

<span class="sd">A tool to contract a network of multiple tensors.</span>

<span class="sd">This is an implementation of &#39;NCON: A tensor network contractor for MATLAB&#39;</span>
<span class="sd">by Robert N. C. Pfeifer, Glen Evenbly, Sukhwinder Singh, Guifre Vidal, see :arxiv:`1402.0939`</span>

<span class="sd">.. todo ::</span>
<span class="sd">    - implement or wrap netcon.m, a function to find optimal contractionn sequences</span>
<span class="sd">        (:arxiv:`1304.6112`)</span>
<span class="sd">    - improve helpfulness of Warnings</span>
<span class="sd">    - _do_trace: trace over all pairs of legs at once. need the corresponding npc function first.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">np_conserved</span> <span class="k">as</span> <span class="n">npc</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;outer_product&#39;</span><span class="p">,</span> <span class="s1">&#39;contract&#39;</span><span class="p">]</span>

<span class="n">outer_product</span> <span class="o">=</span> <span class="o">-</span><span class="mi">66666666</span>  <span class="c1"># a constant that represents an outer product in the sequence of ncon</span>


<div class="viewcode-block" id="contract"><a class="viewcode-back" href="../../../reference/tenpy.algorithms.network_contractor.html#tenpy.algorithms.network_contractor.contract">[docs]</a><span class="k">def</span> <span class="nf">contract</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">,</span> <span class="n">tensor_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leg_contractions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">open_legs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Contract a network of tensors.</span>
<span class="sd">    Based on the MatLab function ncon.m as described in :arxiv:`1402.0939`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_list : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        The tensors to be contracted.</span>
<span class="sd">    leg_contractions : list of ``[n1, l1, n2, l2]``</span>
<span class="sd">        A list of contraction instructions. An entry of leg_contractions has the form</span>
<span class="sd">        ``[n1, l1, n2, l2]``, where ``n1, n2`` are entries of `tensor_names` and each identify an</span>
<span class="sd">        :class:`~tenpy.linalg.np_conserved.Array` in `tensor_list`.</span>
<span class="sd">        ``l1, l2`` are leg labels of the corresponding :class:`~tenpy.linalg.np_conserved.Array`.</span>
<span class="sd">        The instruction implies to contract leg ``l1`` of tensor ``n1``</span>
<span class="sd">        with leg ``l2`` of tensor ``n2``.</span>
<span class="sd">    open_legs : list of ``[n1, l1, l]``</span>
<span class="sd">        A list of instructions for &quot;open&quot; (uncontracted) legs.</span>
<span class="sd">        ``[n1, l1, l]`` implies that leg ``l1`` of tensor ``n1`` is not contracted</span>
<span class="sd">        and is labelled ``l`` in the result.</span>
<span class="sd">    tensor_names : list of str</span>
<span class="sd">        A list of names for each tensor, to be used in `leg_contractions` and `open_legs`.</span>
<span class="sd">        The default value is list(range(len(tensor_list))), so that the tensor &quot;names&quot; are</span>
<span class="sd">        ``0, 1, 2, ...``.</span>
<span class="sd">    sequence : list of int</span>
<span class="sd">        The order in which the leg_contractions are to be performed.</span>
<span class="sd">        An entry of network_contractor.outer_product indicates performing an outer product.</span>
<span class="sd">        This corresponds to the zero-in-sequence convention of :arxiv:`1304.6112`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : :class:`Array` | complex</span>
<span class="sd">        The number or tensor resulting from the contraction.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">leg_contractions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">leg_contractions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">open_legs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">open_legs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># translate tensor names to the numbers used for indexing tensor_list</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_contractions</span><span class="p">)):</span>
        <span class="n">leg_contractions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leg_contractions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">leg_contractions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leg_contractions</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">open_legs</span><span class="p">)):</span>
        <span class="n">open_legs</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">open_legs</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># default sequence</span>
    <span class="k">if</span> <span class="n">sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_contractions</span><span class="p">)))</span>

    <span class="c1"># translate leg_contractions and open_legs to a leg_links list as used by _ncon</span>
    <span class="c1"># initialise leg_links</span>
    <span class="n">leg_links</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">tensor_list</span><span class="p">:</span>
        <span class="n">leg_links</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">legs</span><span class="p">))</span>

    <span class="c1"># fill in the contractions</span>
    <span class="n">contraction_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">new_sequence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">outer_product</span><span class="p">:</span>
            <span class="n">new_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outer_product</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">con</span> <span class="o">=</span> <span class="n">leg_contractions</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">leg_idx1</span> <span class="o">=</span> <span class="n">tensor_list</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">leg_idx2</span> <span class="o">=</span> <span class="n">tensor_list</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">leg_idx1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Multiple contradictory contractions for the leg &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                               <span class="s1">&#39; of tensor &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tensor_names</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39;were supplied&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">leg_idx2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Multiple contradictory contractions for the leg &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">con</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span>
                               <span class="s1">&#39; of tensor &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tensor_names</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39;were supplied&#39;</span><span class="p">)</span>

        <span class="n">leg_links</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">leg_idx1</span><span class="p">]</span> <span class="o">=</span> <span class="n">contraction_counter</span>
        <span class="n">leg_links</span><span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">leg_idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">contraction_counter</span>
        <span class="n">new_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contraction_counter</span><span class="p">)</span>
        <span class="n">contraction_counter</span> <span class="o">=</span> <span class="n">contraction_counter</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># fill in open legs</span>
    <span class="n">final_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">open_leg_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">open_legs</span><span class="p">:</span>
        <span class="n">leg_idx</span> <span class="o">=</span> <span class="n">tensor_list</span><span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">leg_links</span><span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">leg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">open_leg_counter</span>
        <span class="n">open_leg_counter</span> <span class="o">=</span> <span class="n">open_leg_counter</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">final_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># call _ncon and relabel the results&#39; legs</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_ncon</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">,</span> <span class="n">new_sequence</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="n">final_labels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span></div>


<span class="k">def</span> <span class="nf">_ncon</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for contract.</span>

<span class="sd">    _ncon is a python implementation of ncon.m (:arxiv:`1304.6112`) for tenpy :class:&#39;Array&#39;s</span>
<span class="sd">    ncon is a wrapper that translates from a more python/tenpy input style</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_list : list of :class:&#39;Array&#39;</span>
<span class="sd">        Tensors to be contracted.</span>
<span class="sd">    leg_links : list of list of int</span>
<span class="sd">        Each entry of leg_links describes the connectivity of the corresponding tensor in</span>
<span class="sd">        `tensor_list`.</span>
<span class="sd">        Each entry is a list that has an entry for each leg of the corresponding tensor.</span>
<span class="sd">        Values ``0,1,2,...`` are labels of contracted legs and should appear</span>
<span class="sd">        exactly twice in `leg_links`.</span>
<span class="sd">        Values ``-1,-2,-3,...`` are labels of uncontracted legs and indicate the final ordering</span>
<span class="sd">        (``-1`` is first axis).</span>
<span class="sd">    sequence : list of int</span>
<span class="sd">        The order in which the contractions are to be performed.</span>
<span class="sd">        An entry of network_contractor.outer_product indicates performing an outer product.</span>
<span class="sd">        This corresponds to the zero-in-sequence convention of :arxiv:`1304.6112`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : :class:`Array` | complex</span>
<span class="sd">        The number or tensor resulting from the contraction.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tensor_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">)</span>

    <span class="c1"># check contractibility of legs?</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">outer_product</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">outer_product</span><span class="p">:</span>
            <span class="c1"># outer product</span>
            <span class="n">tensor_list</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">,</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">_outer_product</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># identify and perform tensor contraction</span>
            <span class="c1"># find tensors that the index sequence[0] corresponds to</span>
            <span class="n">tensors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                    <span class="n">tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># its a trace</span>

                <span class="c1"># find all traced indices on that tensor</span>
                <span class="n">traced_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">traced_indices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">traced_indices</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="p">]</span>

                <span class="c1"># check if this is in accordance with sequence and update sequence</span>
                <span class="n">doing_traces</span><span class="p">,</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">_find_in_sequence</span><span class="p">(</span><span class="n">traced_indices</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">traced_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">doing_traces</span><span class="p">)):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Suboptimal contraction sequence. When tracing legs &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="n">doing_traces</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; the legs &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                            <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">doing_traces</span><span class="p">,</span> <span class="n">traced_indices</span><span class="p">)))</span> <span class="o">+</span>
                                  <span class="s1">&#39;should also be traced&#39;</span><span class="p">)</span>
                <span class="c1"># TODO translate this back to human readable leg label?</span>

                <span class="c1"># perform traces</span>
                <span class="n">tensor_list</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> \
                    <span class="n">_do_trace</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">doing_traces</span><span class="p">)</span>

                <span class="c1"># update leg links</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">doing_traces</span><span class="p">:</span>
                    <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># its a contraction</span>

                <span class="c1"># find all other contracted legs between the two tensors</span>
                <span class="n">common_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                        <span class="n">common_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c1"># check if this is in accordance with sequence</span>
                <span class="n">contraction_indices</span><span class="p">,</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">_find_in_sequence</span><span class="p">(</span><span class="n">common_indices</span><span class="p">,</span> <span class="n">sequence</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">contraction_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">common_indices</span><span class="p">)):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Suboptimal contraction sequence. When contracting legs &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                        <span class="n">contraction_indices</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; the legs &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                            <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">contraction_indices</span><span class="p">,</span> <span class="n">common_indices</span><span class="p">)))</span> <span class="o">+</span>
                                  <span class="s1">&#39;should also be traced&#39;</span><span class="p">)</span>
                    <span class="c1"># TODO translate this back to human readable leg names</span>

                <span class="c1"># are there traced indices on either of these tensors?</span>
                <span class="c1"># noinspection PyArgumentList</span>
                <span class="n">traces0</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="p">]</span>
                <span class="n">traces1</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">item</span> <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">traces1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;Suboptimal contraction sequence. When processing &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s1">&#39; one of the involved tensors have legs that could be traced over first&#39;</span><span class="p">)</span>
                    <span class="c1"># TODO human readable identifier</span>
                <span class="c1"># contract all contraction_indices and update leg_links</span>
                <span class="n">tensor_list</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> \
                    <span class="n">_tcontract</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">tensor_list</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                               <span class="n">leg_links</span><span class="p">[</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">contraction_indices</span><span class="p">)</span>
                <span class="n">tensor_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">leg_links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">tensor_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_find_in_sequence</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for _ncon</span>

<span class="sd">    check if the supplied indices appear at the beggining of sequence</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices : list of int</span>
<span class="sd">    sequence : list of int</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idcs : list of int</span>
<span class="sd">        All the given indices that appear consecutively at the front of sequence</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">ptr</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">rtn_indices</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[:</span><span class="n">ptr</span><span class="p">]</span>
    <span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ptr</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">rtn_indices</span><span class="p">,</span> <span class="n">sequence</span>


<span class="k">def</span> <span class="nf">_do_trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">leg_link</span><span class="p">,</span> <span class="n">traced_indices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for _ncon</span>

<span class="sd">    Trace over pair(s) of legs on a given tensor</span>
<span class="sd">    Update the leg_link entry</span>
<span class="sd">    .. todo :</span>
<span class="sd">        perform all traces simultaneously</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:&#39;Array&#39;</span>
<span class="sd">        the tensor to perform traces on</span>
<span class="sd">    leg_link : list of int</span>
<span class="sd">        the leg_links entry of a</span>
<span class="sd">    traced_indices list of int</span>
<span class="sd">        the labels of the legs to be traced. each should appear twice in leg_link</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : :class:&#39;Array</span>
<span class="sd">        the traced tensor</span>
<span class="sd">    leg_link : list of int</span>
<span class="sd">        the updated entry for leg_links</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">untraced_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traced_indices</span><span class="p">,</span> <span class="n">leg_link</span><span class="p">))</span>

    <span class="c1"># sort traced legs into two blocks blocks to trace over</span>
    <span class="n">block_a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">block_b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">block_untraced</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">traced_indices</span><span class="p">:</span>
        <span class="c1"># position of first and last appearance of idx in leg_labels</span>
        <span class="n">block_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leg_link</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
        <span class="n">block_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_link</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">leg_link</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">untraced_indices</span><span class="p">:</span>
        <span class="n">block_untraced</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leg_link</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

    <span class="n">new_order</span> <span class="o">=</span> <span class="n">block_untraced</span> <span class="o">+</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block_a</span><span class="p">))</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">[</span><span class="n">block_a</span><span class="p">,</span> <span class="n">block_b</span><span class="p">]]</span>
    <span class="n">a</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_untraced</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">leg_link</span> <span class="o">=</span> <span class="n">untraced_indices</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">leg_link</span>


<span class="k">def</span> <span class="nf">_tcontract</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">links1</span><span class="p">,</span> <span class="n">links2</span><span class="p">,</span> <span class="n">contract_legs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function for _ncon.</span>

<span class="sd">    Contract two tensors along one or multiple axis</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t1 : :class:&#39;Array&#39;</span>
<span class="sd">        The first tensor.</span>
<span class="sd">    t2 : :class:&#39;Array&#39;</span>
<span class="sd">        The second tensor.</span>
<span class="sd">    links1 : list of int</span>
<span class="sd">        The leg_links entry of the first tensor</span>
<span class="sd">    links2 : list of int</span>
<span class="sd">        The leg_links entry of the second tensor</span>
<span class="sd">    contract_legs : list of int</span>
<span class="sd">        The labels of the legs to be contracted. Each should appear exactly once in links1 and exactly once in links2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : :class:&#39;Array&#39;</span>
<span class="sd">        The result of the pairwise contraction</span>
<span class="sd">    links : list of int</span>
<span class="sd">        a leg_links entry for the res tensor</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if either tensor is not an :class:&#39;Array&#39; try converting</span>
    <span class="c1"># this may occur if a closed disconnected diagram is part of the contraction.</span>
    <span class="c1"># ncon will then try to process the resulting number with _tcontract of _outer_product</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray_trivial</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray_trivial</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

    <span class="c1"># find uncontracted legs</span>
    <span class="n">free_legs_1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">contract_legs</span><span class="p">,</span> <span class="n">links1</span><span class="p">))</span>
    <span class="n">free_legs_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">contract_legs</span><span class="p">,</span> <span class="n">links2</span><span class="p">))</span>

    <span class="c1"># find positions of legs</span>
    <span class="n">pos_cont_legs_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">links1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leg</span><span class="p">)</span> <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">contract_legs</span><span class="p">]</span>
    <span class="n">pos_cont_legs_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">links2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leg</span><span class="p">)</span> <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">contract_legs</span><span class="p">]</span>

    <span class="c1"># contract</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">pos_cont_legs_1</span><span class="p">,</span> <span class="n">pos_cont_legs_2</span><span class="p">))</span>
    <span class="c1"># tensordot keeps order of uncontracted legs intact. first those of T1 then those of T2</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">free_legs_1</span> <span class="o">+</span> <span class="n">free_legs_2</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">links</span>


<span class="k">def</span> <span class="nf">_outer_product</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for _ncon</span>

<span class="sd">    Perform an outer product of multiple tensors and optionally contract all their legs with one single tensor.</span>
<span class="sd">    This can be caused a value OP in the sequence or if there are more than one tensors</span>
<span class="sd">    left but no legs to be contracted</span>

<span class="sd">    Details see :arxiv:`1304.6112`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_list : list of :class:&#39;Array&#39;</span>
<span class="sd">        the whole list of tensors currently processed by _ncon</span>
<span class="sd">    leg_links : list of list of int</span>
<span class="sd">        the whole leg_links currently processed by _ncon</span>
<span class="sd">    sequence :</span>
<span class="sd">     the remaining sequence currently processe by _ncon</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor_list : list of :class:&#39;Array&#39;</span>
<span class="sd">        an updated list of tensors containing the result of the outer product and all untouched tensors</span>
<span class="sd">    leg_links : list of list of int</span>
<span class="sd">        the corresponding updated leg_links</span>
<span class="sd">    sequence : list of int</span>
<span class="sd">        the remaining sequence</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">outer_product</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="c1"># final outer product of all remaining tensors</span>
        <span class="c1"># ensure there are enough entries</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">outer_product</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensor_list</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Not enough OP entries in sequence&#39;</span><span class="p">)</span>

    <span class="c1"># determine number of pending outer products</span>
    <span class="n">num_op</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">sequence</span>
    <span class="p">)</span>  <span class="c1"># default value: if no entry in sequence is find that is not outer_product, all of them are</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="n">outer_product</span><span class="p">:</span>
            <span class="n">num_op</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">break</span>

    <span class="c1"># determine tensors on which OPs are to be performed</span>
    <span class="c1"># for num_op outer products we need num_op+1 tensors that are all contracted with one extra tensor</span>
    <span class="c1"># see :arxiv:`1304.6112`</span>
    <span class="c1"># find the next num_op+2 tensors coming up in sequence</span>
    <span class="c1"># failure to find this many implies an invalid sequence.</span>

    <span class="k">if</span> <span class="n">num_op</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># OP of all remaining tensors</span>
        <span class="n">op_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># flag relevant num_op + 2 tensors</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">num_op</span>  <span class="c1"># sequence[num_op] is the first entry that is not _outer</span>
        <span class="k">while</span> <span class="nb">sum</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_op</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ptr</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;sequence contains outer products but ended before finding enough &#39;</span>
                    <span class="s1">&#39;tensors for the outer product.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="o">==</span> <span class="n">outer_product</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;sequence contains outer products but ncon encountered another OP before &#39;</span>
                    <span class="s1">&#39;identifying all tensors involved in the first.&#39;</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                    <span class="n">flags</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;sequence contains outer products. An index on one of the legs is not appearing twice.&#39;</span>
                <span class="p">)</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># identify which of these tensors is *not* participating in the OP</span>
        <span class="c1"># but is instead contracted with the result of the OP</span>
        <span class="c1"># - identify the two tensors involved in the first contraction</span>
        <span class="c1"># - examine following contractions until one of them is with a third tensor</span>
        <span class="c1">#   (thus only occurs on one of the initial candidates)</span>
        <span class="n">first_tensors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">num_op</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">first_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">first_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">first_tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                    <span class="k">break</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">next_tensors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">next_tensors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">next_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">next_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">next_tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first_tensors</span> <span class="o">==</span> <span class="n">next_tensors</span><span class="p">:</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">next_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">first_tensors</span><span class="p">:</span>
            <span class="n">post_op_tensor</span> <span class="o">=</span> <span class="n">next_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">post_op_tensor</span> <span class="o">=</span> <span class="n">next_tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">flags</span><span class="p">[</span><span class="n">post_op_tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">op_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">flags</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leg_links</span><span class="p">))))</span>

        <span class="c1"># check that all indices of op_list are contracted with post_op_tensor</span>
        <span class="n">op_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">leg_links</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">]</span>
        <span class="n">op_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">op_indices</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op_indices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">op_indices</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">in</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">post_op_tensor</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Outer product failure. OP tensor has contraction with multiple other tensors.&#39;</span><span class="p">)</span>

    <span class="c1"># if either tensor is not an :class:&#39;Array&#39; try converting</span>
    <span class="c1"># this may occur if a closed disconnected diagram is part of the contraction.</span>
    <span class="c1"># ncon will then try to process the resulting number with _tcontract of _outer_product</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">:</span>
            <span class="n">tensor_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray_trivial</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

    <span class="c1"># perform OPs, starting with the smallest tensors</span>
    <span class="n">op_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor_list</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">op_sizes</span><span class="p">)</span>

        <span class="c1"># construct outer product of the two smallest tensors</span>
        <span class="n">tensor_list</span><span class="p">[</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">tensor_list</span><span class="p">[</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span>
                                                   <span class="n">tensor_list</span><span class="p">[</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="n">tensor_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">leg_links</span><span class="p">[</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">+</span> <span class="n">leg_links</span><span class="p">[</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="n">leg_links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># re adjust op_sizes</span>
        <span class="n">op_sizes</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">op_sizes</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">op_sizes</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">op_sizes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">op_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">op_list</span><span class="p">[</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">else</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">op_list</span><span class="p">]</span>
        <span class="n">op_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">tensor_list</span><span class="p">,</span> <span class="n">leg_links</span><span class="p">,</span> <span class="n">sequence</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/tenpy.html">Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 23, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>