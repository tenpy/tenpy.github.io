
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tenpy.linalg.np_conserved &#8212; TeNPy 0.4.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tenpy.linalg.np_conserved</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A module to handle charge conservation in tensor networks.</span>

<span class="sd">A detailed introduction to this module (including notations) can be found in :doc:`/intro_npc`.</span>

<span class="sd">This module `np_conserved` implements a class :class:`Array`</span>
<span class="sd">designed to make use of charge conservation in tensor networks.</span>
<span class="sd">The idea is that the `Array` class is used in a fashion very similar to</span>
<span class="sd">the :class:`numpy.ndarray`, e.g you can call the functions :func:`tensordot` or :func:`svd`</span>
<span class="sd">(of this module) on them.</span>
<span class="sd">The structure of the algorithms (as DMRG) is thus the same as with basic numpy ndarrays.</span>

<span class="sd">Internally, an :class:`Array` saves charge meta data to keep track of blocks which are nonzero.</span>
<span class="sd">All possible operations (e.g. tensordot, svd, ...) on such arrays preserve the total charge</span>
<span class="sd">structure. In addition, these operations make use of the charges to figure out which of the blocks</span>
<span class="sd">it has to use/combine - this is the basis for the speed-up.</span>

<span class="sd">Overview</span>
<span class="sd">^^^^^^^^</span>

<span class="sd">.. rubric:: Classes</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    Array</span>
<span class="sd">    ~tenpy.linalg.charges.ChargeInfo</span>
<span class="sd">    ~tenpy.linalg.charges.LegCharge</span>
<span class="sd">    ~tenpy.linalg.charges.LegPipe</span>

<span class="sd">.. rubric :: Array creation</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    Array.from_ndarray_trivial</span>
<span class="sd">    Array.from_ndarray</span>
<span class="sd">    Array.from_func</span>
<span class="sd">    Array.from_func_square</span>
<span class="sd">    zeros</span>
<span class="sd">    eye_like</span>
<span class="sd">    diag</span>

<span class="sd">.. rubric:: Concatenation</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    concatenate</span>
<span class="sd">    grid_concat</span>
<span class="sd">    grid_outer</span>

<span class="sd">.. rubric:: Detecting charges of flat arrays</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    detect_qtotal</span>
<span class="sd">    detect_legcharge</span>
<span class="sd">    detect_grid_outer_legcharge</span>

<span class="sd">.. rubric:: Contraction of some legs</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    tensordot</span>
<span class="sd">    outer</span>
<span class="sd">    inner</span>
<span class="sd">    trace</span>

<span class="sd">.. rubric:: Linear algebra</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    svd</span>
<span class="sd">    pinv</span>
<span class="sd">    norm</span>
<span class="sd">    qr</span>
<span class="sd">    expm</span>

<span class="sd">.. rubric:: Eigen systems</span>

<span class="sd">.. autosummary::</span>
<span class="sd">    eigh</span>
<span class="sd">    eig</span>
<span class="sd">    eigvalsh</span>
<span class="sd">    eigvals</span>
<span class="sd">    speigs</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">blas</span> <span class="k">as</span> <span class="n">BLAS</span>  <span class="c1"># python interface to BLAS</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>

<span class="c1"># import public API from charges</span>
<span class="kn">from</span> <span class="nn">.charges</span> <span class="k">import</span> <span class="n">ChargeInfo</span><span class="p">,</span> <span class="n">LegCharge</span><span class="p">,</span> <span class="n">LegPipe</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">charges</span>  <span class="c1"># for private functions</span>
<span class="kn">from</span> <span class="nn">.svd_robust</span> <span class="k">import</span> <span class="n">svd</span> <span class="k">as</span> <span class="n">svd_flat</span>

<span class="kn">from</span> <span class="nn">..tools.misc</span> <span class="k">import</span> <span class="n">to_iterable</span><span class="p">,</span> <span class="n">anynan</span><span class="p">,</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">inverse_permutation</span><span class="p">,</span> <span class="n">list_to_dict_list</span>
<span class="kn">from</span> <span class="nn">..tools.math</span> <span class="k">import</span> <span class="n">speigs</span> <span class="k">as</span> <span class="n">_sp_speigs</span>
<span class="kn">from</span> <span class="nn">..tools.math</span> <span class="k">import</span> <span class="n">qr_li</span><span class="p">,</span> <span class="n">rq_li</span>
<span class="kn">from</span> <span class="nn">..tools.string</span> <span class="k">import</span> <span class="n">vert_join</span><span class="p">,</span> <span class="n">is_non_string_iterable</span>
<span class="kn">from</span> <span class="nn">..tools.optimization</span> <span class="k">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">OptimizationFlag</span><span class="p">,</span> <span class="n">use_cython</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;QCUTOFF&#39;</span><span class="p">,</span> <span class="s1">&#39;ChargeInfo&#39;</span><span class="p">,</span> <span class="s1">&#39;LegCharge&#39;</span><span class="p">,</span> <span class="s1">&#39;LegPipe&#39;</span><span class="p">,</span> <span class="s1">&#39;Array&#39;</span><span class="p">,</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;eye_like&#39;</span><span class="p">,</span> <span class="s1">&#39;diag&#39;</span><span class="p">,</span>
    <span class="s1">&#39;concatenate&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_concat&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_outer&#39;</span><span class="p">,</span> <span class="s1">&#39;detect_grid_outer_legcharge&#39;</span><span class="p">,</span> <span class="s1">&#39;detect_qtotal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;detect_legcharge&#39;</span><span class="p">,</span> <span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="s1">&#39;tensordot&#39;</span><span class="p">,</span> <span class="s1">&#39;svd&#39;</span><span class="p">,</span> <span class="s1">&#39;pinv&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;eigh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;eig&#39;</span><span class="p">,</span> <span class="s1">&#39;eigvalsh&#39;</span><span class="p">,</span> <span class="s1">&#39;eigvals&#39;</span><span class="p">,</span> <span class="s1">&#39;speigs&#39;</span><span class="p">,</span> <span class="s1">&#39;qr&#39;</span><span class="p">,</span> <span class="s1">&#39;expm&#39;</span><span class="p">,</span> <span class="s1">&#39;to_iterable_arrays&#39;</span>
<span class="p">]</span>

<span class="c1">#: A cutoff to ignore machine precision rounding errors when determining charges</span>
<span class="n">QCUTOFF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mi">10</span>

<span class="c1"># the type used for charges</span>
<span class="n">QTYPE</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">QTYPE</span>

<span class="c1"># ##################################</span>
<span class="c1"># Array class</span>
<span class="c1"># ##################################</span>


<div class="viewcode-block" id="Array"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array">[docs]</a><span class="k">class</span> <span class="nc">Array</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A multidimensional array (=tensor) for using charge conservation.</span>

<span class="sd">    An `Array` represents a multi-dimensional tensor,</span>
<span class="sd">    together with the charge structure of its legs (for abelian charges).</span>
<span class="sd">    Further information can be found in :doc:`/intro_npc`.</span>

<span class="sd">    The default :meth:`__init__` (i.e. ``Array(...)``) does not insert any data,</span>
<span class="sd">    and thus yields an Array &#39;full&#39; of zeros, equivalent to :func:`zeros()`.</span>
<span class="sd">    Further, new arrays can be created with one of :meth:`from_ndarray_trivial`,</span>
<span class="sd">    :meth:`from_ndarray`, or :meth:`from_func`, and of course by copying/tensordot/svd etc.</span>

<span class="sd">    In-place methods are indicated by a name starting with ``i``.</span>
<span class="sd">    (But `is_completely_blocked` is not inplace...)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    legcharges : list of :class:`~tenpy.linalg.charges.LegCharge`</span>
<span class="sd">        The leg charges for each of the legs. The :class:`ChargeInfo` is read out from it.</span>
<span class="sd">    dtype : type or string</span>
<span class="sd">        The data type of the array entries. Defaults to np.float64.</span>
<span class="sd">    qtotal : 1D array of QTYPE</span>
<span class="sd">        The total charge of the array. Defaults to 0.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    size</span>
<span class="sd">    stored_blocks</span>
<span class="sd">    rank : int</span>
<span class="sd">        The rank or &quot;number of dimensions&quot;, equivalent to ``len(shape)``.</span>
<span class="sd">    shape : tuple(int)</span>
<span class="sd">        The number of indices for each of the legs.</span>
<span class="sd">    dtype : np.dtype</span>
<span class="sd">        The data type of the entries.</span>
<span class="sd">    chinfo : :class:`~tenpy.linalg.charges.ChargeInfo`</span>
<span class="sd">        The nature of the charge.</span>
<span class="sd">    qtotal : 1D array</span>
<span class="sd">        The total charge of the tensor.</span>
<span class="sd">    legs : list of :class:`~tenpy.linalg.charges.LegCharge`</span>
<span class="sd">        The leg charges for each of the legs.</span>
<span class="sd">    labels : dict (string -&gt; int)</span>
<span class="sd">        Labels for the different legs.</span>
<span class="sd">    _data : list of arrays</span>
<span class="sd">        The actual entries of the tensor.</span>
<span class="sd">    _qdata : 2D array (len(_data), rank), dtype np.intp</span>
<span class="sd">        For each of the _data entries the qindices of the different legs.</span>
<span class="sd">    _qdata_sorted : Bool</span>
<span class="sd">        Whether self._qdata is lexsorted. Defaults to `True`,</span>
<span class="sd">        but *must* be set to `False` by algorithms changing _qdata.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legcharges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;see help(self)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">legcharges</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t have 0-rank Tensor&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>

<div class="viewcode-block" id="Array.copy"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a (deep or shallow) copy of self.</span>

<span class="sd">        **Both** deep and shallow copies will share ``chinfo`` and the `LegCharges` in ``legs``.</span>

<span class="sd">        In contrast to a deep copy, the shallow copy will also share the tensor entries,</span>
<span class="sd">        namely the *same* instances of ``_qdata`` and ``_data`` and ``labels``</span>
<span class="sd">        (and other &#39;immutable&#39; properties like the shape or dtype).</span>

<span class="sd">        .. note ::</span>

<span class="sd">            Shallow copies are *not* recommended unless you know the consequences!</span>
<span class="sd">            See the following examples illustrating some of the pitfalls.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Be (very!) careful when making non-deep copies: In the following example,</span>
<span class="sd">        the original `a` is changed if and only if the corresponding block existed in `a` before.</span>
<span class="sd">        &gt;&gt;&gt; b = a.copy(deep=False)  # shallow copy</span>
<span class="sd">        &gt;&gt;&gt; b[1, 2] = 4.</span>

<span class="sd">        Other `inplace` operations might have no effect at all (although we don&#39;t guarantee that):</span>

<span class="sd">        &gt;&gt;&gt; a *= 2  # has no effect on `b`</span>
<span class="sd">        &gt;&gt;&gt; b.iconj()  # nor does this change `a`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span>  <span class="c1"># different list but same instances</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>  <span class="c1"># list copy</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># even deep copies share legs &amp; chinfo (!)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">cp</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow to pickle and copy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow to pickle and copy.&quot;&quot;&quot;</span>
        <span class="c1"># order is important for import of old version!</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># allow to import from the non-compiled version</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># allow to import from the compiled versions of TenPy 0.3.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>  <span class="c1"># property, requires rank to be set already</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;setstate with incompatible type of state&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Array.from_ndarray_trivial"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.from_ndarray_trivial">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ndarray_trivial</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data_flat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;convert a flat numpy ndarray to an Array with trivial charge conservation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_flat : array_like</span>
<span class="sd">            The data to be converted to a Array.</span>
<span class="sd">        dtype : ``np.dtype``</span>
<span class="sd">            The data type of the array entries. Defaults to dtype of `data_flat`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`Array`</span>
<span class="sd">            An Array with data of data_flat.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_flat</span><span class="p">)</span>  <span class="c1"># unspecified dtype</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">data_flat</span> <span class="o">=</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">chinfo</span> <span class="o">=</span> <span class="n">ChargeInfo</span><span class="p">()</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_trivial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chinfo</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_flat</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">res</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.from_ndarray"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.from_ndarray">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ndarray</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data_flat</span><span class="p">,</span> <span class="n">legcharges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;convert a flat (numpy) ndarray to an Array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_flat : array_like</span>
<span class="sd">            The flat ndarray which should be converted to a npc `Array`.</span>
<span class="sd">            The shape has to be compatible with legcharges.</span>
<span class="sd">        legcharges : list of :class:`LegCharge`</span>
<span class="sd">            The leg charges for each of the legs. The :class:`ChargeInfo` is read out from it.</span>
<span class="sd">        dtype : ``np.dtype``</span>
<span class="sd">            The data type of the array entries. Defaults to dtype of `data_flat`.</span>
<span class="sd">        qtotal : None | charges</span>
<span class="sd">            The total charge of the new array.</span>
<span class="sd">        cutoff : float</span>
<span class="sd">            Blocks with ``np.max(np.abs(block)) &gt; cutoff`` are considered as zero.</span>
<span class="sd">            Defaults to :data:`QCUTOFF`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`Array`</span>
<span class="sd">            An Array with data of `data_flat`.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        detect_qtotal : used to detect ``qtotal`` if not given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">QCUTOFF</span>
        <span class="n">data_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_flat</span><span class="p">)</span>  <span class="c1"># unspecified dtype</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">data_flat</span> <span class="o">=</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">legcharges</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>  <span class="c1"># without any data</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes: legcharges </span><span class="si">{0!s}</span><span class="s2"> vs flat </span><span class="si">{1!s}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">data_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">qtotal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="n">qtotal</span> <span class="o">=</span> <span class="n">detect_qtotal</span><span class="p">(</span><span class="n">data_flat</span><span class="p">,</span> <span class="n">legcharges</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">qindices</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">_iter_all_blocks</span><span class="p">():</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_get_block_slices</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_get_block_charge</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span> <span class="o">==</span> <span class="n">qtotal</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_flat</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>  <span class="c1"># copy data</span>
                <span class="n">qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_flat</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;flat array has non-zero entries in blocks incompatible with charge&quot;</span><span class="p">,</span>
                              <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qdata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">qdata</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">res</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.from_func"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.from_func">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_func</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                  <span class="n">func</span><span class="p">,</span>
                  <span class="n">legcharges</span><span class="p">,</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">func_args</span><span class="o">=</span><span class="p">(),</span>
                  <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">shape_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Array from a numpy func.</span>

<span class="sd">        This function creates an array and fills the blocks *compatible* with the charges</span>
<span class="sd">        using `func`, where `func` is a function returning a `array_like` when given a shape,</span>
<span class="sd">        e.g. one of ``np.ones`` or ``np.random.standard_normal``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            A function-like object which is called to generate the data blocks.</span>
<span class="sd">            We expect that `func` returns a flat array of the given `shape` convertible to `dtype`.</span>
<span class="sd">            If no `shape_kw` is given, it is called like ``func(shape, *fargs, **fkwargs)``,</span>
<span class="sd">            otherwise as ``func(*fargs, `shape_kw`=shape, **fkwargs)``.</span>
<span class="sd">            `shape` is a tuple of int.</span>
<span class="sd">        legcharges : list of :class:`LegCharge`</span>
<span class="sd">            The leg charges for each of the legs. The :class:`ChargeInfo` is read out from it.</span>
<span class="sd">        dtype : None | type | string</span>
<span class="sd">            The data type of the output entries. Defaults to np.float64.</span>
<span class="sd">            Defaults to `None`: obtain it from the return value of the function.</span>
<span class="sd">            Note that this argument is not given to func, but rather a type conversion</span>
<span class="sd">            is performed afterwards. You might want to set a `dtype` in `func_kwargs` as well.</span>
<span class="sd">        qtotal : None | charges</span>
<span class="sd">            The total charge of the new array. Defaults to charge 0.</span>
<span class="sd">        func_args : iterable</span>
<span class="sd">            Additional arguments given to `func`.</span>
<span class="sd">        func_kwargs : dict</span>
<span class="sd">            Additional keyword arguments given to `func`.</span>
<span class="sd">        shape_kw : None | str</span>
<span class="sd">            If given, the keyword with which shape is given to `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`Array`</span>
<span class="sd">            An Array with blocks filled using `func`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># create a small test block to derive the dtype</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shape_kw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kws</span> <span class="o">=</span> <span class="n">func_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">kws</span><span class="p">[</span><span class="n">shape_kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">legcharges</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>  <span class="c1"># without any data yet.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># iterate over all qindices compatible with qtotal</span>
        <span class="n">qindices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qi</span> <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">_iter_all_blocks</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">block_charges</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_get_block_charge</span><span class="p">(</span><span class="n">qindices</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># .T: allows to use 2D `qindices`</span>
        <span class="n">compatible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">block_charges</span> <span class="o">==</span> <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qindices</span> <span class="ow">in</span> <span class="n">qindices</span><span class="p">[</span><span class="n">compatible</span><span class="p">]:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_get_block_shape</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shape_kw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kws</span> <span class="o">=</span> <span class="n">func_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">kws</span><span class="p">[</span><span class="n">shape_kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qdata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">qdata</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># _iter_all_blocks is in lexiographic order</span>
        <span class="n">res</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.from_func_square"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.from_func_square">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_func_square</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">leg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">shape_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Array from a (numpy) function.</span>

<span class="sd">        This function creates an array and fills the blocks *compatible* with the charges</span>
<span class="sd">        using `func`, where `func` is a function returning a `array_like` when given a shape,</span>
<span class="sd">        e.g. one of ``np.ones`` or ``np.random.standard_normal`` or the functions defined in</span>
<span class="sd">        :mod:`~tenpy.linalg.random_matrix`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            A function-like object which is called to generate the data blocks.</span>
<span class="sd">            We expect that `func` returns a flat array of the given `shape` convertible to `dtype`.</span>
<span class="sd">            If no `shape_kw` is given, it is called like ``func(shape, *fargs, **fkwargs)``,</span>
<span class="sd">            otherwise as ``func(*fargs, `shape_kw`=shape, **fkwargs)``.</span>
<span class="sd">            `shape` is a tuple of int.</span>
<span class="sd">        leg : :class:`LegCharge`</span>
<span class="sd">            The leg charges for the first leg; the second leg is set to ``leg.conj()``.</span>
<span class="sd">            The :class:`ChargeInfo` is read out from it.</span>
<span class="sd">        dtype : None | type | string</span>
<span class="sd">            The data type of the output entries.</span>
<span class="sd">            Defaults to `None`: obtain it from the return value of the function.</span>
<span class="sd">            Note that this argument is not given to func, but rather a type conversion</span>
<span class="sd">            is performed afterwards. You might want to set a `dtype` in `func_kwargs` as well.</span>
<span class="sd">        func_args : iterable</span>
<span class="sd">            Additional arguments given to `func`.</span>
<span class="sd">        func_kwargs : dict</span>
<span class="sd">            Additional keyword arguments given to `func`.</span>
<span class="sd">        shape_kw : None | str</span>
<span class="sd">            If given, the keyword with which shape is given to `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`Array`</span>
<span class="sd">            An Array with blocks filled using `func`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">blocked</span> <span class="o">=</span> <span class="n">leg</span><span class="o">.</span><span class="n">is_blocked</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocked</span><span class="p">:</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="n">LegPipe</span><span class="p">([</span><span class="n">leg</span><span class="p">])</span>
            <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pipe</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">conj</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">leg</span><span class="p">,</span> <span class="n">leg</span><span class="o">.</span><span class="n">conj</span><span class="p">()]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="n">from_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">legs</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="p">,</span> <span class="n">shape_kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">blocked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">split_legs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.zeros_like"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.zeros_like">[docs]</a>    <span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of self with only zeros as entries, containing no `_data`.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity check. Raises ValueErrors, if something is wrong.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">optimize</span><span class="p">(</span><span class="n">OptimizationFlag</span><span class="o">.</span><span class="n">skip_arg_checks</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;We don&#39;t allow rank-0 tensors without legs&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leg has different ChargeInfo:</span><span class="se">\n</span><span class="si">{0!s}</span><span class="se">\n</span><span class="s2"> vs </span><span class="si">{1!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">lc</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape mismatch with LegCharges</span><span class="se">\n</span><span class="s2"> self.shape=</span><span class="si">{0!s}</span><span class="s2"> != </span><span class="si">{1!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">lc</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong dtype: </span><span class="si">{0!s}</span><span class="s2"> vs</span><span class="se">\n</span><span class="s2"> </span><span class="si">{1!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_qdata shape wrong&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wront dtype of _qdata&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">&gt;=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">block_number</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid qind in _qdata&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;qdata is not C-contiguous&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">perm</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_qdata_sorted == True, but _qdata is not sorted&quot;</span><span class="p">)</span>
        <span class="c1"># check total charge</span>
        <span class="n">block_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">T</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">block_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">block_q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">block_q</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;some row of _qdata is incompatible with total charge&quot;</span><span class="p">)</span></div>
        <span class="c1"># TODO: check labels?</span>

    <span class="c1"># properties ==============================================================</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of dtype-objects stored.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stored_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of (non-zero) blocks stored in :attr:`_data`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Deprecated access of Array.labels as dictionary.&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">,</span>
                      <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dict_lab</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dict_lab</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">dict_lab</span>

    <span class="nd">@labels</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dict_lab</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Deprecated setting of Array.labels with dictionary.&quot;</span><span class="p">,</span>
                      <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">,</span>
                      <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">list_lab</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dict_lab</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">list_lab</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Two labels point to the same index &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">dict_lab</span><span class="p">))</span>
            <span class="n">list_lab</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">list_lab</span>

    <span class="c1"># labels ==================================================================</span>

<div class="viewcode-block" id="Array.get_leg_index"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.get_leg_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_leg_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;translate a leg-index or leg-label to a leg-index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : int | string</span>
<span class="sd">            The leg-index directly or a label (string) set before.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        leg_index : int</span>
<span class="sd">            The index of the label.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        get_leg_indices : calls get_leg_index for a list of labels.</span>
<span class="sd">        iset_leg_labels : set the labels of different legs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># not in List</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Label not found: </span><span class="si">{0!r}</span><span class="s2">, current labels: </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="ow">or</span> <span class="n">label</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis </span><span class="si">{0:d}</span><span class="s2"> out of rank </span><span class="si">{1:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">label</span></div>

<div class="viewcode-block" id="Array.get_leg_indices"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.get_leg_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_leg_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translate a list of leg-indices or leg-labels to leg indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : iterable of string/int</span>
<span class="sd">            The leg-labels (or directly indices) to be translated in leg-indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        leg_indices : list of int</span>
<span class="sd">            The translated labels.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        get_leg_index : used to translate each of the single entries.</span>
<span class="sd">        iset_leg_labels : set the labels of different legs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span></div>

<div class="viewcode-block" id="Array.iset_leg_labels"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iset_leg_labels">[docs]</a>    <span class="k">def</span> <span class="nf">iset_leg_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set labels for the different axes/legs. In place.</span>

<span class="sd">        Introduction to leg labeling can be found in :doc:`/intro_npc`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : iterable (strings | None), len=self.rank</span>
<span class="sd">            One label for each of the legs.</span>
<span class="sd">            An entry can be None for an anonymous leg.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        get_leg: translate the labels to indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need one leg label for each of the legs.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;use `None` for empty labels&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate label entry in &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.get_leg_labels"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.get_leg_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_leg_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of the leg labels, with `None` for anonymous legs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span></div>

<div class="viewcode-block" id="Array.has_label"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.has_label">[docs]</a>    <span class="k">def</span> <span class="nf">has_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether a given label exists.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.get_leg"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.get_leg">[docs]</a>    <span class="k">def</span> <span class="nf">get_leg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.legs[self.get_leg_index(label)]``.</span>

<span class="sd">        Convenient function returning the leg corresponding to a leg label/index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">label</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Array.ireplace_label"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.ireplace_label">[docs]</a>    <span class="k">def</span> <span class="nf">ireplace_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_label</span><span class="p">,</span> <span class="n">new_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace the leg label `old_label` with `new_label`. In place.&quot;&quot;&quot;</span>
        <span class="n">old_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">old_label</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">old_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">new_label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Duplicate label: trying to set </span><span class="si">{0!r}</span><span class="s2"> in </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">old_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.replace_label"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.replace_label">[docs]</a>    <span class="k">def</span> <span class="nf">replace_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_label</span><span class="p">,</span> <span class="n">new_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy with the leg label `old_label` replaced by `new_label`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">ireplace_label</span><span class="p">(</span><span class="n">old_label</span><span class="p">,</span> <span class="n">new_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.ireplace_labels"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.ireplace_labels">[docs]</a>    <span class="k">def</span> <span class="nf">ireplace_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_labels</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace leg label ``old_labels[i]`` with ``new_labels[i]``. In place.&quot;&quot;&quot;</span>
        <span class="n">old_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">old_labels</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old_inds</span><span class="p">:</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">new_label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_inds</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">):</span>
            <span class="n">new_label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Duplicate label: trying to set </span><span class="si">{0!r}</span><span class="s2"> in </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_label</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.replace_labels"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.replace_labels">[docs]</a>    <span class="k">def</span> <span class="nf">replace_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_labels</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a shallow copy with ``old_labels[i]`` replaced by ``new_labels[i]``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">ireplace_labels</span><span class="p">(</span><span class="n">old_labels</span><span class="p">,</span> <span class="n">new_labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.idrop_labels"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.idrop_labels">[docs]</a>    <span class="k">def</span> <span class="nf">idrop_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove leg labels from self. In place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        old_labels : list of str|int</span>
<span class="sd">            The leg labels/indices for which the label should be removed.</span>
<span class="sd">            By default (None), remove all labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">old_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">old_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">old_labels</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old_inds</span><span class="p">:</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># string output ===========================================================</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;npc.Array shape=</span><span class="si">{0!s}</span><span class="s2"> charge=</span><span class="si">{1!s}</span><span class="s2"> labels=</span><span class="si">{2!s}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">vert_join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">],</span> <span class="n">delim</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">()))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<div class="viewcode-block" id="Array.sparse_stats"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.sparse_stats">[docs]</a>    <span class="k">def</span> <span class="nf">sparse_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string detailing the sparse statistics&quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total</span> <span class="ow">is</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Array without entries, one axis is empty.&quot;</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span>
        <span class="n">stored</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nblocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">captsparse</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span> <span class="o">/</span> <span class="n">stored</span>
            <span class="n">bs_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span>
            <span class="n">bs_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span>
            <span class="n">bs_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span> <span class="o">/</span> <span class="n">nblocks</span>
            <span class="n">bs_med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
            <span class="n">bs_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">bs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">captsparse</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="n">bs_min</span> <span class="o">=</span> <span class="n">bs_max</span> <span class="o">=</span> <span class="n">bs_mean</span> <span class="o">=</span> <span class="n">bs_med</span> <span class="o">=</span> <span class="n">bs_var</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{nonzero:d}</span><span class="s2"> of </span><span class="si">{total:d}</span><span class="s2"> entries (=</span><span class="si">{nztotal:g}</span><span class="s2">) nonzero,</span><span class="se">\n</span><span class="s2">&quot;</span> \
            <span class="s2">&quot;stored in </span><span class="si">{nblocks:d}</span><span class="s2"> blocks with </span><span class="si">{stored:d}</span><span class="s2"> entries.</span><span class="se">\n</span><span class="s2">&quot;</span> \
            <span class="s2">&quot;Captured sparsity: </span><span class="si">{captsparse:g}</span><span class="se">\n</span><span class="s2">&quot;</span>  \
            <span class="s2">&quot;Block sizes min:</span><span class="si">{bs_min:d}</span><span class="s2"> mean:</span><span class="si">{bs_mean:.2f}</span><span class="s2"> median:</span><span class="si">{bs_med:.1f}</span><span class="s2"> &quot;</span> \
            <span class="s2">&quot;max:</span><span class="si">{bs_max:d}</span><span class="s2"> var:</span><span class="si">{bs_var:.2f}</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nonzero</span><span class="o">=</span><span class="n">nonzero</span><span class="p">,</span>
                          <span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">,</span>
                          <span class="n">nztotal</span><span class="o">=</span><span class="n">nonzero</span> <span class="o">/</span> <span class="n">total</span><span class="p">,</span>
                          <span class="n">nblocks</span><span class="o">=</span><span class="n">nblocks</span><span class="p">,</span>
                          <span class="n">stored</span><span class="o">=</span><span class="n">stored</span><span class="p">,</span>
                          <span class="n">captsparse</span><span class="o">=</span><span class="n">captsparse</span><span class="p">,</span>
                          <span class="n">bs_min</span><span class="o">=</span><span class="n">bs_min</span><span class="p">,</span>
                          <span class="n">bs_max</span><span class="o">=</span><span class="n">bs_max</span><span class="p">,</span>
                          <span class="n">bs_mean</span><span class="o">=</span><span class="n">bs_mean</span><span class="p">,</span>
                          <span class="n">bs_med</span><span class="o">=</span><span class="n">bs_med</span><span class="p">,</span>
                          <span class="n">bs_var</span><span class="o">=</span><span class="n">bs_var</span><span class="p">)</span></div>

    <span class="c1"># accessing entries =======================================================</span>

<div class="viewcode-block" id="Array.to_ndarray"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.to_ndarray">[docs]</a>    <span class="k">def</span> <span class="nf">to_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert self to a dense numpy ndarray.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># that&#39;s elegant! :)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow to iterate over the non-zero blocks, giving all `_data`.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        block : ndarray</span>
<span class="sd">            the actual entries of a charge block</span>
<span class="sd">        blockslices : tuple of slices</span>
<span class="sd">            for each of the legs a slice giving the range of the block in the original tensor</span>
<span class="sd">        charges : list of charges</span>
<span class="sd">            the charge value(s) for each of the legs (taking `qconj` into account)</span>
<span class="sd">        qdat : ndarray</span>
<span class="sd">            the qindex for each of the legs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">qdat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">):</span>
            <span class="n">blockslices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">qs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">qi</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qdat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">):</span>
                <span class="n">blockslices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">))</span>
                <span class="n">qs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">block</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">blockslices</span><span class="p">),</span> <span class="n">qs</span><span class="p">,</span> <span class="n">qdat</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acces entries with ``self[inds]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inds : tuple</span>
<span class="sd">            A tuple specifying the `index` for each leg.</span>
<span class="sd">            An ``Ellipsis`` (written as ``...``) replaces ``slice(None)`` for missing axes.</span>
<span class="sd">            For a single `index`, we currently support:</span>

<span class="sd">            - A single integer, choosing an index of the axis,</span>
<span class="sd">              reducing the dimension of the resulting array.</span>
<span class="sd">            - A ``slice(None)`` specifying the complete axis.</span>
<span class="sd">            - A ``slice``, which acts like a `mask` in :meth:`iproject`.</span>
<span class="sd">            - A 1D array_like(bool): acts like a `mask` in :meth:`iproject`.</span>
<span class="sd">            - A 1D array_like(int): acts like a `mask` in :meth:`iproject`,</span>
<span class="sd">              and if not orderd, a subsequent permuation with :meth:`permute`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : `dtype`</span>
<span class="sd">            Only returned, if a single integer is given for all legs.</span>
<span class="sd">            It is the entry specified by `inds`, giving ``0.`` for non-saved blocks.</span>
<span class="sd">        or</span>
<span class="sd">        sliced : :class:`Array`</span>
<span class="sd">            A copy with some of the data removed by :meth:`take_slice` and/or :meth:`project`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``self[i]`` is equivalent to ``self[i, ...]``.</span>
<span class="sd">        ``self[i, ..., j]`` is syntactic sugar for ``self[(i, Ellipsis, i2)]``</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If the number of indices is too large, or</span>
<span class="sd">            if an index is out of range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">int_only</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_indexing</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">int_only</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)])</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="c1"># advanced indexing</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_advanced_getitem</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign ``self[inds] = other``.</span>

<span class="sd">        Should work as expected for both basic and advanced indexing as described in</span>
<span class="sd">        :meth:`__getitem__`.</span>
<span class="sd">        `other` can be:</span>
<span class="sd">        - a single value (if all of `inds` are integer)</span>
<span class="sd">        or for slicing/advanced indexing:</span>
<span class="sd">        - a :class:`Array`, with charges as ``self[inds]`` returned by :meth:`__getitem__`.</span>
<span class="sd">        - or a flat numpy array, assuming the charges as with ``self[inds]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">int_only</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pre_indexing</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">int_only</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)])</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">insert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">raise_incomp_q</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">return</span>
        <span class="c1"># advanced indexing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="c1"># if other is a flat array, convert it to an npc Array</span>
            <span class="n">like_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">leg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">like_other</span><span class="o">.</span><span class="n">legs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="n">LegPipe</span><span class="p">):</span>
                    <span class="n">like_other</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">leg</span><span class="o">.</span><span class="n">to_LegCharge</span><span class="p">()</span>
            <span class="n">like_other</span> <span class="o">=</span> <span class="n">like_other</span><span class="o">.</span><span class="n">_advanced_getitem</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">like_other</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">like_other</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advanced_setitem_npc</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Array.take_slice"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.take_slice">[docs]</a>    <span class="k">def</span> <span class="nf">take_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of self fixing `indices` along one or multiple `axes`.</span>

<span class="sd">        For a rank-4 Array ``A.take_slice([i, j], [1,2])`` is equivalent to ``A[:, i, j, :]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : (iterable of) int</span>
<span class="sd">            The (flat) index for each of the legs specified by `axes`.</span>
<span class="sd">        axes : (iterable of) str/int</span>
<span class="sd">            Leg labels or indices to specify the legs for which the indices are given.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sliced_self : :class:`Array`</span>
<span class="sd">            A copy of self, equivalent to taking slices with indices inserted in axes.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        add_leg : opposite action of inserting a new leg.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(axes) != len(indices)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices may only contain ints&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>  <span class="c1"># nothing to do</span>
        <span class="c1"># qindex and index_within_block for each of the axes</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">indices</span><span class="p">)])</span>
        <span class="c1"># which axes to keep</span>
        <span class="n">keep_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">keep_axes</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">keep_axes</span><span class="p">]</span>
        <span class="c1"># calculate new total charge</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">qi</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
        <span class="c1"># which blocks to keep</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">keep_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">keep_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">axes</span><span class="p">]</span> <span class="o">==</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">keep_blocks</span><span class="p">,</span> <span class="n">keep_axes</span><span class="p">)],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="c1"># res._qdata_sorted is not changed</span>
        <span class="c1"># determine the slices to take on _data</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">ri</span>  <span class="c1"># the indices within the blocks</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="c1"># finally take slices on _data</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">keep_blocks</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.add_trivial_leg"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.add_trivial_leg">[docs]</a>    <span class="k">def</span> <span class="nf">add_trivial_leg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trivial leg (with just one entry) to `self`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int</span>
<span class="sd">            The new leg is inserted before index `axis`.</span>
<span class="sd">        label : str | ``None``</span>
<span class="sd">            If not ``None``, use it as label for the new leg.</span>
<span class="sd">        qconj : +1 | -1</span>
<span class="sd">            The direction of the new leg.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extended : :class:`Array`</span>
<span class="sd">            A (possibly) *shallow* copy of self with an additional leg of ind_len 1 and charge 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">leg</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="kc">None</span><span class="p">)],</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">leg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;label already exists&quot;</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">[:]</span>  <span class="c1"># make a copy</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">T</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">:])</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="p">:</span><span class="n">axis</span><span class="p">],</span>
             <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">:]]),</span>
                              <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.add_leg"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.add_leg">[docs]</a>    <span class="k">def</span> <span class="nf">add_leg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a leg to `self`, setting the current array as slice for a given index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        leg : :class:`LegCharge`</span>
<span class="sd">            The charge data of the leg to be added.</span>
<span class="sd">        i : int</span>
<span class="sd">            Index within the leg for which the data of `self` should be set.</span>
<span class="sd">        axis : axis</span>
<span class="sd">            The new leg is inserted before this current axis.</span>
<span class="sd">        label : str | ``None``</span>
<span class="sd">            If not ``None``, use it as label for the new leg.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extended : :class:`Array`</span>
<span class="sd">            A copy of self with the new `leg` at axis `axis` , such that</span>
<span class="sd">            ``extended.take_slice(i, axis)`` returns a copy of `self`.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        take_slice : opposite action reducing the number of legs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">leg</span><span class="p">)</span>
        <span class="n">qi</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">leg</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;label already exists&quot;</span><span class="p">)</span>
        <span class="n">labels</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">leg</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">))</span>
        <span class="n">extended</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>
        <span class="n">extended</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">extended</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># use existing implementation</span>
        <span class="k">return</span> <span class="n">extended</span></div>

<div class="viewcode-block" id="Array.extend"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">extra</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Increase the dimension of a given axis, filling the values with zeros.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int | str</span>
<span class="sd">            The axis (or axis-label) to be extended.</span>
<span class="sd">        extra : :class:`LegCharge` | int</span>
<span class="sd">            By what to extend, i.e. the charges to be appended to the leg of `axis`.</span>
<span class="sd">            An int stands for extending the length of the array by a single new block of that size</span>
<span class="sd">            with zero charges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        extended : :class:`Array`</span>
<span class="sd">            A copy of self with the specified axis increased.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extended</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">extended</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
        <span class="n">extended</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">extended</span></div>

    <span class="c1"># handling of charges =====================================================</span>

<div class="viewcode-block" id="Array.gauge_total_charge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.gauge_total_charge">[docs]</a>    <span class="k">def</span> <span class="nf">gauge_total_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">newqtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_qconj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Changes the total charge by adjusting the charge on a certain leg.</span>

<span class="sd">        The total charge is given by finding a nonzero entry [i1, i2, ...] and calculating::</span>

<span class="sd">            qtotal = self.chinfo.make_valid(</span>
<span class="sd">                np.sum([l.get_charge(l.get_qindex(qi)[0])</span>
<span class="sd">                        for i, l in zip([i1,i2,...], self.legs)], axis=0))</span>

<span class="sd">        Thus, the total charge can be changed by redefining (= shifting) the LegCharge</span>
<span class="sd">        of a single given leg. This is exaclty what this function does.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int or string</span>
<span class="sd">            The new leg (index or label), for which the charge is changed.</span>
<span class="sd">        newqtotal : charge values, defaults to 0</span>
<span class="sd">            The new total charge.</span>
<span class="sd">        new_qconj: {+1, -1, None}</span>
<span class="sd">            Whether the new LegCharge points inward (+1) or outward (-1) afterwards.</span>
<span class="sd">            By default (None) use the previous ``self.legs[leg].qconj``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        copy : :class:`Array`</span>
<span class="sd">            A shallow copy of self with ``copy.qtotal == newqtotal`` and new ``copy.legs[leg]``.</span>
<span class="sd">            The new leg will be a :class`LegCharge`, even if the old leg was a :class:`LegPipe`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">old_qconj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">qconj</span>
        <span class="k">if</span> <span class="n">new_qconj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_qconj</span> <span class="o">=</span> <span class="n">old_qconj</span>
        <span class="k">if</span> <span class="n">new_qconj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid new_qconj&quot;</span><span class="p">)</span>
        <span class="n">chinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="n">newqtotal</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">newqtotal</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># default zero</span>
        <span class="n">chdiff</span> <span class="o">=</span> <span class="n">newqtotal</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span>
        <span class="n">new_charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">charges</span> <span class="o">+</span> <span class="n">old_qconj</span> <span class="o">*</span> <span class="n">chdiff</span>
        <span class="k">if</span> <span class="n">old_qconj</span> <span class="o">!=</span> <span class="n">new_qconj</span><span class="p">:</span>
            <span class="n">new_charges</span> <span class="o">=</span> <span class="o">-</span><span class="n">new_charges</span>
        <span class="n">new_charges</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">new_charges</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qind</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">slices</span><span class="p">,</span> <span class="n">new_charges</span><span class="p">,</span> <span class="n">new_qconj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.add_charge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.add_charge">[docs]</a>    <span class="k">def</span> <span class="nf">add_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_legs</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add charges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_legs : iterable of :class:`LegCharge`</span>
<span class="sd">            One `LegCharge` for each axis of `self`, to be added to the one in :attr:`legs`.</span>
<span class="sd">        chargeinfo : :class:`ChargeInfo`</span>
<span class="sd">            The ChargeInfo for all charges; create new if ``None``.</span>
<span class="sd">        qtotal : None | charges</span>
<span class="sd">            The total charge with respect to `add_legs`.</span>
<span class="sd">            If ``None``, derive it from non-zero entries of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        charges_added : :class:`Array`</span>
<span class="sd">            A copy of `self`, where the LegCharges `add_legs` where added to `self.legs`.</span>
<span class="sd">            Note that the LegCharges are neither bunched or sorted;</span>
<span class="sd">            you might want to use :meth:`sort_legcharge`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">add_legs</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong number of legs in `add_legs`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chinfo2</span> <span class="o">=</span> <span class="n">ChargeInfo</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">add_legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chinfo</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">chinfo</span> <span class="o">==</span> <span class="n">chinfo2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chinfo</span> <span class="o">=</span> <span class="n">ChargeInfo</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">add_legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chinfo</span><span class="p">])</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_add_charge</span><span class="p">([</span><span class="n">leg</span><span class="p">,</span> <span class="n">leg2</span><span class="p">],</span> <span class="n">chinfo</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="n">leg2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">add_legs</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">qtotal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">leg_slices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">leg</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">add_legs</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">ind_len</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">leg_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">qtotal</span> <span class="o">=</span> <span class="n">detect_qtotal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_ndarray</span><span class="p">(),</span> <span class="n">leg_slices</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no non-zero entry: can&#39;t detect qtotal&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qtotal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">QTYPE</span><span class="p">)))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># use __iter__</span>
            <span class="n">res</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>  <span class="c1"># use __setitem__</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.drop_charge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.drop_charge">[docs]</a>    <span class="k">def</span> <span class="nf">drop_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop (one of) the charges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        charge : int | str</span>
<span class="sd">            Number or `name` of the charge (within `chinfo`) which is to be dropped.</span>
<span class="sd">            ``None`` means dropping all charges.</span>
<span class="sd">        chinfo : :class:`ChargeInfo`</span>
<span class="sd">            The :class:`ChargeInfo` with `charge` dropped; create a new one if ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : :class:`Array`</span>
<span class="sd">            A copy of `self`, where the specified `charge` has been removed.</span>
<span class="sd">            Note that the LegCharges are neither bunched or sorted;</span>
<span class="sd">            you might want to use :meth:`sort_legcharge`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chinfo2</span> <span class="o">=</span> <span class="n">ChargeInfo</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">charge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">chinfo</span> <span class="o">==</span> <span class="n">chinfo2</span>
            <span class="n">chinfo2</span> <span class="o">=</span> <span class="n">chinfo</span>
        <span class="k">if</span> <span class="n">charge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">charge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_drop_charge</span><span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">chinfo2</span><span class="p">)</span> <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># use __iter__</span>
            <span class="n">res</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>  <span class="c1"># use __setitem__</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.change_charge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.change_charge">[docs]</a>    <span class="k">def</span> <span class="nf">change_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">new_qmod</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the `qmod` of one charge in `chinfo`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        charge : int | str</span>
<span class="sd">            Number or `name` of the charge (within `chinfo`) which is to be changed.</span>
<span class="sd">            ``None`` means dropping all charges.</span>
<span class="sd">        new_qmod : int</span>
<span class="sd">            The new `qmod` to be set.</span>
<span class="sd">        new_name : str</span>
<span class="sd">            The new name of the charge.</span>
<span class="sd">        chinfo : :class:`ChargeInfo`</span>
<span class="sd">            The :class:`ChargeInfo` with `qmod` of `charge` changed; create a new one if ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        changed : :class:`Array`</span>
<span class="sd">            A copy of `self`, where the `qmod` of the specified `charge` has been changed.</span>
<span class="sd">            Note that the LegCharges are neither bunched or sorted;</span>
<span class="sd">            you might want to use :meth:`sort_legcharge`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chinfo2</span> <span class="o">=</span> <span class="n">ChargeInfo</span><span class="o">.</span><span class="n">change</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">new_qmod</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">chinfo</span> <span class="o">==</span> <span class="n">chinfo2</span>
            <span class="n">chinfo2</span> <span class="o">=</span> <span class="n">chinfo</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">=</span> <span class="n">chinfo2</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_change_charge</span><span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">new_qmod</span><span class="p">,</span> <span class="n">new_name</span><span class="p">,</span> <span class="n">chinfo2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span>
        <span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.is_completely_blocked"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.is_completely_blocked">[docs]</a>    <span class="k">def</span> <span class="nf">is_completely_blocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return bool whether all legs are blocked by charge.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">is_blocked</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">])</span></div>

<div class="viewcode-block" id="Array.sort_legcharge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.sort_legcharge">[docs]</a>    <span class="k">def</span> <span class="nf">sort_legcharge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bunch</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy with one or all legs sorted by charges.</span>

<span class="sd">        Sort/bunch one or multiple of the LegCharges.</span>
<span class="sd">        Legs which are sorted *and* bunched are guaranteed to be blocked by charge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort : True | False | list of {True, False, perm}</span>
<span class="sd">            A single bool holds for all legs, default=True.</span>
<span class="sd">            Else, `sort` should contain one entry for each leg, with a bool for sort/don&#39;t sort,</span>
<span class="sd">            or a 1D array perm for a given permuation to apply to a leg.</span>
<span class="sd">        bunch : True | False | list of {True, False}</span>
<span class="sd">            A single bool holds for all legs, default=True.</span>
<span class="sd">            Whether or not to bunch at each leg, i.e. combine contiguous blocks with equal charges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        perm : tuple of 1D arrays</span>
<span class="sd">            The permutation applied to each of the legs, such that</span>
<span class="sd">            ``cp.to_ndarray() = self.to_ndarray()[np.ix_(*perm)]``.</span>
<span class="sd">        result : Array</span>
<span class="sd">            A shallow copy of self, with legs sorted/bunched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># ``sort in [False, True]`` doesn&#39;t work</span>
            <span class="n">sort</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">if</span> <span class="n">bunch</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">bunch</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">bunch</span> <span class="o">=</span> <span class="p">[</span><span class="n">bunch</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">sort</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bunch</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong len for bunch or sort&quot;</span><span class="p">)</span>

        <span class="c1"># idea: encapsulate legs into pipes wich are sorted/bunched ...</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pipes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sort</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="ow">or</span> <span class="n">bunch</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span>
                <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ax</span><span class="p">])</span>
                <span class="n">leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
                <span class="n">pipe</span> <span class="o">=</span> <span class="n">LegPipe</span><span class="p">([</span><span class="n">leg</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">bunch</span><span class="o">=</span><span class="n">bunch</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="n">leg</span><span class="o">.</span><span class="n">qconj</span><span class="p">)</span>
                <span class="n">pipes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">perms</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">pipes</span><span class="o">=</span><span class="n">pipes</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>  <span class="c1"># reset labels</span>
        <span class="c1"># ... and convert pipes back to leg charges</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sort</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="ow">or</span> <span class="n">bunch</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span>
                <span class="n">pipe</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pipe</span><span class="o">.</span><span class="n">_perm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">perms</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p_qind</span> <span class="o">=</span> <span class="n">inverse_permutation</span><span class="p">(</span><span class="n">pipe</span><span class="o">.</span><span class="n">_perm</span><span class="p">)</span>
                    <span class="n">perms</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">perm_flat_from_perm_qind</span><span class="p">(</span><span class="n">p_qind</span><span class="p">)</span>
                <span class="n">cp</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">to_LegCharge</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">perms</span><span class="p">),</span> <span class="n">cp</span></div>

<div class="viewcode-block" id="Array.isort_qdata"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.isort_qdata">[docs]</a>    <span class="k">def</span> <span class="nf">isort_qdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(Lexiographically) sort ``self._qdata``. In place.</span>

<span class="sd">        Lexsort ``self._qdata`` and ``self._data`` and set ``self._qdata_sorted = True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">perm</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># reshaping ===============================================================</span>

<div class="viewcode-block" id="Array.make_pipe"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.make_pipe">[docs]</a>    <span class="k">def</span> <span class="nf">make_pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a :class:`~tenpy.linalg.charges.LegPipe` for specified axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : iterable of str|int</span>
<span class="sd">            The leg labels for the axes which should be combined. Order matters!</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments given to :class:`~tenpy.linalg.charges.LegPipe`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pipe : :class:`~tenpy.linalg.charges.LegPipe`</span>
<span class="sd">            A pipe of the legs specified by axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">LegPipe</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.combine_legs"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.combine_legs">[docs]</a>    <span class="k">def</span> <span class="nf">combine_legs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pipes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reshape: combine multiple legs into multiple pipes. If necessary, transpose before.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        combine_legs : (iterable of) iterable of {str|int}</span>
<span class="sd">            Bundles of leg indices or labels, which should be combined into a new output pipes.</span>
<span class="sd">            If multiple pipes should be created, use a list fore each new pipe.</span>
<span class="sd">        new_axes : None | (iterable of) int</span>
<span class="sd">            The leg-indices, at which the combined legs should appear in the resulting array.</span>
<span class="sd">            Default: for each pipe the position of its first pipe in the original array,</span>
<span class="sd">            (taking into account that some axes are &#39;removed&#39; by combining).</span>
<span class="sd">            Thus no transposition is perfomed if `combine_legs` contains only contiguous ranges.</span>
<span class="sd">        pipes : None | (iterable of) {:class:`LegPipes` | None}</span>
<span class="sd">            Optional: provide one or multiple of the resulting LegPipes to avoid overhead of</span>
<span class="sd">            computing new leg pipes for the same legs multiple times.</span>
<span class="sd">            The LegPipes are conjugated, if that is necessary for compatibility with the legs.</span>
<span class="sd">        qconj : (iterable of) {+1, -1}</span>
<span class="sd">            Specify whether new created pipes point inward or outward. Defaults to +1.</span>
<span class="sd">            Ignored for given `pipes`, which are not newly calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reshaped : :class:`Array`</span>
<span class="sd">            A copy of self, whith some legs combined into pipes as specified by the arguments.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        split_legs : inverse reshaping splitting LegPipes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Labels are inherited from self.</span>
<span class="sd">        New pipe labels are generated as ``&#39;(&#39; + &#39;.&#39;.join(*leglabels) + &#39;)&#39;``.</span>
<span class="sd">        For these new labels, previously unlabeled legs are replaced by ``&#39;?#&#39;``,</span>
<span class="sd">        where ``#`` is the leg-index in the original tensor `self`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; oldarray.iset_leg_labels([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &gt;&gt;&gt; c1 = oldarray.combine_legs([1, 2], qconj=-1)  # only single output pipe</span>
<span class="sd">        &gt;&gt;&gt; c1.get_leg_labels()</span>
<span class="sd">        [&#39;a&#39;, &#39;(b.c)&#39;, &#39;d&#39;, &#39;e&#39;]</span>

<span class="sd">        Indices of `combine_legs` refer to the original array.</span>
<span class="sd">        If transposing is necessary, it is performed automatically:</span>

<span class="sd">        &gt;&gt;&gt; c2 = oldarray.combine_legs([[0, 3], [4, 1]], qconj=[+1, -1]) # two output pipes</span>
<span class="sd">        &gt;&gt;&gt; c2.get_leg_labels()</span>
<span class="sd">        [&#39;(a.d)&#39;, &#39;c&#39;, &#39;(e.b)&#39;]</span>
<span class="sd">        &gt;&gt;&gt; c3 = oldarray.combine_legs([[&#39;a&#39;, &#39;d&#39;], [&#39;e&#39;, &#39;b&#39;]], new_axes=[2, 1],</span>
<span class="sd">        &gt;&gt;&gt;                            pipes=[c2.legs[0], c2.legs[2]])</span>
<span class="sd">        &gt;&gt;&gt; c3.get_leg_labels()</span>
<span class="sd">        [&#39;b&#39;, &#39;(e.b)&#39;, &#39;(a.d)&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># bring arguments into a standard form</span>
        <span class="n">combine_legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">)</span>  <span class="c1"># convert iterable to list</span>
        <span class="c1"># check: is combine_legs `iterable(iterable(int|str))` or `iterable(int|str)` ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_non_string_iterable</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># the first entry is (int|str) -&gt; only a single new pipe</span>
            <span class="n">combine_legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">combine_legs</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_axes</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">new_axes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pipes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pipes</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">pipes</span><span class="p">)</span>
        <span class="n">pipes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_legs_make_pipes</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">,</span> <span class="n">pipes</span><span class="p">,</span> <span class="n">qconj</span><span class="p">)</span>  <span class="c1"># out-sourced</span>
        <span class="c1"># good for index tricks: convert combine_legs into arrays</span>
        <span class="n">combine_legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">cl</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span> <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">combine_legs</span><span class="p">]</span>
        <span class="n">all_combine_legs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_combine_legs</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_combine_legs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;got a leg multiple times: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">))</span>
        <span class="n">new_axes</span><span class="p">,</span> <span class="n">transp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_legs_new_axes</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="p">)</span>  <span class="c1"># out-sourced</span>
        <span class="c1"># permute arguments sucht that new_axes is sorted ascending</span>
        <span class="n">perm_args</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">new_axes</span><span class="p">)</span>
        <span class="n">combine_legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">combine_legs</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perm_args</span><span class="p">]</span>
        <span class="n">pipes</span> <span class="o">=</span> <span class="p">[</span><span class="n">pipes</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perm_args</span><span class="p">]</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_axes</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">perm_args</span><span class="p">]</span>

        <span class="c1"># labels: replace non-set labels with &#39;?#&#39; (*before* transpose</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[(</span><span class="n">l</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;?&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)]</span>
        <span class="c1"># transpose if necessary</span>
        <span class="k">if</span> <span class="n">transp</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">transp</span><span class="p">)</span>
            <span class="n">inv_transp</span> <span class="o">=</span> <span class="n">inverse_permutation</span><span class="p">(</span><span class="n">transp</span><span class="p">)</span>
            <span class="n">tr_combine_legs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">inv_transp</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">]</span> <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">combine_legs</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">tr_combine_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">new_axes</span><span class="p">,</span> <span class="n">pipes</span><span class="o">=</span><span class="n">pipes</span><span class="p">)</span>
        <span class="c1"># if we come here, combine_legs has the form of `tr_combine_legs`.</span>
        <span class="c1"># HERE we have the standard form of arguments</span>

        <span class="c1"># obtain the new legs</span>
        <span class="c1"># non_combined_legs: axes of self which are not in combine_legs</span>
        <span class="n">non_combined_legs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_combine_legs</span><span class="p">],</span>
                                     <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">non_combined_legs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">na</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_axes</span><span class="p">,</span> <span class="n">pipes</span><span class="p">):</span>  <span class="c1"># not reversed</span>
            <span class="n">legs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">non_new_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">legs</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_axes</span><span class="p">],</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>  <span class="c1"># convert to array for index tricks</span>
        <span class="c1"># get new labels</span>
        <span class="n">pipe_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_combine_leg_labels</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">])</span> <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">combine_legs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">na</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">plab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_axes</span><span class="p">,</span> <span class="n">pipes</span><span class="p">,</span> <span class="n">pipe_labels</span><span class="p">):</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">na</span><span class="p">:</span><span class="n">na</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">nlegs</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">plab</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="n">legs</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="c1"># the **main work** of copying &amp; reshaping the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># handle self.stored_blocks == 1 separately for optimization</span>
            <span class="n">qmap_inds</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span><span class="o">.</span><span class="n">_map_incoming_qind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">cl</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">res_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="n">res_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_new_axes</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_combined_legs</span><span class="p">]</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span>
            <span class="k">for</span> <span class="n">na</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_axes</span><span class="p">,</span> <span class="n">pipes</span><span class="p">,</span> <span class="n">qmap_inds</span><span class="p">):</span>
                <span class="n">q_map_row</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">q_map</span><span class="p">[</span><span class="n">qi</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">res_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_map_row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">slices</span><span class="p">[</span><span class="n">na</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">q_map_row</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">res_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_get_block_shape</span><span class="p">(</span><span class="n">res_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">res_block</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">res_qdata</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">res_block_view</span> <span class="o">=</span> <span class="n">res_block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)]</span>
            <span class="n">res_block_view</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">res_block_view</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># sourced out for optimization</span>
            <span class="n">new_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_axes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="n">_combine_legs_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">,</span> <span class="n">non_combined_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="p">,</span>
                                 <span class="n">non_new_axes</span><span class="p">,</span> <span class="n">pipes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.split_legs"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.split_legs">[docs]</a>    <span class="k">def</span> <span class="nf">split_legs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reshape: opposite of combine_legs: split (some) legs which are LegPipes.</span>

<span class="sd">        Reverts :meth:`combine_legs` (except a possibly performed `transpose`).</span>
<span class="sd">        The splited legs are replacing the LegPipes at their position, see the examples below.</span>
<span class="sd">        Labels are split reverting what was done in :meth:`combine_legs`.</span>
<span class="sd">        &#39;?#&#39; labels are replaced with ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : (iterable of) int|str</span>
<span class="sd">            Leg labels or indices determining the axes to split.</span>
<span class="sd">            The corresponding entries in self.legs must be :class:`LegPipe` instances.</span>
<span class="sd">            Defaults to all legs, which are :class:`LegPipe` instances.</span>
<span class="sd">        cutoff : float</span>
<span class="sd">            Splitted data blocks with ``np.max(np.abs(block)) &gt; cutoff`` are considered as zero.</span>
<span class="sd">            Defaults to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reshaped : :class:`Array`</span>
<span class="sd">            A copy of self where the specified legs are splitted.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        combine_legs : this is reversed by split_legs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Given a rank-5 Array `old_array`, you can combine it and split it again:</span>

<span class="sd">        &gt;&gt;&gt; old_array.iset_leg_labels([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &gt;&gt;&gt; comb_array = old_array.combine_legs([[0, 3], [2, 4]] )</span>
<span class="sd">        &gt;&gt;&gt; comb_array.get_leg_labels()</span>
<span class="sd">        [&#39;(a.d)&#39;, &#39;b&#39;, &#39;(c.e)&#39;]</span>
<span class="sd">        &gt;&gt;&gt; split_array = comb_array.split_legs([0, 2])</span>
<span class="sd">        &gt;&gt;&gt; split_array.get_leg_labels()</span>
<span class="sd">        [&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">LegPipe</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t split a leg multiple times!&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">LegPipe</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t split leg </span><span class="si">{ax:d}</span><span class="s2"> which is not a LegPipe&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">:</span><span class="n">ax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">q_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]):</span>
            <span class="c1"># optimize: just a single block in each pipe</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">qdata</span> <span class="o">=</span> <span class="p">[[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                <span class="n">pipe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
                <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">:</span><span class="n">ax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">legs</span>
                <span class="n">qdata</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">q_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">qdata</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">))</span>
            <span class="n">new_block_shape</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_get_block_shape</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_block_shape</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_split_legs_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_leg_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">nlegs</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.as_completely_blocked"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.as_completely_blocked">[docs]</a>    <span class="k">def</span> <span class="nf">as_completely_blocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives a version of self which is completely blocked by charges.</span>

<span class="sd">        Functions like :func:`svd` or :func:`eigh` require a complete blocking by charges.</span>
<span class="sd">        This can be achieved by encapsulating each leg which is not completely blocked into a</span>
<span class="sd">        :class:`LegPipe` (containing only that single leg). The LegPipe will then contain all</span>
<span class="sd">        necessary information to revert the blocking.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        encapsulated_axes : list of int</span>
<span class="sd">            The leg indices which have been encapsulated into Pipes.</span>
<span class="sd">        blocked_self : :class:`Array`</span>
<span class="sd">            Self (if ``len(encapsulated_axes) = 0``) or a copy of self,</span>
<span class="sd">            which is completely blocked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">enc_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span><span class="o">.</span><span class="n">is_blocked</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">enc_axes</span><span class="p">,</span> <span class="bp">self</span>
        <span class="n">qconj</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">qconj</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">enc_axes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">enc_axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">enc_axes</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.squeeze"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.squeeze">[docs]</a>    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like ``np.squeeze``.</span>

<span class="sd">        If a squeezed leg has non-zero charge, this charge is added to :attr:`qtotal`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : None | (iterable of) {int|str}</span>
<span class="sd">            Labels or indices of the legs which should be &#39;squeezed&#39;, i.e. the legs removed.</span>
<span class="sd">            The corresponding legs must be trivial, i.e., have `ind_len` 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        squeezed : :class:Array | scalar</span>
<span class="sd">            A scalar of ``self.dtype``, if all axes were squeezed.</span>
<span class="sd">            Else a copy of ``self`` with reduced ``rank`` as specified by `axes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tried to squeeze non-unit leg&quot;</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># adjust qtotal</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># modified!</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">])</span>

        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">keep</span><span class="p">)],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="c1"># res._qdata_sorted doesn&#39;t change</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="c1"># data manipulation =======================================================</span>

<div class="viewcode-block" id="Array.astype"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy with new dtype, upcasting all blocks in ``_data``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : convertible to a np.dtype</span>
<span class="sd">            The new data type.</span>
<span class="sd">            If None, deduce the new dtype as common type of ``self._data``.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Whether to make a copy of the blocks even if the type didn&#39;t change.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        copy : :class:`Array`</span>
<span class="sd">            Deep copy of self with new dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># manual deep copy: don&#39;t copy every block twice</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="p">[])</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cp</span></div>

<div class="viewcode-block" id="Array.ipurge_zeros"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.ipurge_zeros">[docs]</a>    <span class="k">def</span> <span class="nf">ipurge_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">QCUTOFF</span><span class="p">,</span> <span class="n">norm_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes ``self._data`` blocks with *norm* less than cutoff. In place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cutoff : float</span>
<span class="sd">            Blocks with norm &lt;= `cutoff` are removed. defaults to :data:`QCUTOFF`.</span>
<span class="sd">        norm_order :</span>
<span class="sd">            A valid `ord` argument for `np.linalg.norm`.</span>
<span class="sd">            Default ``None`` gives the Frobenius norm/2-norm for matrices/everything else.</span>
<span class="sd">            Note that this differs from other methods, e.g. :meth:`from_ndarray`,</span>
<span class="sd">            which use the maximum norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="n">norm_order</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">)</span>  <span class="c1"># bool array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="c1"># self._qdata_sorted is preserved</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.iproject"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iproject">[docs]</a>    <span class="k">def</span> <span class="nf">iproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applying masks to one or multiple axes. In place.</span>

<span class="sd">        This function is similar as `np.compress` with boolean arrays</span>
<span class="sd">        For each specified axis, a boolean 1D array `mask` can be given,</span>
<span class="sd">        which chooses the indices to keep.</span>

<span class="sd">        .. warning ::</span>
<span class="sd">            Although it is possible to use an 1D int array as a mask, the order is ignored!</span>
<span class="sd">            If you need to permute an axis, use :meth:`permute` or :meth:`sort_legcharge`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : (list of) 1D array(bool|int)</span>
<span class="sd">            For each axis specified by `axes` a mask, which indices of the axes should be kept.</span>
<span class="sd">            If `mask` is a bool array, keep the indices where `mask` is True.</span>
<span class="sd">            If `mask` is an int array, keep the indices listed in the mask, *ignoring* the</span>
<span class="sd">            order or multiplicity.</span>
<span class="sd">        axes : (list of) int | string</span>
<span class="sd">            The `i`th entry in this list specifies the axis for the `i`th entry of `mask`,</span>
<span class="sd">            either as an int, or with a leg label.</span>
<span class="sd">            If axes is just a single int/string, specify just a single mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map_qind : list of 1D arrays</span>
<span class="sd">            The mapping of qindices for each of the specified axes.</span>
<span class="sd">        block_masks: list of lists of 1D bool arrays</span>
<span class="sd">            ``block_masks[a][qind]`` is a boolen mask which indices to keep</span>
<span class="sd">            in block ``qindex`` of ``axes[a]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(axes) != len(mask)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># nothing to do.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="c1"># convert integer masks to bool masks</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Array views may share ``_qdata`` views, so make a copy of _qdata before manipulating</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">block_masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">proj_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">)</span>
        <span class="n">map_qind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="n">m_qind</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">map_qind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_qind</span><span class="p">)</span>
            <span class="n">block_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bm</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_qind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]]</span>
            <span class="n">piv</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">piv</span><span class="p">]</span>  <span class="c1"># keeps dimension</span>
            <span class="c1"># self._qdata_sorted is preserved</span>
            <span class="n">proj_data</span> <span class="o">=</span> <span class="n">proj_data</span><span class="p">[</span><span class="n">piv</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="c1"># finally project out the blocks</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iold</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">proj_data</span><span class="p">):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">iold</span><span class="p">]</span>
            <span class="n">subidx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">block_masks</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
                <span class="n">subidx</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">]]</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">]],</span> <span class="n">block</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">map_qind</span><span class="p">,</span> <span class="n">block_masks</span></div>

<div class="viewcode-block" id="Array.permute"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.permute">[docs]</a>    <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a permutation in the indices of an axis.</span>

<span class="sd">        Similar as np.take with a 1D array.</span>
<span class="sd">        Roughly equivalent to ``res[:, ...] = self[perm, ...]`` for the corresponding `axis`.</span>
<span class="sd">        Note: This function is quite slow, and usually not needed!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        perm : array_like 1D int</span>
<span class="sd">            The permutation which should be applied to the leg given by `axis`.</span>
<span class="sd">        axis : str | int</span>
<span class="sd">            A leg label or index specifying on which leg to take the permutation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : :class:`Array`</span>
<span class="sd">            A copy of self with leg `axis` permuted, such that</span>
<span class="sd">            ``res[i, ...] = self[perm[i], ...]`` for ``i`` along `axis`.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        sort_legcharge : can also be used to perform a general permutation.</span>
<span class="sd">            Preferable, since it is faster for permutations which don&#39;t mix charge blocks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">oldleg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">oldleg</span><span class="o">.</span><span class="n">ind_len</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;permutation has wrong length&quot;</span><span class="p">)</span>
        <span class="n">inv_perm</span> <span class="o">=</span> <span class="n">inverse_permutation</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">newleg</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">oldleg</span><span class="o">.</span><span class="n">to_qflat</span><span class="p">()[</span><span class="n">perm</span><span class="p">],</span> <span class="n">oldleg</span><span class="o">.</span><span class="n">qconj</span><span class="p">)</span>
        <span class="n">newleg</span> <span class="o">=</span> <span class="n">newleg</span><span class="o">.</span><span class="n">bunch</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># data is replaced afterwards</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">newleg</span>
        <span class="n">qdata_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span>
        <span class="n">new_block_idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">old_block_idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qdata</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dict for fast look up: tuple(indices) -&gt; _data index</span>
        <span class="k">for</span> <span class="n">old_qind</span><span class="p">,</span> <span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">oldleg</span><span class="o">.</span><span class="n">_slice_start_stop</span><span class="p">()):</span>
            <span class="n">old_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">old_data_index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">qdata_axis</span> <span class="o">==</span> <span class="n">old_qind</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">old_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">old_data_index</span><span class="p">]</span>
                <span class="n">old_qindices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">old_data_index</span><span class="p">]</span>
                <span class="n">new_qindices</span> <span class="o">=</span> <span class="n">old_qindices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i_old</span> <span class="ow">in</span> <span class="n">old_range</span><span class="p">:</span>
                    <span class="n">i_new</span> <span class="o">=</span> <span class="n">inv_perm</span><span class="p">[</span><span class="n">i_old</span><span class="p">]</span>
                    <span class="n">qi_new</span><span class="p">,</span> <span class="n">within_new</span> <span class="o">=</span> <span class="n">newleg</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i_new</span><span class="p">)</span>
                    <span class="n">new_qindices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">qi_new</span>
                    <span class="c1"># look up new_qindices in `qdata`, insert them if necessary</span>
                    <span class="n">new_data_ind</span> <span class="o">=</span> <span class="n">qdata</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_qindices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">new_data_ind</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                        <span class="c1"># insert new block</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">_get_block_shape</span><span class="p">(</span><span class="n">new_qindices</span><span class="p">)))</span>
                    <span class="n">new_block</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">new_data_ind</span><span class="p">]</span>
                    <span class="c1"># copy data</span>
                    <span class="n">new_block_idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">within_new</span>
                    <span class="n">old_block_idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_old</span> <span class="o">-</span> <span class="n">beg</span>
                    <span class="n">new_block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_block_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">old_block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">old_block_idx</span><span class="p">)]</span>
        <span class="c1"># data blocks copied</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">res_qdata</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">res_qdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qindices</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.itranspose"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.itranspose">[docs]</a>    <span class="nd">@use_cython</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="s1">&#39;Array_itranspose&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">itranspose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transpose axes like `np.transpose`. In place.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes: iterable (int|string), len ``rank`` | None</span>
<span class="sd">            The new order of the axes. By default (None), reverse axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axes has wrong length: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">axes</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># nothing to do</span>
        <span class="n">axes_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="n">labs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">labs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">axes_arr</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.transpose"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`itranspose`, but on a deep copy.&quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cp</span></div>

<div class="viewcode-block" id="Array.iswapaxes"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iswapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">iswapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Similar as ``np.swapaxes``. In place.&quot;&quot;&quot;</span>
        <span class="n">axis1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
        <span class="n">axis2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis1</span> <span class="o">==</span> <span class="n">axis2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># nothing to do</span>
        <span class="n">swap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">swap</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">axis1</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span>
        <span class="n">legs</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">legs</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">legs</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">legs</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">swap</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.iscale_axis"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iscale_axis">[docs]</a>    <span class="k">def</span> <span class="nf">iscale_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale with varying values along an axis. In place.</span>

<span class="sd">        Rescale to ``new_self[i1, ..., i_axis, ...] = s[i_axis] * self[i1, ..., i_axis, ...]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : 1D array, len=self.shape[axis]</span>
<span class="sd">            The vector with which the axis should be scaled.</span>
<span class="sd">        axis : str|int</span>
<span class="sd">            The leg label or index for the axis which should be scaled.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        iproject : can be used to discard indices for which s is zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s has wrong shape: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; instead of &quot;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
        <span class="n">leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">leg</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)],</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">qi</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># optimize: no need to swap axes, if axis is -1.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">t</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">leg</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)]</span>  <span class="c1"># (it&#39;s slightly faster for large arrays)</span>
                <span class="k">for</span> <span class="n">qi</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.scale_axis"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.scale_axis">[docs]</a>    <span class="k">def</span> <span class="nf">scale_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as :meth:`iscale_axis`, but return a (deep) copy.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="c1"># block-wise operations == element wise with numpy ufunc</span>

<div class="viewcode-block" id="Array.iunary_blockwise"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iunary_blockwise">[docs]</a>    <span class="k">def</span> <span class="nf">iunary_blockwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Roughly ``self = f(self)``, block-wise. In place.</span>

<span class="sd">        Applies an unary function `func` to the non-zero blocks in ``self._data``.</span>

<span class="sd">        .. note ::</span>
<span class="sd">            Assumes implicitly that ``func(np.zeros(...), *args, **kwargs)`` gives 0,</span>
<span class="sd">            since we don&#39;t let `func` act on zero blocks!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            A function acting on flat arrays, returning flat arrays.</span>
<span class="sd">            It is called like ``new_block = func(block, *args, **kwargs)``.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional arguments given to function *after* the block.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments given to the function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a.iunaray_blockwise(np.real)  # get real part</span>
<span class="sd">        &gt;&gt;&gt; a.iunaray_blockwise(np.conj)  # same data as a.iconj(), but doesn&#39;t charge conjugate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.unary_blockwise"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.unary_blockwise">[docs]</a>    <span class="k">def</span> <span class="nf">unary_blockwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Roughly ``return func(self)``, block-wise. Copies.</span>

<span class="sd">        Same as :meth:`iunary_blockwise`, but makes a **shallow** copy first.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">iunary_blockwise</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.iconj"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iconj">[docs]</a>    <span class="k">def</span> <span class="nf">iconj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">complex_conj</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wraper around :meth:`self.conj` with ``inplace=True``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">complex_conj</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.conj"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">complex_conj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjugate: complex conjugate data, conjugate charge data.</span>

<span class="sd">        Conjugate all legs, set negative qtotal.</span>

<span class="sd">        Labeling: takes &#39;a&#39; -&gt; &#39;a*&#39;, &#39;a*&#39;-&gt; &#39;a&#39; and</span>
<span class="sd">        &#39;(a,(b*,c))&#39; -&gt; &#39;(a*, (b, c*))&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        complex_conj : bool</span>
<span class="sd">            Whether the data should be complex conjugated.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            Whether to apply changes to `self`, or to return a *deep* copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">complex_conj</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iunary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="o">-</span><span class="n">res</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conj_leg_label</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Array.complex_conj"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.complex_conj">[docs]</a>    <span class="k">def</span> <span class="nf">complex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy which is complex conjugated *without* conjugating the charge data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.norm"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert_to_float</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Norm of flattened data.</span>

<span class="sd">        See :func:`norm` for details.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">convert_to_float</span><span class="p">:</span>
            <span class="n">new_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>  <span class="c1"># int -&gt; float</span>
            <span class="k">if</span> <span class="n">new_type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_type</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">block_norms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="nb">ord</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="c1"># ``.reshape(-1) gives a 1D view and is thus faster than ``.flatten()``</span>
        <span class="c1"># add a [0] in the list to ensure correct results for ``ord=-inf``</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">block_norms</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">ord</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return ``-self``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">)</span>

<div class="viewcode-block" id="Array.ibinary_blockwise"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.ibinary_blockwise">[docs]</a>    <span class="k">def</span> <span class="nf">ibinary_blockwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Roughly ``self = func(self, other)``, block-wise. In place.</span>

<span class="sd">        Applies a binary function &#39;block-wise&#39; to the non-zero blocks of</span>
<span class="sd">        ``self._data`` and ``other._data``, storing result in place.</span>
<span class="sd">        Assumes that `other` is an :class:`Array` as well, with the same shape</span>
<span class="sd">        and compatible legs.</span>

<span class="sd">        .. note ::</span>
<span class="sd">            Assumes implicitly that</span>
<span class="sd">            ``func(np.zeros(...), np.zeros(...), *args, **kwargs)`` gives 0,</span>
<span class="sd">            since we don&#39;t let `func` act on zero blocks!</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a.ibinary_blockwise(np.add, b)  # equivalent to ``a += b``, if ``b`` is an `Array`.</span>
<span class="sd">        &gt;&gt;&gt; a.ibinary_blockwise(np.max, b)  # overwrites ``a`` to ``a = max(a, b)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize</span><span class="p">(</span><span class="n">OptimizationFlag</span><span class="o">.</span><span class="n">skip_arg_checks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;different rank!&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">self_leg</span><span class="p">,</span> <span class="n">other_leg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">legs</span><span class="p">):</span>
                <span class="n">self_leg</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">other_leg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">qtotal</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arrays can&#39;t have different `qtotal`!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isort_qdata</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">isort_qdata</span><span class="p">()</span>

        <span class="n">adata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">bdata</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">aq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span>
        <span class="n">bq</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_qdata</span>
        <span class="n">Na</span><span class="p">,</span> <span class="n">Nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aq</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bq</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Na</span> <span class="o">==</span> <span class="n">Nb</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">aq</span> <span class="o">==</span> <span class="n">bq</span><span class="p">):</span>
            <span class="c1"># If the qdata structure is identical, we can immediately run through the data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">bt</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span><span class="p">,</span> <span class="n">bt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise we have to step through comparing left and right qdata</span>
            <span class="c1"># F-style strides to preserve sorting!</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_make_stride</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">block_number</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">aq_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aq</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">bq_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bq</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">qdata</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Na</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Nb</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Na</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Nb</span> <span class="ow">and</span> <span class="n">aq_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bq_</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># a and b are non-zero</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bdata</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                    <span class="n">qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">Na</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Nb</span> <span class="ow">and</span> <span class="n">aq_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">bq_</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># a is 0</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bdata</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">bdata</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                    <span class="n">qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bq</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">Nb</span> <span class="ow">or</span> <span class="n">aq_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bq_</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>  <span class="c1"># b is 0</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">adata</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">adata</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
                    <span class="n">qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># tested a == b or a &lt; b or a &gt; b, so this should never happen</span>
                    <span class="k">assert</span> <span class="kc">False</span>
                <span class="c1"># if both are zero, we assume f(0, 0) = 0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qdata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="c1"># ``self._qdata_sorted = True`` was set by self.isort_qdata</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.binary_blockwise"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.binary_blockwise">[docs]</a>    <span class="k">def</span> <span class="nf">binary_blockwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Roughly ``return func(self, other)``, block-wise. Copies.</span>

<span class="sd">        Same as :meth:`ibinary_blockwise`, but makes a **shallow** copy first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.matvec"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.matvec">[docs]</a>    <span class="k">def</span> <span class="nf">matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is used by the Lanczos algorithm needed for DMRG.</span>

<span class="sd">        It is supposed to calculate the matrix - vector - product</span>
<span class="sd">        for a rank-2 matrix ``self`` and a rank-1 vector `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Array.iadd_prefactor_other"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iadd_prefactor_other">[docs]</a>    <span class="nd">@use_cython</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;Array_iadd_prefactor_other&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iadd_prefactor_other</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefactor</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``self += prefactor * other`` for scalar `prefactor` and :class:`Array` `other`.</span>

<span class="sd">        Note that we allow the type of `self` to change if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">prefactor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong argument types: </span><span class="si">{0!r}</span><span class="s2">, </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">prefactor</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">prefactor</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Array.iscale_prefactor"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array.iscale_prefactor">[docs]</a>    <span class="nd">@use_cython</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;Array_iscale_prefactor&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">iscale_prefactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefactor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``self *= prefactor`` for scalar `prefactor`.</span>

<span class="sd">        Note that we allow the type of `self` to change if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">prefactor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;prefactor is not scalar: </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">prefactor</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iunary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span> <span class="n">prefactor</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self + other``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">iadd_prefactor_other</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># unknown type of other</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``self += other``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iadd_prefactor_other</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># unknown type of other</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self - other``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">iadd_prefactor_other</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>  <span class="c1"># unknown type of other</span>

    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``self -= other``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iadd_prefactor_other</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self * other`` for scalar ``other``.</span>

<span class="sd">        Use explicit functions for matrix multiplication etc.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">iscale_prefactor</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``other * self`` for scalar ``other``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">iscale_prefactor</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``self *= other`` for scalar `other`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscale_prefactor</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self / other`` for scalar `other`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;a/b for b=0. Types: </span><span class="si">{0!s}</span><span class="s2">, </span><span class="si">{1!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">iscale_prefactor</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``self /= other`` for scalar `other`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;a/b for b=0. Types: </span><span class="si">{0!s}</span><span class="s2">, </span><span class="si">{1!s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iscale_prefactor</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="c1"># private functions =======================================================</span>

    <span class="k">def</span> <span class="nf">_set_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deduce self.shape from self.legs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;We don&#39;t allow 0-dimensional arrays. Why should we?&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">lc</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">lc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_all_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator to iterate over all combinations of qindices in lexiographic order.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        qindices : tuple of int</span>
<span class="sd">            A qindex for each of the legs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">block_inds</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">block_number</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)]):</span>
            <span class="c1"># loop over all charge sectors in lex order (last leg most siginificant)</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">block_inds</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># back to legs in correct order</span>

    <span class="k">def</span> <span class="nf">_get_block_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qindices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the charge of a block selected by `qindices`.</span>

<span class="sd">        The charge of a single block is defined as ::</span>

<span class="sd">            qtotal = sum_{legs l} legs[l].get_charges(qindices[l])) modulo qmod</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">qindices</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_block_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qindices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns tuple of slices for a block selected by `qindices`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">qindices</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_get_block_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qindices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return shape for the block given by qindices.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">l</span><span class="o">.</span><span class="n">slices</span><span class="p">[</span><span class="n">qi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="o">.</span><span class="n">slices</span><span class="p">[</span><span class="n">qi</span><span class="p">])</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">qindices</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">insert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">raise_incomp_q</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the ndarray in ``_data`` representing the block corresponding to `qindices`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qindices : 1D array of np.intp</span>
<span class="sd">            The qindices, for which we need to look in _qdata.</span>
<span class="sd">        insert : bool</span>
<span class="sd">            If True, insert a new (zero) block, if `qindices` is not existent in ``self._data``.</span>
<span class="sd">            Else: just return ``None`` in that case.</span>
<span class="sd">        raise_incomp_q : bool</span>
<span class="sd">            Raise an IndexError if the charge is incompatible.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        block: ndarray</span>
<span class="sd">            The block in ``_data`` corresponding to qindices.</span>
<span class="sd">            If `insert`=False and there is not block with qindices, return ``False``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If qindices are incompatible with charge and `raise_incomp_q`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_charge</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">raise_incomp_q</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;trying to get block for qindices incompatible with charges&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># find qindices in self._qdata</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">==</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">insert</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_shape</span><span class="p">(</span><span class="n">qindices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="p">[</span><span class="n">qindices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_bunch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bunch_legs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy and bunch the qind for one or multiple legs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bunch : list of {True, False}</span>
<span class="sd">            One entry for each leg, whether the leg should be bunched.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        sort_legcharge: public API calling this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># lists for each leg:</span>
        <span class="n">map_qindex</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">rank</span>  <span class="c1"># array mapping old qindex to new qindex, such that</span>
        <span class="c1"># ``new_leg.charges[m_qindex[i]] == old_leg.charges[i]``</span>
        <span class="n">bunch_qindex</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">rank</span>  <span class="c1"># bool array whether the *new* qindex was bunched</span>
        <span class="k">for</span> <span class="n">li</span><span class="p">,</span> <span class="n">bunch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bunch_legs</span><span class="p">):</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">new_leg</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">li</span><span class="p">]</span><span class="o">.</span><span class="n">bunch</span><span class="p">()</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">li</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_leg</span>
            <span class="c1"># generate entries in map_qindex and bunch_qdindex</span>
            <span class="n">bunch_qindex</span><span class="p">[</span><span class="n">li</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">m_qindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="n">m_qindex</span><span class="p">[</span><span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">map_qindex</span><span class="p">[</span><span class="n">li</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">m_qindex</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># now map _data and _qdata</span>
        <span class="n">bunched_blocks</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># new qindices -&gt; index in new _data</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_qdata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">old_block</span><span class="p">,</span> <span class="n">old_qindices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">):</span>
            <span class="n">new_qindices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">map_qindex</span><span class="p">,</span> <span class="n">old_qindices</span><span class="p">)])</span>
            <span class="n">bunch</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bunch_qindex</span><span class="p">,</span> <span class="n">new_qindices</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">bunch</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_qindices</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bunched_blocks</span><span class="p">:</span>
                    <span class="c1"># create enlarged block</span>
                    <span class="n">bunched_blocks</span><span class="p">[</span><span class="n">new_qindices</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
                    <span class="c1"># cp has new legs and thus gives the new shape</span>
                    <span class="n">new_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">_get_block_shape</span><span class="p">(</span><span class="n">new_qindices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_block</span><span class="p">)</span>
                    <span class="n">new_qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_qindices</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_block</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[</span><span class="n">bunched_blocks</span><span class="p">[</span><span class="n">new_qindices</span><span class="p">]]</span>
                <span class="c1"># figure out where to insert the in the new bunched_blocks</span>
                <span class="n">old_slbeg</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">slices</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">old_qindices</span><span class="p">)]</span>
                <span class="n">new_slbeg</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">slices</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">new_qindices</span><span class="p">)]</span>
                <span class="n">slbeg</span> <span class="o">=</span> <span class="p">[(</span><span class="n">o</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_slbeg</span><span class="p">,</span> <span class="n">new_slbeg</span><span class="p">)]</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">beg</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">beg</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">slbeg</span><span class="p">,</span> <span class="n">old_block</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
                <span class="c1"># insert the old block into larger new block</span>
                <span class="n">new_block</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span> <span class="o">=</span> <span class="n">old_block</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># just copy the old block</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_block</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">new_qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_qindices</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_qdata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">))</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_qsorted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">cp</span>

    <span class="k">def</span> <span class="nf">_perm_qind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_qind</span><span class="p">,</span> <span class="n">leg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a permutation `p_qind` of the qindices in leg `leg` to _qdata. In place.&quot;&quot;&quot;</span>
        <span class="c1"># entry ``b`` of of old old._qdata[:, leg] refers to old ``old.legs[leg][b]``.</span>
        <span class="c1"># since new ``new.legs[leg][i] == old.legs[leg][p_qind[i]]``,</span>
        <span class="c1"># we have new ``new.legs[leg][reverse_sort_perm(p_qind)[b]] == old.legs[leg][b]``</span>
        <span class="c1"># thus we replace an entry `b` in ``_qdata[:, leg]``with reverse_sort_perm(q_ind)[b].</span>
        <span class="n">p_qind_r</span> <span class="o">=</span> <span class="n">inverse_permutation</span><span class="p">(</span><span class="n">p_qind</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">leg</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_qind_r</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">leg</span><span class="p">]]</span>  <span class="c1"># equivalent to</span>
        <span class="c1"># self._qdata[:, leg] = [p_qind_r[i] for i in self._qdata[:, leg]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_pre_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if `inds` are valid indices for ``self[inds]`` and replaces Ellipsis by slices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        only_integer : bool</span>
<span class="sd">            Whether all of `inds` are (convertible to) np.intp.</span>
<span class="sd">        inds : tuple, len=self.rank</span>
<span class="sd">            `inds`, where ``Ellipsis`` is replaced by the correct number of slice(None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">:</span>  <span class="c1"># for rank 1</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># i is index of Ellipsis or None if we don&#39;t have one</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>  <span class="c1"># need an Ellipsis</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># replace Ellipsis with slice(None)</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">fill</span> <span class="o">+</span> <span class="n">inds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;too many indices for Array&quot;</span><span class="p">)</span>
        <span class="c1"># do we have only integer entries in `inds`?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">only_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">only_int</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">),</span> <span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">inds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">inds</span>

    <span class="k">def</span> <span class="nf">_advanced_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">calc_map_qind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate self[inds] for non-integer `inds`.</span>

<span class="sd">        This function is called by self.__getitem__(inds).</span>
<span class="sd">        and from _advanced_setitem_npc with ``calc_map_qind=True``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inds : tuple</span>
<span class="sd">            Indices for the different axes, as returned by :meth:`_pre_indexing`.</span>
<span class="sd">        calc_map_qind :</span>
<span class="sd">            Whether to calculate and return the additional `map_qind` and `axes` tuple.</span>
<span class="sd">        permute :</span>
<span class="sd">            If False, don&#39;t perform permutations in case one of `inds` is an unsorted index array,</span>
<span class="sd">            but consider it as a mask only, ignoring the order of the indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map_qind_part2self : function</span>
<span class="sd">            Only returned if `calc_map_qind` is True.</span>
<span class="sd">            This function takes qindices from `res` as arguments</span>
<span class="sd">            and returns ``(qindices, block_mask)`` such that</span>
<span class="sd">            ``res._get_block(part_qindices) = self._get_block(qindices)[block_mask]``.</span>
<span class="sd">            permutation are ignored for this.</span>
<span class="sd">        permutations : list((int, 1D array(int)))</span>
<span class="sd">            Only returned if `calc_map_qind` is True.</span>
<span class="sd">            Collects (axes, permutation) applied to `res` *after* `take_slice` and `iproject`.</span>
<span class="sd">        res : :class:`Array`</span>
<span class="sd">            A copy with the data ``self[inds]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># non-integer inds -&gt; slicing / projection</span>
        <span class="n">slice_inds</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># arguments for `take_slice`</span>
        <span class="n">slice_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">project_masks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># arguments for `iproject`</span>
        <span class="n">project_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">permutations</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># [axis, mask] for all axes for which we need to call `permute`</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">project_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">project_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">permutations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">m</span><span class="p">),</span>
                                                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>  <span class="c1"># not iterable: single index</span>
                    <span class="n">slice_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">slice_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># iterable</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">project_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">project_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>  <span class="c1"># should be integer indexing</span>
                        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># check if `i` is sorted</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">perm</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">))):</span>
                            <span class="c1"># np.argsort(i) gives the reverse permutation, so reverse it again.</span>
                            <span class="c1"># In that way, we get the permuation within the projected indices.</span>
                            <span class="n">permutations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">inverse_permutation</span><span class="p">(</span><span class="n">perm</span><span class="p">)))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take_slice</span><span class="p">(</span><span class="n">slice_inds</span><span class="p">,</span> <span class="n">slice_axes</span><span class="p">)</span>
        <span class="n">res_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([(</span><span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">slice_axes</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">p_map_qinds</span><span class="p">,</span> <span class="n">p_masks</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">iproject</span><span class="p">(</span><span class="n">project_masks</span><span class="p">,</span> <span class="p">[</span><span class="n">res_axes</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">project_axes</span><span class="p">])</span>
        <span class="n">permutations</span> <span class="o">=</span> <span class="p">[(</span><span class="n">res_axes</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">permute</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">calc_map_qind</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">part2self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_advanced_getitem_map_qind</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">slice_axes</span><span class="p">,</span> <span class="n">slice_inds</span><span class="p">,</span> <span class="n">project_axes</span><span class="p">,</span>
                                                    <span class="n">p_map_qinds</span><span class="p">,</span> <span class="n">p_masks</span><span class="p">,</span> <span class="n">res_axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">part2self</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_advanced_getitem_map_qind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">slice_axes</span><span class="p">,</span> <span class="n">slice_inds</span><span class="p">,</span> <span class="n">project_axes</span><span class="p">,</span> <span class="n">p_map_qinds</span><span class="p">,</span>
                                   <span class="n">p_masks</span><span class="p">,</span> <span class="n">res_axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a function mapping from qindices of `self[inds]` back to qindices of self.</span>

<span class="sd">        This function is called only by `_advanced_getitem(calc_map_qind=True)`</span>
<span class="sd">        to obtain the function `map_qind_part2self`,</span>
<span class="sd">        which in turn in needed in `_advanced_setitem_npc` for ``self[inds] = other``.</span>
<span class="sd">        This function returns a function `part2self`, see doc string in the source for details.</span>
<span class="sd">        Note: the function ignores permutations introduced by `inds` - they are handled separately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">map_qinds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">map_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">slice_axes</span><span class="p">,</span> <span class="n">slice_inds</span><span class="p">):</span>
            <span class="n">qi</span><span class="p">,</span> <span class="n">within_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">map_qinds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">qi</span>
            <span class="n">map_blocks</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">within_block</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">m_qind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">project_axes</span><span class="p">,</span> <span class="n">p_map_qinds</span><span class="p">):</span>
            <span class="n">map_qinds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">m_qind</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># revert m_qind</span>
        <span class="c1"># keep_axes = neither in slice_axes nor in project_axes</span>
        <span class="n">keep_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">map_qinds</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">not_slice_axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">project_axes</span> <span class="o">+</span> <span class="n">keep_axes</span><span class="p">)</span>
        <span class="n">bsizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">_get_block_sizes</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">part2self</span><span class="p">(</span><span class="n">part_qindices</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Given `part_qindices` of ``res = self[inds]``,</span>
<span class="sd">            return (`qindices`, `block_mask`) such that</span>
<span class="sd">            ``res._get_block(part_qindices) == self._get_block(qindices)``.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">qindices</span> <span class="o">=</span> <span class="n">map_qinds</span><span class="p">[:]</span>  <span class="c1"># copy</span>
            <span class="n">block_mask</span> <span class="o">=</span> <span class="n">map_blocks</span><span class="p">[:]</span>  <span class="c1"># copy</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">keep_axes</span><span class="p">:</span>
                <span class="n">qindices</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">qi</span> <span class="o">=</span> <span class="n">part_qindices</span><span class="p">[</span><span class="n">res_axes</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span>
                <span class="n">block_mask</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bsizes</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">qi</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">bmask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">project_axes</span><span class="p">,</span> <span class="n">p_masks</span><span class="p">):</span>
                <span class="n">old_qi</span> <span class="o">=</span> <span class="n">part_qindices</span><span class="p">[</span><span class="n">res_axes</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span>
                <span class="n">qindices</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_qinds</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">old_qi</span><span class="p">]</span>
                <span class="n">block_mask</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">bmask</span><span class="p">[</span><span class="n">old_qi</span><span class="p">]</span>
            <span class="c1"># advanced indexing in numpy is tricky ^_^</span>
            <span class="c1"># np.ix_ can&#39;t handle integer entries reducing the dimension.</span>
            <span class="c1"># we have to call it only on the entries with arrays</span>
            <span class="n">ix_block_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">block_mask</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">not_slice_axes</span><span class="p">])</span>
            <span class="c1"># and put the result back into block_mask</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">bm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">not_slice_axes</span><span class="p">,</span> <span class="n">ix_block_mask</span><span class="p">):</span>
                <span class="n">block_mask</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">bm</span>
            <span class="k">return</span> <span class="n">qindices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">block_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">part2self</span>

    <span class="k">def</span> <span class="nf">_advanced_setitem_npc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Self[inds] = other for non-integer `inds` and :class:`Array` `other`.</span>

<span class="sd">        This function is called by self.__setitem__(inds, other).&quot;&quot;&quot;</span>
        <span class="c1"># suppress warning if we project a pipe</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">map_part2self</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">self_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_advanced_getitem</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span>
                                                                            <span class="n">calc_map_qind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                            <span class="n">permute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># permuations are ignored by map_part2self.</span>
        <span class="c1"># instead of figuring out permuations in self, apply the *reversed* permutations ot other</span>
        <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">inverse_permutation</span><span class="p">(</span><span class="n">perm</span><span class="p">),</span> <span class="n">ax</span><span class="p">)</span>
        <span class="c1"># now test compatibility of self_part with `other`</span>
        <span class="k">if</span> <span class="n">self_part</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;wrong number of indices&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pl</span><span class="p">,</span> <span class="n">ol</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">self_part</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">legs</span><span class="p">):</span>
            <span class="n">pl</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">ol</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">self_part</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">qtotal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong charge for assinging self[inds] = other&quot;</span><span class="p">)</span>
        <span class="c1"># note: a block exists in self_part, if and only if its extended version exists in self.</span>
        <span class="c1"># by definition, non-existent blocks in `other` are zero.</span>
        <span class="c1"># instead of checking which blocks are non-existent,</span>
        <span class="c1"># we first set self[inds] completely to zero</span>
        <span class="k">for</span> <span class="n">p_qindices</span> <span class="ow">in</span> <span class="n">self_part</span><span class="o">.</span><span class="n">_qdata</span><span class="p">:</span>
            <span class="n">qindices</span><span class="p">,</span> <span class="n">block_mask</span> <span class="o">=</span> <span class="n">map_part2self</span><span class="p">(</span><span class="n">p_qindices</span><span class="p">)</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
            <span class="n">block</span><span class="p">[</span><span class="n">block_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># overwrite data in self</span>
        <span class="c1"># now we copy blocks from other</span>
        <span class="k">for</span> <span class="n">o_block</span><span class="p">,</span> <span class="n">o_qindices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_qdata</span><span class="p">):</span>
            <span class="n">qindices</span><span class="p">,</span> <span class="n">block_mask</span> <span class="o">=</span> <span class="n">map_part2self</span><span class="p">(</span><span class="n">o_qindices</span><span class="p">)</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">qindices</span><span class="p">,</span> <span class="n">insert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">block</span><span class="p">[</span><span class="n">block_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">o_block</span>  <span class="c1"># overwrite data in self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ipurge_zeros</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>  <span class="c1"># remove blocks identically zero</span>

    <span class="k">def</span> <span class="nf">_combine_legs_make_pipes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">,</span> <span class="n">pipes</span><span class="p">,</span> <span class="n">qconj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Argument parsing for :meth:`combine_legs`: make missing pipes.</span>

<span class="sd">        Generates missing pipes &amp; checks compatibility for provided pipes.&quot;&quot;&quot;</span>
        <span class="n">npipes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">)</span>
        <span class="c1"># default arguments for pipes and qconj</span>
        <span class="k">if</span> <span class="n">pipes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pipes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">npipes</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">pipes</span><span class="p">)</span> <span class="o">!=</span> <span class="n">npipes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of `pipes`&quot;</span><span class="p">)</span>
        <span class="n">qconj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">qconj</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qconj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">npipes</span><span class="p">:</span>
            <span class="n">qconj</span> <span class="o">=</span> <span class="p">[</span><span class="n">qconj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">npipes</span>  <span class="c1"># same qconj for all pipes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qconj</span><span class="p">)</span> <span class="o">!=</span> <span class="n">npipes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of `qconj`&quot;</span><span class="p">)</span>

        <span class="n">pipes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pipes</span><span class="p">)</span>
        <span class="c1"># make pipes as necessary</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pipes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pipe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">qconj_i</span> <span class="o">=</span> <span class="n">qconj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">qconj_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">qconj_i</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>  <span class="c1"># will change in future to</span>
                    <span class="n">qconj_i_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">qconj</span>
                    <span class="k">if</span> <span class="n">qconj_i</span> <span class="o">!=</span> <span class="n">qconj_i_new</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;combine_legs default value for `qconj` will change &quot;</span>
                            <span class="s2">&quot;from +1 to `qconj` of the first leg, here `-1`&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_pipe</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">combine_legs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj_i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># test for compatibility</span>
                <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">combine_legs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">pipe</span><span class="o">.</span><span class="n">nlegs</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">legs</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pipe has wrong number of legs&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">qconj</span> <span class="o">!=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">qconj</span><span class="p">:</span>
                    <span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>  <span class="c1"># need opposite qind</span>
                <span class="k">for</span> <span class="n">self_leg</span><span class="p">,</span> <span class="n">pipe_leg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">legs</span><span class="p">):</span>
                    <span class="n">self_leg</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">pipe_leg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pipes</span>

    <span class="k">def</span> <span class="nf">_combine_legs_new_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Figure out new_axes and how legs have to be transposed.&quot;&quot;&quot;</span>
        <span class="n">all_combine_legs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">)</span>
        <span class="n">non_combined_legs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_combine_legs</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">new_axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># figure out default new_legs</span>
            <span class="n">first_cl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">combine_legs</span><span class="p">])</span>
            <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">non_combined_legs</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">first_cl</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">first_cl</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># test compatibility</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of `new_axes`&quot;</span><span class="p">)</span>
            <span class="n">new_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_combined_legs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_axes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">new_rank</span>
                <span class="k">elif</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">new_rank</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_axis larger than the new number of legs&quot;</span><span class="p">)</span>
        <span class="n">transp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">non_combined_legs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">new_axes</span><span class="p">):</span>
            <span class="n">transp</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_axes</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="n">combine_legs</span><span class="p">[</span><span class="n">s</span><span class="p">]))</span>
        <span class="n">transp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transp</span><span class="p">,</span> <span class="p">[])</span>  <span class="c1"># flatten: [a] + [b] = [a, b]</span>
        <span class="k">return</span> <span class="n">new_axes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">transp</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_leg_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate label for legs combined in a :class:`LegPipe`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; self._combine_leg_labels([&#39;a&#39;, &#39;b&#39;, &#39;(c.d)&#39;])</span>
<span class="sd">        &#39;(a.b.(c.d))&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_split_leg_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Revert the combination of labels performed in :meth:`combine_leg_labels`.</span>

<span class="sd">        Return a list of labels corresponding to the original labels before &#39;combine_leg_labels&#39;.</span>
<span class="sd">        Test that it splits into `count` labels.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; self._split_leg_label(&#39;(a.b.(c.d))&#39;, 3)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;(c.d)&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>
        <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;(&#39;</span> <span class="ow">or</span> <span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;split leg with label not in Form &#39;(...)&#39;: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">label</span><span class="p">),</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">count</span>
        <span class="n">beg</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># number of non-closed &#39;(&#39; to the left</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong number of splitted labels.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;?&#39;</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_conj_leg_label</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Conjugate a leg `label`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; self._conj_leg_labels(&#39;a&#39;)</span>
<span class="sd">        &#39;a*&#39;</span>
<span class="sd">        &gt;&gt;&gt; self._conj_leg_labels(&#39;a*&#39;)</span>
<span class="sd">        &#39;a&#39;</span>
<span class="sd">        &gt;&gt;&gt; self._conj_leg_labels(&#39;(a.(b*.c))&#39;)</span>
<span class="sd">        &#39;(a*.(b.c*))&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first insert &#39;*&#39; after each label, taking into account recursion of LegPipes</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span> <span class="ow">and</span> <span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;.)&#39;</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">beg</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">beg</span><span class="p">:])</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s1">&#39;*&#39;</span>
        <span class="c1"># remove &#39;**&#39; entries</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="nd">@use_cython</span><span class="p">(</span><span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;Array__imake_contiguous&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_imake_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make each of the blocks c-style contigous in memory.</span>

<span class="sd">        Might speed up subsequent tensordot &amp; co by fixing the memory layout to contigous blocks.</span>
<span class="sd">        (No need to call it manually: it&#39;s called from tensordot &amp; co anyways!)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<span class="c1"># ##################################</span>
<span class="c1"># global functions</span>
<span class="c1"># ##################################</span>


<div class="viewcode-block" id="zeros"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.zeros.html#tenpy.linalg.np_conserved.zeros">[docs]</a><span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">legcharges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a npc array full of zeros (with no _data).</span>

<span class="sd">    This is just a wrapper around ``Array(...)``,</span>
<span class="sd">    detailed documentation can be found in the class doc-string of :class:`Array`.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Array</span><span class="p">(</span><span class="n">legcharges</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span></div>


<div class="viewcode-block" id="eye_like"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.eye_like.html#tenpy.linalg.np_conserved.eye_like">[docs]</a><span class="k">def</span> <span class="nf">eye_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an identity matrix contractible with the leg `axis` of the :class:`Array` `a`.&quot;&quot;&quot;</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span></div>


<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.diag.html#tenpy.linalg.np_conserved.diag">[docs]</a><span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">leg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a square, diagonal matrix of entries `s`.</span>

<span class="sd">    The resulting matrix has legs ``(leg, leg.conj())`` and charge 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : scalar | 1D array</span>
<span class="sd">        The entries to put on the diagonal. If scalar, all diagonal entries are the same.</span>
<span class="sd">    leg : :class:`LegCharge`</span>
<span class="sd">        The first leg of the resulting matrix.</span>
<span class="sd">    dtype : None | type</span>
<span class="sd">        The data type to be used for the result. By default, use dtype of `s`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diagonal : :class:`Array`</span>
<span class="sd">        A square matrix with diagonal entries `s`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    Array.scale_axis : similar as ``tensordot(diag(s), ...)``, but faster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">scalar</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">scalar</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">leg</span><span class="o">.</span><span class="n">ind_len</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(s)=</span><span class="si">{0:d}</span><span class="s2"> not equal to leg.ind_len=</span><span class="si">{1:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">leg</span><span class="o">.</span><span class="n">ind_len</span><span class="p">))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">((</span><span class="n">leg</span><span class="p">,</span> <span class="n">leg</span><span class="o">.</span><span class="n">conj</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># default charge is 0</span>
    <span class="c1"># qdata = [[0, 0], [1, 1], ....]</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">block_number</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="c1"># ``res._qdata_sorted = True`` was already set</span>
    <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">leg</span><span class="o">.</span><span class="n">_get_block_sizes</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">leg</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)])</span> <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">block_number</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.concatenate.html#tenpy.linalg.np_conserved.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stack arrays along a given axis, similar as np.concatenate.</span>

<span class="sd">    Stacks the qind of the array, without sorting/blocking.</span>
<span class="sd">    Labels are inherited from the first array only.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : iterable of :class:`Array`</span>
<span class="sd">        The arrays to be stacked. They must have the same shape and charge data</span>
<span class="sd">        except on the specified axis.</span>
<span class="sd">    axis : int | str</span>
<span class="sd">        Leg index or label of the first array. Defines the axis along which the arrays are stacked.</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Whether to copy the data blocks.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    stacked : :class:`Array`</span>
<span class="sd">        Concatenation of the given `arrays` along the specified axis.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    Array.sort_legcharge : can be used to block by charges along the axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">()</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">get_leg_index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">not_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="c1"># test for compatibility</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong shape to fit &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; into &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="n">res</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong ChargeInfo&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">res</span><span class="o">.</span><span class="n">qtotal</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong qtotal&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">not_axis</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="p">[])</span>
    <span class="c1"># stack the data</span>
    <span class="n">res_axis_bl_sizes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_axis_charges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_qdata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">qind_shift</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># sum of previous `block_number`</span>
    <span class="n">axis_qconj</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">qconj</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="n">leg</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">res_axis_bl_sizes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">_get_block_sizes</span><span class="p">())</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="n">leg</span><span class="o">.</span><span class="n">charges</span> <span class="k">if</span> <span class="n">leg</span><span class="o">.</span><span class="n">qconj</span> <span class="o">==</span> <span class="n">axis_qconj</span> <span class="k">else</span> <span class="n">res</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="o">-</span><span class="n">leg</span><span class="o">.</span><span class="n">charges</span><span class="p">)</span>
        <span class="n">res_axis_charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">charges</span><span class="p">)</span>
        <span class="n">qdata</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">qdata</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">qind_shift</span>
        <span class="n">res_qdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qdata</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">res_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span>
        <span class="n">qind_shift</span> <span class="o">+=</span> <span class="n">leg</span><span class="o">.</span><span class="n">block_number</span>
    <span class="n">res_axis_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">res_axis_bl_sizes</span><span class="p">))</span>
    <span class="n">res_axis_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res_axis_charges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qind</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">res_axis_slices</span><span class="p">,</span> <span class="n">res_axis_charges</span><span class="p">,</span> <span class="n">axis_qconj</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res_qdata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">res_data</span>
    <span class="n">res</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="grid_concat"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.grid_concat.html#tenpy.linalg.np_conserved.grid_concat">[docs]</a><span class="k">def</span> <span class="nf">grid_concat</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an np.array of npc.Arrays, performs a multi-dimensional concatentation along &#39;axes&#39;.</span>

<span class="sd">    Similar to :func:`numpy.block`, but only for uniform blocking.</span>

<span class="sd">    Stacks the qind of the array, *without* sorting/blocking.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : array_like of :class:`Array`</span>
<span class="sd">        The grid of arrays.</span>
<span class="sd">    axes : list of int</span>
<span class="sd">        The axes along which to concatenate the arrays,  same len as the dimension of the grid.</span>
<span class="sd">        Concatenate arrays of the `i`th axis of the grid along the axis ``axes[i]``</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Whether the _data blocks are copied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Assume we have rank 2 Arrays ``A, B, C, D`` of shapes</span>
<span class="sd">    ``(1, 2), (1, 4), (3, 2), (3, 4)`` sharing the legs of equal sizes.</span>
<span class="sd">    Then the following grid will result in a ``(1+3, 2+4)`` shaped array:</span>

<span class="sd">    &gt;&gt;&gt; g = grid_concat([[A, B], [C, D]], axes=[0, 1])</span>
<span class="sd">    &gt;&gt;&gt; g.shape</span>
<span class="sd">    (4, 6)</span>

<span class="sd">    If ``A, B, C, D`` were rank 4 arrays, with the first and last leg as before, and sharing</span>
<span class="sd">    *common* legs ``1`` and ``2`` of dimensions 1, 2, then you would get a rank-4 array:</span>

<span class="sd">    &gt;&gt;&gt; g = grid_concat([[A, B], [C, D]], axes=[0, 3])</span>
<span class="sd">    &gt;&gt;&gt; g.shape</span>
<span class="sd">    (4, 1, 2, 6)</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    Array.sort_legcharge : can be used to block by charges.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid has wrong dimension&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`None` entry in 1D grid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">copy</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">flat</span><span class="p">]):</span>
        <span class="n">new_legs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">a</span><span class="p">]</span>
            <span class="n">grid_tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span>
            <span class="n">leg</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">grid_tr_row</span> <span class="ow">in</span> <span class="n">grid_tr</span><span class="p">:</span>
                <span class="c1"># get first g which is not None in grid_tr_row</span>
                <span class="n">first_g</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid_tr_row</span><span class="o">.</span><span class="n">flat</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">first_g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Full row/column with only `None` entries&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">leg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_g</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="n">ax</span><span class="p">))</span>
            <span class="n">new_legs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leg</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">first_g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">first_g</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">first_g</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">zeros_legs</span> <span class="o">=</span> <span class="n">first_g</span><span class="o">.</span><span class="n">legs</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">new_leg</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">new_legs</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                    <span class="n">zeros_legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_leg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">zeros_legs</span><span class="p">,</span> <span class="n">first_g</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">first_g</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>
    <span class="k">return</span> <span class="n">_grid_concat_recursion</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="grid_outer"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.grid_outer.html#tenpy.linalg.np_conserved.grid_outer">[docs]</a><span class="k">def</span> <span class="nf">grid_outer</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_legs</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an np.array of npc.Arrays, return the corresponding higher-dimensional Array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : array_like of {:class:`Array` | None}</span>
<span class="sd">        The grid gives the first part of the axes of the resulting array.</span>
<span class="sd">        Entries have to have all the same shape and charge-data, giving the remaining axes.</span>
<span class="sd">        ``None`` entries in the grid are interpreted as zeros.</span>
<span class="sd">    grid_legs : list of :class:`LegCharge`</span>
<span class="sd">        One LegCharge for each dimension of the grid along the grid.</span>
<span class="sd">    qtotal : charge</span>
<span class="sd">        The total charge of the Array.</span>
<span class="sd">        By default (``None``), derive it out from a non-trivial entry of the grid.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : :class:`Array`</span>
<span class="sd">        An Array with shape ``grid.shape + nontrivial_grid_entry.shape``.</span>
<span class="sd">        Constructed such that ``res[idx] == grid[idx]`` for any index ``idx`` of the `grid`</span>
<span class="sd">        the `grid` entry is not trivial (``None``).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    detect_grid_outer_legcharge : can calculate one missing :class:`LegCharge` of the grid.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A typical use-case for this function is the generation of an MPO.</span>
<span class="sd">    Say you have npc.Arrays ``Splus, Sminus, Sz``, each with legs ``[phys.conj(), phys]``.</span>
<span class="sd">    Further, you have to define appropriate LegCharges `l_left` and `l_right`.</span>
<span class="sd">    Then one &#39;matrix&#39; of the MPO for a nearest neighbour Heisenberg Hamiltonian could look like:</span>

<span class="sd">    &gt;&gt;&gt; Id = np.eye_like(Sz)</span>
<span class="sd">    &gt;&gt;&gt; W_mpo = grid_outer([[Id, Splus, Sminus, Sz, None],</span>
<span class="sd">    ...                     [None, None, None, None, J*Sminus],</span>
<span class="sd">    ...                     [None, None, None, None, J*Splus],</span>
<span class="sd">    ...                     [None, None, None, None, J*Sz],</span>
<span class="sd">    ...                     [None, None, None, None, Id]],</span>
<span class="sd">    ...                    leg_charges=[l_left, l_right])</span>
<span class="sd">    &gt;&gt;&gt; W_mpo.shape</span>
<span class="sd">    (5, 5, 2, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grid_shape</span><span class="p">,</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">_nontrivial_grid_entries</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_legs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong number of grid_legs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">grid_shape</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">grid_legs</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid shape incompatible with grid_legs&quot;</span><span class="p">)</span>
    <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># first non-trivial entry</span>
    <span class="n">chinfo</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">chinfo</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">],</span> <span class="p">[])</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grid_legs</span><span class="p">)</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="n">legs</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">qtotal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># figure out qtotal from first non-zero entry</span>
        <span class="n">grid_charges</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">grid_legs</span><span class="p">)]</span>
        <span class="n">qtotal</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid_charges</span> <span class="o">+</span> <span class="p">[</span><span class="n">entry</span><span class="o">.</span><span class="n">qtotal</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qtotal</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>
    <span class="c1"># main work: iterate over all non-trivial entries to fill `res`.</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span>  <span class="c1"># insert the values with Array.__setitem__ partial slicing.</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">entry</span><span class="o">.</span><span class="n">_labels</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">labels</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="detect_grid_outer_legcharge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.detect_grid_outer_legcharge.html#tenpy.linalg.np_conserved.detect_grid_outer_legcharge">[docs]</a><span class="k">def</span> <span class="nf">detect_grid_outer_legcharge</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid_legs</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bunch</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Derive a LegCharge for a grid used for :func:`grid_outer`.</span>

<span class="sd">    Note: The resulting LegCharge is *not* bunched.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : array_like of {:class:`Array` | None}</span>
<span class="sd">        The grid as it will be given to :func:`grid_outer`.</span>
<span class="sd">    grid_legs : list of {:class:`LegCharge` | None}</span>
<span class="sd">        One LegCharge for each dimension of the grid, except for one entry which is ``None``.</span>
<span class="sd">        This missing entry is to be calculated.</span>
<span class="sd">    qtotal : charge</span>
<span class="sd">        The desired total charge of the array. Defaults to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_grid_legs : list of :class:`LegCharge`</span>
<span class="sd">        A copy of the given `grid_legs` with the ``None`` replaced by a compatible LegCharge.</span>
<span class="sd">        The new LegCharge is neither bunched nor sorted!</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    detect_legcharge : similar functionality for a flat numpy array instead of a grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grid_shape</span><span class="p">,</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">_nontrivial_grid_entries</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_legs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong number of grid_legs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span> <span class="o">!=</span> <span class="n">l</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">grid_legs</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid shape incompatible with grid_legs&quot;</span><span class="p">)</span>
    <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># first non-trivial entry</span>
    <span class="n">chinfo</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">chinfo</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid_legs</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only derive one grid_leg&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">grid_legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grid_legs</span><span class="p">)</span>
    <span class="n">qtotal</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span><span class="p">)</span>  <span class="c1"># charge 0, if qtotal is not set.</span>
    <span class="n">qflat</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="n">grid_charges</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">grid_legs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">axis</span>
        <span class="p">]</span>
        <span class="n">qflat_entry</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">entry</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">grid_charges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">qflat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qflat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">qflat_entry</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">qflat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">qflat_entry</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;different grid entries lead to different charges at index &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qflat</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t derive flat charge for all indices:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">qflat</span><span class="p">))</span>
    <span class="n">grid_legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qconj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qflat</span><span class="p">)),</span>
                                           <span class="n">qconj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grid_legs</span></div>


<div class="viewcode-block" id="detect_qtotal"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.detect_qtotal.html#tenpy.linalg.np_conserved.detect_qtotal">[docs]</a><span class="k">def</span> <span class="nf">detect_qtotal</span><span class="p">(</span><span class="n">flat_array</span><span class="p">,</span> <span class="n">legcharges</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the total charge (w.r.t `legs`) of first non-zero sector found in `flat_array`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flat_array : array</span>
<span class="sd">        The flat numpy array from which you want to detect the charges.</span>
<span class="sd">    legcharges : list of :class:`LegCharge`</span>
<span class="sd">        For each leg the LegCharge.</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        Blocks with ``np.max(np.abs(block)) &gt; cutoff`` are considered as zero.</span>
<span class="sd">        Defaults to :data:`QCUTOFF`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qtotal : charge</span>
<span class="sd">        The total charge fo the first non-zero (i.e. &gt; cutoff) charge block.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    detect_legcharge : detects the charges of one missing LegCharge if `qtotal` is known.</span>
<span class="sd">    detect_grid_outer_legcharge : similar functionality if the flat array is given by a &#39;grid&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">QCUTOFF</span>
    <span class="n">chinfo</span> <span class="o">=</span> <span class="n">legcharges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">chinfo</span>
    <span class="n">test_array</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">legcharges</span><span class="p">)</span>  <span class="c1"># Array prototype with correct charges</span>
    <span class="k">for</span> <span class="n">qindices</span> <span class="ow">in</span> <span class="n">test_array</span><span class="o">.</span><span class="n">_iter_all_blocks</span><span class="p">():</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="n">test_array</span><span class="o">.</span><span class="n">_get_block_slices</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flat_array</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">test_array</span><span class="o">.</span><span class="n">_get_block_charge</span><span class="p">(</span><span class="n">qindices</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;can&#39;t detect total charge: no entry larger than cutoff. Return 0 charge.&quot;</span><span class="p">,</span>
                  <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()</span></div>


<div class="viewcode-block" id="detect_legcharge"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.detect_legcharge.html#tenpy.linalg.np_conserved.detect_legcharge">[docs]</a><span class="k">def</span> <span class="nf">detect_legcharge</span><span class="p">(</span><span class="n">flat_array</span><span class="p">,</span> <span class="n">chargeinfo</span><span class="p">,</span> <span class="n">legcharges</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate a missing `LegCharge` by looking for nonzero entries of a flat array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flat_array : ndarray</span>
<span class="sd">        A flat array, in which we look for non-zero entries.</span>
<span class="sd">    chargeinfo : :class:`~tenpy.linalg.charges.ChargeInfo`</span>
<span class="sd">        The nature of the charge.</span>
<span class="sd">    legcharges : list of :class:`LegCharge`</span>
<span class="sd">        One LegCharge for each dimension of flat_array, except for one entry which is ``None``.</span>
<span class="sd">        This missing entry is to be calculated.</span>
<span class="sd">    qconj : {+1, -1}</span>
<span class="sd">        `qconj` for the new calculated LegCharge.</span>
<span class="sd">    qtotal : charges</span>
<span class="sd">        Desired total charge of the array. Defaults to zeros.</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        Blocks with ``np.max(np.abs(block)) &gt; cutoff`` are considered as zero.</span>
<span class="sd">        Defaults to :data:`QCUTOFF`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_legcharges : list of :class:`LegCharge`</span>
<span class="sd">        A copy of the given `legcharges` with the ``None`` replaced by a compatible LegCharge.</span>
<span class="sd">        The new legcharge is &#39;bunched&#39;, but not sorted!</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    detect_grid_outer_legcharge : similar functionality if the flat array is given by a &#39;grid&#39;.</span>
<span class="sd">    detect_qtotal : detects the total charge, if all legs are known.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flat_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flat_array</span><span class="p">)</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">legcharges</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">QCUTOFF</span>
    <span class="k">if</span> <span class="n">flat_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">legs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong number of grid_legs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span> <span class="o">!=</span> <span class="n">l</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flat_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">legs</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array shape incompatible with legcharges&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">legs</span><span class="p">)</span> <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only derive charges for one leg.&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">axis_len</span> <span class="o">=</span> <span class="n">flat_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">chargeinfo</span><span class="o">.</span><span class="n">qnumber</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_trivial</span><span class="p">(</span><span class="n">axis_len</span><span class="p">,</span> <span class="n">chargeinfo</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="n">qconj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">legs</span>
    <span class="n">qtotal</span> <span class="o">=</span> <span class="n">chargeinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span><span class="p">)</span>  <span class="c1"># charge 0, if qtotal is not set.</span>
    <span class="n">legs_known</span> <span class="o">=</span> <span class="n">legs</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">legs</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">qflat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">axis_len</span><span class="p">,</span> <span class="n">chargeinfo</span><span class="o">.</span><span class="n">qnumber</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">QTYPE</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis_len</span><span class="p">):</span>
        <span class="n">A_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">flat_array</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">qflat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">detect_qtotal</span><span class="p">(</span><span class="n">A_i</span><span class="p">,</span> <span class="n">legs_known</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
    <span class="n">qflat</span> <span class="o">=</span> <span class="n">chargeinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">((</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">qflat</span><span class="p">)</span> <span class="o">*</span> <span class="n">qconj</span><span class="p">)</span>
    <span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">chargeinfo</span><span class="p">,</span> <span class="n">qflat</span><span class="p">,</span> <span class="n">qconj</span><span class="p">)</span><span class="o">.</span><span class="n">bunch</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">legs</span></div>


<div class="viewcode-block" id="trace"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.trace.html#tenpy.linalg.np_conserved.trace">[docs]</a><span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">leg1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">leg2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Trace of `a`, summing over leg1 and leg2.</span>

<span class="sd">    Requires that the contracted legs are contractible (i.e. have opposite charges).</span>
<span class="sd">    Labels are inherited from `a`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    leg1, leg2: str|int</span>
<span class="sd">        The leg label or index for the two legs which should be contracted (i.e. summed over).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    traced : :class:`Array` | ``a.dtype``</span>
<span class="sd">        A scalar if ``a.rank == 2``, else an :class:`Array` of rank ``a.rank - 2``.</span>
<span class="sd">        Equivalent to ``sum([a.take_slice([i, i], [leg1, leg2]) for i in range(a.shape[leg1])])``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">([</span><span class="n">leg1</span><span class="p">,</span> <span class="n">leg2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ax1</span> <span class="o">==</span> <span class="n">ax2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leg1 = </span><span class="si">{0!r}</span><span class="s2"> == leg2 = </span><span class="si">{1!r}</span><span class="s2"> ???&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">leg1</span><span class="p">,</span> <span class="n">leg2</span><span class="p">))</span>
    <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># full contraction: ax1, ax2 = 0, 1 or vice versa</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qdata_row</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">qdata_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">qdata_row</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="c1"># non-complete contraction</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">ax1</span> <span class="ow">and</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">ax2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">legs</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res_data</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary qdata_row -&gt; block</span>
        <span class="k">for</span> <span class="n">qdata_row</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">qdata_row</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">qdata_row</span><span class="p">[</span><span class="n">ax2</span><span class="p">]:</span>
                <span class="k">continue</span>  <span class="c1"># not on the diagonal =&gt; doesn&#39;t contribute</span>
            <span class="n">new_qdata_row</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">qdata_row</span><span class="p">[</span><span class="n">keep</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">new_qdata_row</span> <span class="ow">in</span> <span class="n">res_data</span><span class="p">:</span>
                <span class="n">res_data</span><span class="p">[</span><span class="n">new_qdata_row</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_data</span><span class="p">[</span><span class="n">new_qdata_row</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">res_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># labels</span>
    <span class="n">a_labels</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_labels</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_labels</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">keep</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.outer.html#tenpy.linalg.np_conserved.outer">[docs]</a><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forms the outer tensor product, equivalent to ``tensordot(a, b, axes=0)``.</span>

<span class="sd">    Labels are inherited from `a` and `b`. In case of a collision (same label in both `a` and `b`),</span>
<span class="sd">    they are both dropped.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : :class:`Array`</span>
<span class="sd">        The arrays for which to form the product.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : :class:`Array`</span>
<span class="sd">        Array of rank ``a.rank + b.rank`` such that (for ``Ra = a.rank; Rb = b.rank``)::</span>

<span class="sd">            c[i_1, ..., i_Ra, j_1, ... j_R] = a[i_1, ..., i_Ra] * b[j_1, ..., j_rank_b]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;different ChargeInfo&quot;</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>
    <span class="n">qtotal</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>

    <span class="c1"># fill with data</span>
    <span class="n">qdata_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span>
    <span class="n">qdata_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">qdata_a</span><span class="p">),</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">qdata_b</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># grid is lexsorted like qdata, with rows as all combinations of a/b block indices.</span>
    <span class="n">qdata_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">qdata_a</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">qdata_b</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">qdata_res</span><span class="p">[:,</span> <span class="p">:</span><span class="n">a</span><span class="o">.</span><span class="n">rank</span><span class="p">]</span> <span class="o">=</span> <span class="n">qdata_a</span><span class="p">[</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="n">qdata_res</span><span class="p">[:,</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span><span class="p">:]</span> <span class="o">=</span> <span class="n">qdata_b</span><span class="p">[</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># use numpys broadcasting to obtain the tensor product</span>
    <span class="n">idx_reshape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
    <span class="n">data_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">ta</span><span class="p">[</span><span class="n">idx_reshape</span><span class="p">]</span> <span class="k">for</span> <span class="n">ta</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
    <span class="n">idx_reshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">data_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">tb</span><span class="p">[</span><span class="n">idx_reshape</span><span class="p">]</span> <span class="k">for</span> <span class="n">tb</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">_data</span><span class="p">]</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">]</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">qdata_res</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata_sorted</span>  <span class="c1"># since grid is lex sorted</span>
    <span class="c1"># labels</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">_drop_duplicate_labels</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.inner.html#tenpy.linalg.np_conserved.inner">[docs]</a><span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_conj</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Contract all legs in `a` and `b`, return scalar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : class:`Array`</span>
<span class="sd">        The arrays for which to calculate the product.</span>
<span class="sd">        Must have same rank, and compatible LegCharges.</span>
<span class="sd">    axes : ``(axes_a, axes_b)`` | ``None``</span>
<span class="sd">        ``None`` is equivalent to ``(range(rank), range(rank))``.</span>
<span class="sd">        Alternatively, `axes_a` and `axes_b` specifiy the legs of `a` and `b`, respectively,</span>
<span class="sd">        which should be contracted. Legs can be specified with leg labels or indices.</span>
<span class="sd">        Contract leg ``axes_a[i]`` of `a` with leg ``axes_b[i]`` of `b`.</span>
<span class="sd">    do_conj : bool</span>
<span class="sd">        If ``False`` (Default), ignore it.</span>
<span class="sd">        if ``True``, conjugate `a` before, i.e., return ``inner(a.conj(), b, axes)``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inner_product : dtype</span>
<span class="sd">        A scalar (of common dtype of `a` and `b`) giving the full contraction of `a` and `b`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;different rank!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes_a</span><span class="p">,</span> <span class="n">axes_b</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="n">axes_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes_a</span><span class="p">))</span>
        <span class="n">axes_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes_b</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_b</span><span class="p">)</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no full contraction. Use tensordot instead!&quot;</span><span class="p">)</span>
        <span class="c1"># we can permute axes_a and axes_b. Use that to ensure axes_b = range(b.rank)</span>
        <span class="n">sort_axes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axes_b</span><span class="p">)</span>
        <span class="n">axes_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_axes_b</span><span class="p">]</span>
        <span class="n">transp</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rank</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">transp</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">transp</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span>
    <span class="c1"># check charge compatibility</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize</span><span class="p">(</span><span class="n">OptimizationFlag</span><span class="o">.</span><span class="n">skip_arg_checks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;different ChargeInfo&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lega</span><span class="p">,</span> <span class="n">legb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">do_conj</span><span class="p">:</span>
                <span class="n">lega</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">legb</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lega</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">legb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">do_conj</span><span class="p">)</span></div>


<div class="viewcode-block" id="tensordot"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.tensordot.html#tenpy.linalg.np_conserved.tensordot">[docs]</a><span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar as ``np.tensordot`` but for :class:`Array`.</span>

<span class="sd">    Builds the tensor product of `a` and `b` and sums over the specified axes.</span>
<span class="sd">    Does not require complete blocking of the charges.</span>

<span class="sd">    Labels are inherited from `a` and `b`.</span>
<span class="sd">    In case of a collision (= the same label would be inherited from `a` and `b`</span>
<span class="sd">    after the contraction), both labels are dropped.</span>

<span class="sd">    Detailed implementation notes are available in the doc-string of :func:`_tensordot_worker`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : :class:`Array`</span>
<span class="sd">        The first and second npc Array for which axes are to be contracted.</span>
<span class="sd">    axes : ``(axes_a, axes_b)`` | int</span>
<span class="sd">        A single integer is equivalent to ``(range(-axes, 0), range(axes))``.</span>
<span class="sd">        Alternatively, `axes_a` and `axes_b` specifiy the legs of `a` and `b`, respectively,</span>
<span class="sd">        which should be contracted. Legs can be specified with leg labels or indices.</span>
<span class="sd">        Contract leg ``axes_a[i]`` of `a` with leg ``axes_b[i]`` of `b`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a_dot_b : :class:`Array`</span>
<span class="sd">        The tensorproduct of `a` and `b`, summed over the specified axes.</span>
<span class="sd">        Returns a scalar in case of a full contraction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># for details on the implementation, see _tensordot_worker.</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">_tensordot_transpose_axes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

    <span class="c1"># optimize/check for special cases</span>
    <span class="n">no_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># result is zero</span>
    <span class="n">one_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="ow">and</span> <span class="n">axes</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_inner_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># full contraction yields a single number</span>
    <span class="k">elif</span> <span class="n">no_block</span> <span class="ow">or</span> <span class="n">one_block</span><span class="p">:</span>
        <span class="n">cut_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">-</span> <span class="n">axes</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[:</span><span class="n">cut_a</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axes</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[]),</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">qtotal</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">one_block</span><span class="p">:</span>
            <span class="c1"># optimize for special case that a and b have only 1 entry</span>
            <span class="c1"># this is (usually) the case if we have trivial charges</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cut_a</span><span class="p">:]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">axes</span><span class="p">]):</span>  <span class="c1"># blocks fit together</span>
                <span class="c1"># contract innner axes</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)]</span>
                <span class="n">c_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
                <span class="n">c_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">cut_a</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">cut_a</span><span class="p">]</span>
                <span class="n">c_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cut_a</span><span class="p">:]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">axes</span><span class="p">:]</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">c_qdata</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># else: zero</span>
    <span class="k">elif</span> <span class="n">axes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># no sum necessary</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># #### the main work</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_tensordot_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
    <span class="c1"># labels</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">_drop_duplicate_labels</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:</span><span class="o">-</span><span class="n">axes</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">axes</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.svd.html#tenpy.linalg.np_conserved.svd">[docs]</a><span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
        <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_uv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">qtotal_LR</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">inner_qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Singualar value decomposition of an Array `a`.</span>

<span class="sd">    Factorizes ``U, S, VH = svd(a)``, such that ``a = U*diag(S)*VH`` (where ``*`` stands for</span>
<span class="sd">    a :func:`tensordot` and `diag` creates an correctly shaped Array with `S` on the diagonal).</span>
<span class="sd">    For a non-zero `cutoff` this holds only approximately.</span>

<span class="sd">    There is a gauge freedom regarding the charges, see also :meth:`Array.gauge_total_charge`.</span>
<span class="sd">    We ensure contractibility by setting ``U.legs[1] = VH.legs[0].conj()``.</span>
<span class="sd">    Further, we gauge the LegCharge such that `U` and `V` have the desired `qtotal_LR`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`, shape ``(M, N)``</span>
<span class="sd">        The matrix to be decomposed.</span>
<span class="sd">    full_matrices : bool</span>
<span class="sd">        If ``False`` (default), `U` and `V` have shapes ``(M, K)`` and ``(K, N)``,</span>
<span class="sd">        where ``K=len(S)``.</span>
<span class="sd">        If ``True``, `U` and `V` are full square unitary matrices with shapes ``(M, M)`` and</span>
<span class="sd">        ``(N, N)``. Note that the arrays are not directly contractible in that case; ``diag(S)``</span>
<span class="sd">        would need to be a rectangluar ``(M, N)`` matrix.</span>
<span class="sd">    compute_uv : bool</span>
<span class="sd">        Whether to compute and return `U` and `V`.</span>
<span class="sd">    cutoff : ``None`` | float</span>
<span class="sd">        Keep only singular values which are (strictly) greater than `cutoff`.</span>
<span class="sd">        (Then the factorization holds only approximately).</span>
<span class="sd">        If ``None`` (default), ignored.</span>
<span class="sd">    qtotal_LR : [{charges|None}, {charges|None}]</span>
<span class="sd">        The desired `qtotal` for `U` and `VH`, respectively.</span>
<span class="sd">        ``[None, None]`` (Default) is equivalent to ``[None, a.qtotal]``.</span>
<span class="sd">        A single `None` entry is replaced the unique charge satisfying the requirement</span>
<span class="sd">        ``U.qtotal + VH.qtotal = a.qtotal (modulo qmod)``.</span>
<span class="sd">    inner_labels_LR: [{str|None}, {str|None}]</span>
<span class="sd">        The first label corresponds to ``U.legs[1]``, the second to ``VH.legs[0]``.</span>
<span class="sd">    inner_qconj : {+1, -1}</span>
<span class="sd">        Direction of the charges for the new leg. Default +1.</span>
<span class="sd">        The new LegCharge is constructed such that ``VH.legs[0].qconj = qconj``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    U : :class:`Array`</span>
<span class="sd">        Matrix with left singular vectors as columns.</span>
<span class="sd">        Shape ``(M, M)`` or ``(M, K)`` depending on `full_matrices`.</span>
<span class="sd">    S : 1D ndarray</span>
<span class="sd">        The singluar values of the array. If no `cutoff` is given, it has lenght ``min(M, N)``.</span>
<span class="sd">    VH : :class:`Array`</span>
<span class="sd">        Matrix with right singular vectors as rows.</span>
<span class="sd">        Shape ``(N, N)`` or ``(K, N)`` depending on `full_matrices`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check arguments</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SVD is only defined for a 2D matrix. Use LegPipes!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">full_matrices</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="n">compute_uv</span><span class="p">)</span> <span class="ow">or</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;What do you want? Check your goals!&quot;</span><span class="p">)</span>
    <span class="n">labL</span><span class="p">,</span> <span class="n">labR</span> <span class="o">=</span> <span class="n">inner_labels</span>
    <span class="n">a_labels</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_labels</span>
    <span class="c1"># ensure complete blocking</span>
    <span class="n">piped_axes</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>

    <span class="c1"># figure out qtotal_LR</span>
    <span class="n">qtotal_L</span><span class="p">,</span> <span class="n">qtotal_R</span> <span class="o">=</span> <span class="n">qtotal_LR</span>
    <span class="k">if</span> <span class="n">qtotal_L</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">qtotal_R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qtotal_R</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">qtotal</span>
    <span class="k">if</span> <span class="n">qtotal_L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qtotal_L</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">qtotal_R</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">qtotal_R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qtotal_R</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">qtotal_L</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal_L</span> <span class="o">+</span> <span class="n">qtotal_R</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The entries of `qtotal_LR` have to add up to ``a.qtotal``!&quot;</span><span class="p">)</span>
    <span class="n">qtotal_LR</span> <span class="o">=</span> <span class="n">qtotal_L</span><span class="p">,</span> <span class="n">qtotal_R</span>

    <span class="c1"># the main work</span>
    <span class="n">overwrite_a</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">piped_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VH</span> <span class="o">=</span> <span class="n">_svd_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">qtotal_LR</span><span class="p">,</span>
                           <span class="n">inner_qconj</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">compute_uv</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="c1"># &#39;split&#39; pipes introduced to ensure complete blocking</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">piped_axes</span><span class="p">:</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">piped_axes</span><span class="p">:</span>
        <span class="n">VH</span> <span class="o">=</span> <span class="n">VH</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">U</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">a_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">labL</span><span class="p">])</span>
    <span class="n">VH</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">labR</span><span class="p">,</span> <span class="n">a_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VH</span></div>


<div class="viewcode-block" id="pinv"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.pinv.html#tenpy.linalg.np_conserved.pinv">[docs]</a><span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the (Moore-Penrose) pseudo-inverse of a matrix.</span>

<span class="sd">    Equivalent to the following procedure: Perform a SVD, ``U, S, VH = svd(a, cutoff=cutoff)``</span>
<span class="sd">    with a `cutoff` &gt; 0, calculate ``P = U * diag(1/S) * VH``</span>
<span class="sd">    (with ``*`` denoting tensordot) and return ``P.conj.transpose()``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, N) :class:`Array`</span>
<span class="sd">        Matrix to be pseudo-inverted.</span>
<span class="sd">    cuttof : float</span>
<span class="sd">        Cutoff for small singular values, as given to :func:`svd`.</span>
<span class="sd">        (Note: different convetion than numpy.)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : (N, M) :class:`Array`</span>
<span class="sd">        The pseudo-inverse of `a`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid cutoff&quot;</span><span class="p">)</span>
    <span class="c1"># follow exactly the procedure lined out.</span>
    <span class="c1"># however, use inplace methods and don&#39;t construct the diagonal matrix explicitly.</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VH</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">VH</span><span class="o">.</span><span class="n">itranspose</span><span class="p">()</span><span class="o">.</span><span class="n">iconj</span><span class="p">()</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">itranspose</span><span class="p">()</span><span class="o">.</span><span class="n">iconj</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tensordot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.norm.html#tenpy.linalg.np_conserved.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convert_to_float</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Norm of flattened data.</span>

<span class="sd">    Equivalent to ``np.linalg.norm(a.to_ndarray().flatten(), ord)``.</span>

<span class="sd">    In contrast to numpy, we don&#39;t distinguish between matrices and vectors,</span>
<span class="sd">    but simply calculate the norm for the **flat** (block) data.</span>
<span class="sd">    The usual `ord`-norm is defined as  :math:`(\sum_i |a_i|^{ord} )^{1/ord}`.</span>

<span class="sd">    ==========  ======================================</span>
<span class="sd">    ord         norm</span>
<span class="sd">    ==========  ======================================</span>
<span class="sd">    None/&#39;fro&#39;  Frobenius norm (same as 2-norm)</span>
<span class="sd">    np.inf      ``max(abs(x))``</span>
<span class="sd">    -np.inf     ``min(abs(x))``</span>
<span class="sd">    0           ``sum(a != 0) == np.count_nonzero(x)``</span>
<span class="sd">    other       ususal `ord`-norm</span>
<span class="sd">    ==========  ======================================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array` | np.ndarray</span>
<span class="sd">        The array of which the norm should be calculated.</span>
<span class="sd">    ord :</span>
<span class="sd">        The order of the norm. See table above.</span>
<span class="sd">    convert_to_float :</span>
<span class="sd">        Convert integer to float before calculating the norm, avoiding int overflow.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    norm : float</span>
<span class="sd">        The norm over the *flat* data of the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">convert_to_float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">convert_to_float</span><span class="p">:</span>
            <span class="n">new_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>  <span class="c1"># int -&gt; float</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_type</span><span class="p">)</span>  <span class="c1"># doesn&#39;t copy, if the dtype did not change.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">)),</span> <span class="nb">ord</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown type of a&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.eigh.html#tenpy.linalg.np_conserved.eigh">[docs]</a><span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate eigenvalues and eigenvectors for a hermitian matrix.</span>

<span class="sd">    ``W, V = eigh(a)`` yields :math:`a = V diag(w) V^{\dagger}`.</span>
<span class="sd">    **Assumes** that a is hermitian, ``a.conj().transpose() == a``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        The hermitian square matrix to be diagonalized.</span>
<span class="sd">    UPLO : {&#39;L&#39;, &#39;U&#39;}</span>
<span class="sd">        Whether to take the lower (&#39;L&#39;, default) or upper (&#39;U&#39;) triangular part of `a`.</span>
<span class="sd">    sort : {&#39;m&gt;&#39;, &#39;m&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, ``None``}</span>
<span class="sd">        How the eigenvalues should are sorted *within* each charge block.</span>
<span class="sd">        Defaults to ``None``, which is same as &#39;&lt;&#39;. See :func:`argsort` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : 1D ndarray</span>
<span class="sd">        The eigenvalues, sorted within the same charge blocks according to `sort`.</span>
<span class="sd">    V : :class:`Array`</span>
<span class="sd">        Unitary matrix; ``V[:, i]`` is normalized eigenvector with eigenvalue ``W[i]``.</span>
<span class="sd">        The first label is inherited from `A`, the second label is ``&#39;eig&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Requires the legs to be contractible.</span>
<span class="sd">    If `a` is not blocked by charge, a blocked copy is made via a permutation ``P``,</span>
<span class="sd">    :math:` a&#39; =  P a P = V&#39; W&#39; (V&#39;)^{\dagger}`.</span>
<span class="sd">    The eigenvectors `V` are then obtained by the reverse permutation,</span>
<span class="sd">    :math:`V = P^{-1} V&#39;` such that `A = V W V^{\dagger}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_eig_worker</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">UPLO</span><span class="p">)</span>  <span class="c1"># hermitian</span>
    <span class="n">v</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;eig&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span></div>


<div class="viewcode-block" id="eig"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.eig.html#tenpy.linalg.np_conserved.eig">[docs]</a><span class="k">def</span> <span class="nf">eig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate eigenvalues and eigenvectors for a non-hermitian matrix.</span>

<span class="sd">    ``W, V = eig(a)`` yields :math:`a V = V diag(w)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        The hermitian square matrix to be diagonalized.</span>
<span class="sd">    sort : {&#39;m&gt;&#39;, &#39;m&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, ``None``}</span>
<span class="sd">        How the eigenvalues should are sorted *within* each charge block.</span>
<span class="sd">        Defaults to ``None``, which is same as &#39;&lt;&#39;. See :func:`argsort` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : 1D ndarray</span>
<span class="sd">        The eigenvalues, sorted within the same charge blocks according to `sort`.</span>
<span class="sd">    V : :class:`Array`</span>
<span class="sd">        Unitary matrix; ``V[:, i]`` is normalized eigenvector with eigenvalue ``W[i]``.</span>
<span class="sd">        The first label is inherited from `A`, the second label is ``&#39;eig&#39;``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Requires the legs to be contractible.</span>
<span class="sd">    If `a` is not blocked by charge, a blocked copy is made via a permutation ``P``,</span>
<span class="sd">    :math:` a&#39; =  P a P = V&#39; W&#39; (V&#39;)^{\dagger}`.</span>
<span class="sd">    The eigenvectors `V` are then obtained by the reverse permutation,</span>
<span class="sd">    :math:`V = P^{-1} V&#39;` such that `A = V W V^{\dagger}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">_eig_worker</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>  <span class="c1"># non-hermitian</span>
    <span class="n">v</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;eig&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span></div>


<div class="viewcode-block" id="eigvalsh"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.eigvalsh.html#tenpy.linalg.np_conserved.eigvalsh">[docs]</a><span class="k">def</span> <span class="nf">eigvalsh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate eigenvalues for a hermitian matrix.</span>

<span class="sd">    **Assumes** that a is hermitian, ``a.conj().transpose() == a``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        The hermitian square matrix to be diagonalized.</span>
<span class="sd">    UPLO : {&#39;L&#39;, &#39;U&#39;}</span>
<span class="sd">        Whether to take the lower (&#39;L&#39;, default) or upper (&#39;U&#39;) triangular part of `a`.</span>
<span class="sd">    sort : {&#39;m&gt;&#39;, &#39;m&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, ``None``}</span>
<span class="sd">        How the eigenvalues should are sorted *within* each charge block.</span>
<span class="sd">        Defaults to ``None``, which is same as &#39;&lt;&#39;. See :func:`argsort` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : 1D ndarray</span>
<span class="sd">        The eigenvalues, sorted within the same charge blocks according to `sort`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The eigenvalues are sorted within blocks of the completely blocked legs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_eigvals_worker</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">UPLO</span><span class="p">)</span></div>


<div class="viewcode-block" id="eigvals"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.eigvals.html#tenpy.linalg.np_conserved.eigvals">[docs]</a><span class="k">def</span> <span class="nf">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate eigenvalues for a hermitian matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        The hermitian square matrix to be diagonalized.</span>
<span class="sd">    sort : {&#39;m&gt;&#39;, &#39;m&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, ``None``}</span>
<span class="sd">        How the eigenvalues should are sorted *within* each charge block.</span>
<span class="sd">        Defaults to ``None``, which is same as &#39;&lt;&#39;. See :func:`argsort` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : 1D ndarray</span>
<span class="sd">        The eigenvalues, sorted within the same charge blocks according to `sort`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The eigenvalues are sorted within blocks of the completely blocked legs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_eigvals_worker</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span></div>


<div class="viewcode-block" id="speigs"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.speigs.html#tenpy.linalg.np_conserved.speigs">[docs]</a><span class="k">def</span> <span class="nf">speigs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">charge_sector</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sparse eigenvalue decomposition ``w, v`` of square `a` in a given charge sector.</span>

<span class="sd">    Finds `k` right eigenvectors (chosen by ``kwargs[&#39;which&#39;]``) in a given charge sector,</span>
<span class="sd">    ``tensordot(A, V[i], axes=1) = W[i] * V[i]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        A square array with contractible legs and vanishing total charge.</span>
<span class="sd">    charge_sector : charges</span>
<span class="sd">        `ndim` charges to select the block.</span>
<span class="sd">    k : int</span>
<span class="sd">        How many eigenvalues/vectors should be calculated.</span>
<span class="sd">        If the block of `charge_sector` is smaller than `k`, `k` may be reduced accordingly.</span>
<span class="sd">    *args, **kwargs :</span>
<span class="sd">        Additional arguments given to `scipy.sparse.linalg.eigs`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    W : ndarray</span>
<span class="sd">        `k` (or less) eigenvalues</span>
<span class="sd">    V : list of :class:`Array`</span>
<span class="sd">        `k` (or less) right eigenvectors of `A` with total charge `charge_sector`.</span>
<span class="sd">        Note that when interpreted as a matrix,</span>
<span class="sd">        this is the transpose of what ``np.eigs`` normally gives.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">charge_sector</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">charge_sector</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">qnumber</span><span class="p">,</span> <span class="p">))</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expect a square matrix!&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-trivial qtotal -&gt; Nilpotent. Not diagonizable!?&quot;</span><span class="p">)</span>
    <span class="n">ret_eigv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;return_eigenvectors&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">7</span> <span class="k">else</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">piped_axes</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>  <span class="c1"># ensure complete blocking</span>

    <span class="c1"># find the block correspoding to `charge_sector` in `a`</span>
    <span class="n">block_exists</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">qinds</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
        <span class="n">qi</span> <span class="o">=</span> <span class="n">qinds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">))</span> <span class="o">!=</span> <span class="n">charge_sector</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">block_exists</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># found the correct `block`</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_sp_speigs</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_eigv</span><span class="p">:</span>
            <span class="n">W</span><span class="p">,</span> <span class="n">V_flat</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">block_exists</span><span class="p">:</span>  <span class="c1"># block corresponding to charge_sector is zero</span>
        <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">block_number</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">))</span> <span class="o">==</span> <span class="n">charge_sector</span><span class="p">):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">slices</span>
                <span class="n">block_size</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="n">qi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sl</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;desired charge sector not present in the leg of `a`&quot;</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">V_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">block_size</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">V_flat</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># chose standard basis as eigenvectors</span>
    <span class="c1"># convert V_flat to npc Arrays and return</span>
    <span class="k">if</span> <span class="n">ret_eigv</span><span class="p">:</span>
        <span class="n">V</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="n">charge_sector</span><span class="p">)</span>
            <span class="n">U</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">V_flat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]]</span>
            <span class="n">U</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">qi</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">piped_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">W</span></div>


<div class="viewcode-block" id="expm"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.expm.html#tenpy.linalg.np_conserved.expm">[docs]</a><span class="k">def</span> <span class="nf">expm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use scipy.linalg.expm to calculate the matrix exponential of a square matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        A square matrix to be exponentiated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    exp_a : :class:`Array`</span>
<span class="sd">        The matrix exponential ``expm(a)``, calculated using scipy.linalg.expm.</span>
<span class="sd">        Same legs/labels as `a`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expect a square matrix!&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;A*A has different qtotal than A; nilpotent matrix&quot;</span><span class="p">)</span>
    <span class="n">piped_axes</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>  <span class="c1"># ensure complete blocking</span>

    <span class="n">res_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res_dtype</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_labels</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>  <span class="c1"># non-zero blocks on the diagonal</span>
        <span class="n">exp_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">block</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res_dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>  <span class="c1"># main work</span>
        <span class="n">qi</span> <span class="o">=</span> <span class="n">qindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># `res` has all diagonal blocks,</span>
        <span class="c1"># so res._qdata = [[0, 0], [1, 1], [2, 2]...]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp_block</span>  <span class="c1"># replace idendity block</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">piped_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="n">piped_axes</span><span class="p">)</span>  <span class="c1"># revert the permutation in the axes</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.qr.html#tenpy.linalg.np_conserved.qr">[docs]</a><span class="k">def</span> <span class="nf">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reduced&#39;</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Q-R decomposition of a matrix.</span>

<span class="sd">    Decomposition such that ``A == npc.tensordot(q, r, axes=1)`` up to numerical rounding errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : :class:`Array`</span>
<span class="sd">        A square matrix to be exponentiated, shape ``(M,N)``.</span>
<span class="sd">    mode : &#39;reduced&#39;, &#39;complete&#39;</span>
<span class="sd">        &#39;reduced&#39;: return `q` and `r` with shapes (M,K) and (K,N), where K=min(M,N)</span>
<span class="sd">        &#39;complete&#39;: return `q` with shape (M,M).</span>
<span class="sd">    inner_labels: [{str|None}, {str|None}]</span>
<span class="sd">        The first label is used for ``Q.legs[1]``, the second for ``R.legs[0]``.</span>
<span class="sd">    cutoff : ``None`` or float</span>
<span class="sd">        If not ``None``, discard linearly dependent vectors to given precision, which might</span>
<span class="sd">        reduce `K` of the &#39;reduced&#39; mode even further.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : :class:`Array`</span>
<span class="sd">        If `mode` is &#39;complete&#39;, a unitary matrix.</span>
<span class="sd">        For `mode` &#39;reduced&#39; such thatOtherwise such that</span>
<span class="sd">        :math:`q^{*}_{j,i} q_{j,k} = \delta_{i,k}`</span>
<span class="sd">    r : :class:`Array`</span>
<span class="sd">        Upper triangular matrix if both legs of A are sorted by charges;</span>
<span class="sd">        Otherwise a simple transposition (performed when sorting by charges) brings it to</span>
<span class="sd">        upper triangular form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expect a matrix!&quot;</span><span class="p">)</span>
    <span class="n">a_labels</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_labels</span>
    <span class="n">label_Q</span><span class="p">,</span> <span class="n">label_R</span> <span class="o">=</span> <span class="n">inner_labels</span>
    <span class="n">piped_axes</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>  <span class="c1"># ensure complete blocking &amp; sort</span>
    <span class="n">q_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">r_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">a_leg0</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">inner_leg_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a_leg0</span><span class="o">.</span><span class="n">ind_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>  <span class="c1"># non-zero blocks on the diagonal</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q_block</span><span class="p">,</span> <span class="n">r_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q_block</span><span class="p">,</span> <span class="n">r_block</span> <span class="o">=</span> <span class="n">qr_li</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">q_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q_block</span><span class="p">)</span>
        <span class="n">r_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_block</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complete&#39;</span><span class="p">:</span>
            <span class="n">q1</span><span class="p">,</span> <span class="n">q2</span> <span class="o">=</span> <span class="n">qindices</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">a_leg0</span><span class="o">.</span><span class="n">slices</span><span class="p">[</span><span class="n">q1</span><span class="p">]</span>
            <span class="n">inner_leg_mask</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i0</span> <span class="o">+</span> <span class="n">q_block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complete&#39;</span><span class="p">:</span>
        <span class="c1"># map qindices</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">map_qind</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">inner_leg</span> <span class="o">=</span> <span class="n">a_leg0</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">inner_leg_mask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inner_leg</span> <span class="o">=</span> <span class="n">a_leg0</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">a_leg0</span><span class="p">,</span> <span class="n">inner_leg</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">q_data</span>
    <span class="n">q</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">inner_leg</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">r_data</span>
    <span class="n">r</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">r</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complete&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_qind</span><span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># copy map_qind[q._qdata[:, 0]] from q</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">piped_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># revert the permutation in the axes</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">piped_axes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complete&#39;</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">piped_axes</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">a_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label_Q</span><span class="p">])</span>
    <span class="n">r</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">label_R</span><span class="p">,</span> <span class="n">a_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span></div>


<div class="viewcode-block" id="to_iterable_arrays"><a class="viewcode-back" href="../../../reference/tenpy.linalg.np_conserved.to_iterable_arrays.html#tenpy.linalg.np_conserved.to_iterable_arrays">[docs]</a><span class="k">def</span> <span class="nf">to_iterable_arrays</span><span class="p">(</span><span class="n">array_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar as :func:`~tenpy.tools.misc.to_iterable`, but also enclose npc Arrays in a list.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
        <span class="n">array_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">array_list</span><span class="p">]</span>
    <span class="n">array_list</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array_list</span></div>


<span class="c1"># ##################################</span>
<span class="c1"># internal helper functions</span>
<span class="c1"># ##################################</span>


<span class="k">def</span> <span class="nf">_find_calc_dtype</span><span class="p">(</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">b_dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;return (calc_dtype, res_dtype) suitable for BLAS calculations.&quot;&quot;&quot;</span>
    <span class="n">res_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">a_dtype</span><span class="p">,</span> <span class="n">b_dtype</span><span class="p">],</span> <span class="p">[])</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">calc_dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">BLAS</span><span class="o">.</span><span class="n">find_best_blas_type</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">res_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">calc_dtype</span><span class="p">,</span> <span class="n">res_dtype</span>


<span class="nd">@use_cython</span>
<span class="k">def</span> <span class="nf">_combine_legs_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">,</span> <span class="n">non_combined_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="p">,</span> <span class="n">non_new_axes</span><span class="p">,</span>
                         <span class="n">pipes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The main work of :meth:`Array.combine_legs`: create a copy and reshape the data blocks.</span>

<span class="sd">    Assumes standard form of parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : Array</span>
<span class="sd">        The array from where legs are being combined.</span>
<span class="sd">    res : Array</span>
<span class="sd">        The array to be returned, already filled with correct legs (pipes);</span>
<span class="sd">        needs `_data` and `_qdata` to be filled.</span>
<span class="sd">        Labels are set outside.</span>
<span class="sd">    combine_legs : list(1D np.array)</span>
<span class="sd">        Axes of self which are collected into pipes.</span>
<span class="sd">    non_combined_legs : 1D array</span>
<span class="sd">        ``[i for i in range(self.rank) if i not in flatten(combine_legs)]``</span>
<span class="sd">    new_axes : 1D array</span>
<span class="sd">        The axes of the pipes in the new array. Ascending.</span>
<span class="sd">    non_new_axes 1D array</span>
<span class="sd">        ``[i for i in range(res.rank) if i not in new_axes]``</span>
<span class="sd">    pipes : list of :class:`LegPipe`</span>
<span class="sd">        All the correct output pipes, already generated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># non_combined_legs: axes of self which are not in combine_legs</span>
    <span class="c1"># map `self._qdata[:, combine_leg]` to `pipe.q_map` indices for each new pipe</span>
    <span class="n">q_map_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">_map_incoming_qind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">cl</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">combine_legs</span><span class="p">)]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_imake_contiguous</span><span class="p">()</span>
    <span class="c1"># get new qdata</span>
    <span class="n">qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">qdata</span><span class="p">[:,</span> <span class="n">non_new_axes</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">non_combined_legs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pipes</span><span class="p">)):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">new_axes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">qdata</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">q_map</span><span class="p">[</span><span class="n">q_map_inds</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># now we have probably many duplicate rows in qdata,</span>
    <span class="c1"># since for the pipes many `q_map_ind` map to the same `qindex`</span>
    <span class="c1"># find unique entries by sorting qdata</span>
    <span class="n">sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">qdata</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">qdata</span> <span class="o">=</span> <span class="n">qdata</span><span class="p">[</span><span class="n">sort</span><span class="p">]</span>
    <span class="n">old_data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sort</span><span class="p">]</span>
    <span class="n">q_map_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">qm</span><span class="p">[</span><span class="n">sort</span><span class="p">]</span> <span class="k">for</span> <span class="n">qm</span> <span class="ow">in</span> <span class="n">q_map_inds</span><span class="p">]</span>
    <span class="n">block_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">block_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">block_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">leg</span><span class="o">.</span><span class="n">_get_block_sizes</span><span class="p">()</span> <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">non_new_axes</span><span class="p">:</span>
        <span class="n">block_shape</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sizes</span><span class="p">[</span><span class="n">ax</span><span class="p">][</span><span class="n">qdata</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pipes</span><span class="p">)):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">new_axes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">pipes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">q_map</span><span class="p">[</span><span class="n">q_map_inds</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">block_start</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">block_shape</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sizes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># TODO size directly in pipe!?</span>

    <span class="c1"># divide qdata into parts, which give a single new block</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_find_row_differences</span><span class="p">(</span><span class="n">qdata</span><span class="p">)</span>  <span class="c1"># including the first and last row</span>
    <span class="n">res_stored_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">qdata</span> <span class="o">=</span> <span class="n">qdata</span><span class="p">[</span><span class="n">diffs</span><span class="p">[:</span><span class="n">res_stored_blocks</span><span class="p">],</span> <span class="p">:]</span>  <span class="c1"># (keeps the dimensions)</span>
    <span class="n">res_blockshapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">res_stored_blocks</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">):</span>
        <span class="n">res_blockshapes</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sizes</span><span class="p">[</span><span class="n">ax</span><span class="p">][</span><span class="n">qdata</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]]</span>

    <span class="c1"># now the hard part: map data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># iterate over ranges of equal qindices in qdata</span>
    <span class="k">for</span> <span class="n">res_blockshape</span><span class="p">,</span> <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">res_blockshapes</span><span class="p">,</span> <span class="n">diffs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">new_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res_blockshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_block</span><span class="p">)</span>
        <span class="c1"># copy blocks</span>
        <span class="k">for</span> <span class="n">old_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">block_shape</span><span class="p">[</span><span class="n">old_row</span><span class="p">]</span>
            <span class="n">old_block</span> <span class="o">=</span> <span class="n">old_data</span><span class="p">[</span><span class="n">old_row</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">charges</span><span class="o">.</span><span class="n">_sliced_copy</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="n">block_start</span><span class="p">[</span><span class="n">old_row</span><span class="p">],</span> <span class="n">old_block</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">qdata</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># done</span>


<span class="nd">@use_cython</span>
<span class="k">def</span> <span class="nf">_split_legs_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_axes</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The main work of split_legs: create a copy and reshape the data blocks.</span>

<span class="sd">    Called by :meth:`split_legs`. Assumes that the corresponding legs are LegPipes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate mappings of axes</span>
    <span class="n">new_split_axes_first</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nonsplit_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_nonsplit_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pipes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_legs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[:]</span>
    <span class="n">new_axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">split_axes</span><span class="p">:</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">pipes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
            <span class="n">res_legs</span><span class="p">[</span><span class="n">new_axis</span><span class="p">:</span><span class="n">new_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">legs</span>
            <span class="n">new_split_axes_first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_axis</span><span class="p">)</span>
            <span class="n">new_axis</span> <span class="o">+=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">nlegs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nonsplit_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">new_nonsplit_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_axis</span><span class="p">)</span>
            <span class="n">new_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">split_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">split_axes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">N_split</span> <span class="o">=</span> <span class="n">split_axes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">new_split_axes_first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_split_axes_first</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">nonsplit_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonsplit_axes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">new_nonsplit_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_nonsplit_axes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="n">res_legs</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_set_shape</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># get new qdata</span>
    <span class="n">q_map_slices_beg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">,</span> <span class="n">N_split</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">q_map_slices_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">stored_blocks</span><span class="p">,</span> <span class="n">N_split</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_split</span><span class="p">):</span>
        <span class="n">pipe</span> <span class="o">=</span> <span class="n">pipes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">q_map_slices</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">q_map_slices</span>
        <span class="n">qinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">split_axes</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="n">q_map_slices_beg</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_map_slices</span><span class="p">[</span><span class="n">qinds</span><span class="p">]</span>
        <span class="n">q_map_slices_shape</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_map_slices</span><span class="p">[</span>
            <span class="n">qinds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># - q_map_slices[qinds] # one line below # TODO: in pipe</span>
    <span class="n">q_map_slices_shape</span> <span class="o">-=</span> <span class="n">q_map_slices_beg</span>
    <span class="n">new_data_blocks_per_old_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">q_map_slices_shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">old_block_inds</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_map_blocks</span><span class="p">(</span><span class="n">new_data_blocks_per_old_block</span><span class="p">)</span>
    <span class="n">res_stored_blocks</span> <span class="o">=</span> <span class="n">old_block_inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">q_map_rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">beg</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">q_map_slices_beg</span><span class="p">,</span> <span class="n">q_map_slices_shape</span><span class="p">):</span>
        <span class="n">q_map_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N_split</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">beg</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">q_map_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">q_map_rows</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shape (res_stored_blocks, N_split)</span>

    <span class="n">new_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">res_stored_blocks</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">new_qdata</span><span class="p">[:,</span> <span class="n">new_nonsplit_axes</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span>
        <span class="n">old_block_inds</span><span class="p">,</span> <span class="n">nonsplit_axes</span><span class="p">)]</span>  <span class="c1"># TODO faster to implement by hand?</span>
    <span class="n">old_block_beg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">res_stored_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">old_block_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">res_stored_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_split</span><span class="p">):</span>
        <span class="n">pipe</span> <span class="o">=</span> <span class="n">pipes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">new_split_axes_first</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">pipe</span><span class="o">.</span><span class="n">nlegs</span>
        <span class="n">q_map</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">q_map</span><span class="p">[</span><span class="n">q_map_rows</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">new_qdata</span><span class="p">[:,</span> <span class="n">a</span><span class="p">:</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_map</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
        <span class="n">old_block_beg</span><span class="p">[:,</span> <span class="n">split_axes</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">q_map</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">old_block_shapes</span><span class="p">[:,</span> <span class="n">split_axes</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">q_map</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">q_map</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">new_block_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">res_stored_blocks</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">block_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">leg</span><span class="o">.</span><span class="n">_get_block_sizes</span><span class="p">()</span> <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">legs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">rank</span><span class="p">):</span>
        <span class="n">new_block_shapes</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sizes</span><span class="p">[</span><span class="n">ax</span><span class="p">][</span><span class="n">new_qdata</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]]</span>
    <span class="n">old_block_shapes</span><span class="p">[:,</span> <span class="n">nonsplit_axes</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_block_shapes</span><span class="p">[:,</span> <span class="n">new_nonsplit_axes</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">old_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="c1"># the actual loop to split the blocks</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">res_stored_blocks</span><span class="p">):</span>
        <span class="n">old_block</span> <span class="o">=</span> <span class="n">old_data</span><span class="p">[</span><span class="n">old_block_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">new_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">old_block_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">charges</span><span class="o">.</span><span class="n">_sliced_copy</span><span class="p">(</span><span class="n">new_block</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">old_block</span><span class="p">,</span> <span class="n">old_block_beg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">old_block_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_block</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_block_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">new_qdata</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_nontrivial_grid_entries</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list [(idx, entry)] of non-``None`` entries in an array_like grid.&quot;&quot;&quot;</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No non-trivial entries in grid&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">entries</span>


<span class="k">def</span> <span class="nf">_grid_concat_recursion</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple recursion on ndim for grid_concat.&quot;&quot;&quot;</span>
    <span class="c1"># Copy only required on last go</span>
    <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">_grid_concat_recursion</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>


<span class="c1"># (in cython, but with different arguments)</span>
<span class="k">def</span> <span class="nf">_iter_common_sorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Yield indices ``i, j`` for which ``a[i] == b[j]``.</span>

<span class="sd">    *Assumes* that ``a[i_start:i_stop]`` and ``b[j_start:j_stop]`` are strictly ascending.</span>
<span class="sd">    Given that, it is equivalent to (but faster than)</span>
<span class="sd">    ``[(i, j) for j, i in itertools.product(range(len(a)), range(len(b)) if a[i] == b[j]]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">l_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l_a</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">l_b</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="nd">@use_cython</span>
<span class="k">def</span> <span class="nf">_inner_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">do_conj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Full contraction of `a` and `b` with axes in matching order.&quot;&quot;&quot;</span>
    <span class="n">calc_dtype</span><span class="p">,</span> <span class="n">res_dtype</span> <span class="o">=</span> <span class="n">_find_calc_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">check_qtotal</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="k">if</span> <span class="n">do_conj</span> <span class="k">else</span> <span class="n">b</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">qtotal</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">check_qtotal</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">res</span>  <span class="c1"># can&#39;t have blocks to be contracted.</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>  <span class="c1"># also trivial</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">calc_dtype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">calc_dtype</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="s1">&#39;dotc&#39;</span> <span class="k">if</span> <span class="n">do_conj</span> <span class="k">else</span> <span class="s1">&#39;dotu&#39;</span>
    <span class="n">blas_dot</span> <span class="o">=</span> <span class="n">BLAS</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">calc_dtype</span><span class="p">)</span>

    <span class="c1"># need to find common blocks in a and b, i.e. equal leg charges.</span>
    <span class="c1"># for faster comparison, generate 1D arrays with a combined index</span>
    <span class="c1"># F-style strides to preserve sorting!</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_make_stride</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">block_number</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">a_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">a_data</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata_sorted</span><span class="p">:</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a_qdata</span><span class="p">)</span>
        <span class="n">a_qdata</span> <span class="o">=</span> <span class="n">a_qdata</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
        <span class="n">a_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
    <span class="n">b_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b_data</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata_sorted</span><span class="p">:</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">b_qdata</span><span class="p">)</span>
        <span class="n">b_qdata</span> <span class="o">=</span> <span class="n">b_qdata</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span>
        <span class="n">b_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">_iter_common_sorted</span><span class="p">(</span><span class="n">a_qdata</span><span class="p">,</span> <span class="n">b_qdata</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">blas_dot</span><span class="p">(</span><span class="n">a_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b_data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="c1"># same as res += np.inner(a_data[i].reshape((-1, )), b_data[j].reshape((-1, )))</span>
        <span class="c1"># (or with complex conj if &#39;do_conj&#39;)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_drop_duplicate_labels</span><span class="p">(</span><span class="n">a_labels</span><span class="p">,</span> <span class="n">b_labels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine lists `a_labels` and `b_labels` into a new list, dropping any duplicates.&quot;&quot;&quot;</span>
    <span class="n">a_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a_labels</span><span class="p">)</span>
    <span class="n">b_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">b_labels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_labels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">b_labels</span><span class="p">:</span>
            <span class="c1"># collision: drop labels</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">b_labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
            <span class="n">a_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">b_labels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">a_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b_labels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_labels</span>


<span class="nd">@use_cython</span>
<span class="k">def</span> <span class="nf">_tensordot_transpose_axes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Step 1: Transpose a,b if necessary.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Different ChargeInfo&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axes_a</span><span class="p">,</span> <span class="n">axes_b</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="n">axes_int</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">axes_int</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">axes_int</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># shallow copy allows to call itranspose</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># which would otherwise break views.</span>
        <span class="c1"># step 1.) of the implementation notes: bring into standard form by transposing</span>
        <span class="n">axes_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes_a</span><span class="p">))</span>
        <span class="n">axes_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">get_leg_indices</span><span class="p">(</span><span class="n">to_iterable</span><span class="p">(</span><span class="n">axes_b</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;different lens of axes for a, b: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">not_axes_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_a</span><span class="p">]</span>
        <span class="n">not_axes_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_b</span><span class="p">]</span>
        <span class="n">a</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">not_axes_a</span> <span class="o">+</span> <span class="n">axes_a</span><span class="p">)</span>
        <span class="n">b</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">axes_b</span> <span class="o">+</span> <span class="n">not_axes_b</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span>

    <span class="c1"># now `axes` is integer</span>
    <span class="c1"># check for contraction compatibility</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize</span><span class="p">(</span><span class="n">OptimizationFlag</span><span class="o">.</span><span class="n">skip_arg_checks</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lega</span><span class="p">,</span> <span class="n">legb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="o">-</span><span class="n">axes</span><span class="p">:],</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">[:</span><span class="n">axes</span><span class="p">]):</span>
            <span class="n">lega</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">legb</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">axes</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axes</span><span class="p">]:</span>  <span class="c1"># check at least the shape</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape mismatch for tensordot&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span>


<span class="k">def</span> <span class="nf">_tensordot_pre_reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">same_shape_before_cut</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reshape blocks to (fortran) matrix/vector (depending on `cut`)&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cut</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cut</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="c1"># special case: reshape to 1D vectors</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">same_shape_before_cut</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">cut</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">cut</span><span class="p">:]:</span>
                <span class="n">p</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_tensordot_pre_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cut_a</span><span class="p">,</span> <span class="n">cut_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pre-calculations before the actual matrix procut.</span>

<span class="sd">    Called by :func:`_tensordot_worker`.</span>
<span class="sd">    See doc-string of :func:`tensordot` for details on the implementation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : :class:`Array`</span>
<span class="sd">        the arrays to be contracted with tensordot. Should have non-empty ``a._data``</span>
<span class="sd">    cut_a, cut_b : int</span>
<span class="sd">        contract `a.legs[cut_a:]` with `b.legs[:cut_b]`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a_pre_result, b_pre_result : tuple</span>
<span class="sd">        In the following order, it contains for `a`, and `b` respectively:</span>
<span class="sd">        a_data : list of reshaped tensors</span>
<span class="sd">        a_qdata_contr : 2D array with qindices of `a` which we need to sum over</span>
<span class="sd">        a_qdata_keep : 2D array of the qindices of `a` which will appear in the final result</span>
<span class="sd">        a_slices : partition to map the indices of a_*_keep to a_data</span>
<span class="sd">    f_dot_sum : function</span>
<span class="sd">        a wrapper around a suitable BLAS function for perfoming the matrix product</span>
<span class="sd">        of single blocks sum over the results.</span>
<span class="sd">        For ``a, a2, ...`` from ``a_data`` (and similar for ``b_data``) the code</span>
<span class="sd">        ``s = f_dot_sum(a, b, None); s = f_dot_sum(a2, b2, s); ....``</span>
<span class="sd">        should be equivalent to (yet faster than)</span>
<span class="sd">        ``s = np.dot(a, b); s += np.dot(a2, b2); ... ``.</span>
<span class="sd">    res_dtype : np.dtype</span>
<span class="sd">        The data type which should be chosed for the result.</span>
<span class="sd">        (The `dtype` of the ``s`` above might differ from `res_dtype`!).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert qindices over which we sum to a 1D array for faster lookup/iteration</span>
    <span class="c1"># F-style strides to preserve sorting</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_make_stride</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">block_number</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">cut_a</span><span class="p">:]],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">a_qdata_contr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">cut_a</span><span class="p">:]</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># lex-sort a_qdata, dominated by the axes kept, then the axes summed over.</span>
    <span class="n">a_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_qdata_contr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="p">:</span><span class="n">cut_a</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">a_qdata_keep</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">a_sort</span><span class="p">,</span> <span class="p">:</span><span class="n">cut_a</span><span class="p">]</span>
    <span class="n">a_qdata_contr</span> <span class="o">=</span> <span class="n">a_qdata_contr</span><span class="p">[</span><span class="n">a_sort</span><span class="p">]</span>
    <span class="n">a_data</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span>
    <span class="n">a_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a_sort</span><span class="p">]</span>
    <span class="c1"># combine all b_qdata[axes_b] into one column (with the same stride as before)</span>
    <span class="n">b_qdata_contr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="p">:</span><span class="n">cut_b</span><span class="p">]</span> <span class="o">*</span> <span class="n">stride</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># lex-sort b_qdata, dominated by the axes summed over, then the axes kept.</span>
    <span class="n">b_data</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata_sorted</span><span class="p">:</span>
        <span class="n">b_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_qdata_contr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">cut_b</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">b_qdata_keep</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">b_sort</span><span class="p">,</span> <span class="n">cut_b</span><span class="p">:]</span>
        <span class="n">b_qdata_contr</span> <span class="o">=</span> <span class="n">b_qdata_contr</span><span class="p">[</span><span class="n">b_sort</span><span class="p">]</span>
        <span class="n">b_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b_sort</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b_qdata_keep</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[:,</span> <span class="n">cut_b</span><span class="p">:]</span>
    <span class="c1"># find blocks where qdata_a[not_axes_a] and qdata_b[not_axes_b] change</span>
    <span class="n">a_slices</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_find_row_differences</span><span class="p">(</span><span class="n">a_qdata_keep</span><span class="p">)</span>
    <span class="n">b_slices</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_find_row_differences</span><span class="p">(</span><span class="n">b_qdata_keep</span><span class="p">)</span>
    <span class="c1"># the slices divide a_data and b_data into rows and columns of the final result</span>
    <span class="n">a_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
    <span class="n">b_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_data</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j2</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b_slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
    <span class="n">a_qdata_contr</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_qdata_contr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
    <span class="n">b_qdata_contr</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_qdata_contr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">b_slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">b_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
    <span class="n">a_qdata_keep</span> <span class="o">=</span> <span class="n">a_qdata_keep</span><span class="p">[</span><span class="n">a_slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">b_qdata_keep</span> <span class="o">=</span> <span class="n">b_qdata_keep</span><span class="p">[</span><span class="n">b_slices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">a_shape_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">cut_a</span><span class="p">]</span> <span class="k">for</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">a_data</span><span class="p">]</span>
    <span class="n">b_shape_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">cut_b</span><span class="p">:]</span> <span class="k">for</span> <span class="n">blocks</span> <span class="ow">in</span> <span class="n">b_data</span><span class="p">]</span>
    <span class="c1"># determine calculation type and result type</span>
    <span class="n">calc_dtype</span><span class="p">,</span> <span class="n">res_dtype</span> <span class="o">=</span> <span class="n">_find_calc_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># reshape a_data and b_data to matrix/vector in fortran order</span>
    <span class="n">a_data</span> <span class="o">=</span> <span class="n">_tensordot_pre_reshape</span><span class="p">(</span><span class="n">a_data</span><span class="p">,</span> <span class="n">cut_a</span><span class="p">,</span> <span class="n">calc_dtype</span><span class="p">,</span> <span class="n">same_shape_before_cut</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b_data</span> <span class="o">=</span> <span class="n">_tensordot_pre_reshape</span><span class="p">(</span><span class="n">b_data</span><span class="p">,</span> <span class="n">cut_b</span><span class="p">,</span> <span class="n">calc_dtype</span><span class="p">,</span> <span class="n">same_shape_before_cut</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># determine blas function</span>
    <span class="n">f_name</span> <span class="o">=</span> <span class="s1">&#39;gemv&#39;</span> <span class="k">if</span> <span class="p">(</span><span class="n">cut_a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">cut_b</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;gemm&#39;</span>
    <span class="n">blas_dot</span> <span class="o">=</span> <span class="n">BLAS</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">calc_dtype</span><span class="p">)</span>
    <span class="n">kw_overwrite</span> <span class="o">=</span> <span class="s1">&#39;overwrite_c&#39;</span> <span class="k">if</span> <span class="n">f_name</span> <span class="o">==</span> <span class="s1">&#39;gemm&#39;</span> <span class="k">else</span> <span class="s1">&#39;overwrite_y&#39;</span>
    <span class="n">kw_overwrite</span> <span class="o">=</span> <span class="p">{</span><span class="n">kw_overwrite</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">cut_a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">fast_dot_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a_qdata</span><span class="p">,</span> <span class="n">b_qdata</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;BLAS wrapper to perform contraction in a fast way.</span>

<span class="sd">            Equivalent to::</span>
<span class="sd">                np.sum([np.dot(a[k1], b[k2])</span>
<span class="sd">                    for k1, k2 in _iter_common_sorted(a_qdata, b_qdata)], axis=0)</span>

<span class="sd">            Returns ``None`` if no ``(k1, k2)`` pair existed.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="n">_iter_common_sorted</span><span class="p">(</span><span class="n">a_qdata</span><span class="p">,</span> <span class="n">b_qdata</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sum_</span> <span class="o">=</span> <span class="n">blas_dot</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">k2</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">sum_</span> <span class="o">=</span> <span class="n">blas_dot</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">k2</span><span class="p">],</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">sum_</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_overwrite</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sum_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># special case: `a` contains 1D vectors, so we need blas_dot(b, a, trans=True)</span>
        <span class="n">kw_no_overwrite</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;trans&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="n">kw_overwrite</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw_no_overwrite</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">fast_dot_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a_qdata</span><span class="p">,</span> <span class="n">b_qdata</span><span class="p">):</span>
            <span class="c1"># same as above fast_dot_sum, but for special case that a contains vectors</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="n">_iter_common_sorted</span><span class="p">(</span><span class="n">a_qdata</span><span class="p">,</span> <span class="n">b_qdata</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sum_</span> <span class="o">=</span> <span class="n">blas_dot</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">k2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="o">**</span><span class="n">kw_no_overwrite</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">sum_</span> <span class="o">=</span> <span class="n">blas_dot</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">k2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">sum_</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_overwrite</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sum_</span>

    <span class="c1"># collect and return the results</span>
    <span class="n">a_pre_result</span> <span class="o">=</span> <span class="n">a_data</span><span class="p">,</span> <span class="n">a_qdata_contr</span><span class="p">,</span> <span class="n">a_qdata_keep</span><span class="p">,</span> <span class="n">a_shape_keep</span>
    <span class="n">b_pre_result</span> <span class="o">=</span> <span class="n">b_data</span><span class="p">,</span> <span class="n">b_qdata_contr</span><span class="p">,</span> <span class="n">b_qdata_keep</span><span class="p">,</span> <span class="n">b_shape_keep</span>
    <span class="k">return</span> <span class="n">a_pre_result</span><span class="p">,</span> <span class="n">b_pre_result</span><span class="p">,</span> <span class="n">fast_dot_sum</span><span class="p">,</span> <span class="n">res_dtype</span>


<span class="nd">@use_cython</span>
<span class="k">def</span> <span class="nf">_tensordot_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main work of tensordot, called by :func:`tensordot`.</span>

<span class="sd">    Assumes standard form of parameters: axes is integer,</span>
<span class="sd">    sum over the last `axes` legs of `a` and first `axes` legs of `b`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Looking at the source of numpy&#39;s tensordot (which is just 62 lines of python code),</span>
<span class="sd">    you will find that it has the following strategy:</span>

<span class="sd">    1. Transpose `a` and `b` such that the axes to sum over are in the end of `a` and front of `b`.</span>
<span class="sd">    2. Combine the legs `axes`-legs and other legs with a `np.reshape`,</span>
<span class="sd">       such that `a` and `b` are matrices.</span>
<span class="sd">    3. Perform a matrix product with `np.dot`.</span>
<span class="sd">    4. Split the remaining axes with another `np.reshape` to obtain the correct shape.</span>

<span class="sd">    The main work is done by `np.dot`, which calls LAPACK to perform the simple matrix product.</span>
<span class="sd">    [This matrix multiplication of a ``NxK`` times ``KxM`` matrix is actually faster</span>
<span class="sd">    than the O(N*K*M) needed by a naive implementation looping over the indices.]</span>

<span class="sd">    We follow the same overall strategy, viewing the :class:`Array` as a tensor with</span>
<span class="sd">    data block entries.</span>
<span class="sd">    Step 1) is performed directly in :func:`tensordot`.</span>

<span class="sd">    The steps 2) and 4) could be implemented with :meth:`Array.combine_legs`</span>
<span class="sd">    and :meth:`Array.split_legs`.</span>
<span class="sd">    However, that would actually be an overkill: we&#39;re not interested</span>
<span class="sd">    in the full charge data of the combined legs (which would be generated in the LegPipes).</span>
<span class="sd">    Instead, we just need to track the qindices of the `a._qdata` and `b._qdata` carefully.</span>

<span class="sd">    Our step 2) is implemented in :func:`_tensordot_pre_worker`:</span>
<span class="sd">    We split `a._qdata` in `a_qdata_keep` and `a_qdata_sum`, and similar for `b`.</span>
<span class="sd">    Then, view `a` is a matrix :math:`A_{i,k1}` and `b` as :math:`B_{k2,j}`, where</span>
<span class="sd">    `i` can be any row of `a_qdata_keep`, `j` can be any row of `b_qdata_keep`.</span>
<span class="sd">    The `k1` and `k2` are rows of `a_qdata_sum` and `b_qdata_sum`, which stem from the same legs</span>
<span class="sd">    (up to a :meth:`LegCharge.conj()`).</span>
<span class="sd">    In our storage scheme, `a._data[s]` then contains the block :math:`A_{i,k1}` for</span>
<span class="sd">    ``j = a_qdata_keep[s]`` and ``k1 = a_qdata_sum[s]``.</span>
<span class="sd">    To identify the different indices `i` and `j`, it is easiest to lexsort in the `s`.</span>
<span class="sd">    Note that we give priority to the `#_qdata_keep` over the `#_qdata_sum`, such that</span>
<span class="sd">    equal rows of `i` are contiguous in `#_qdata_keep`.</span>
<span class="sd">    Then, they are identified with :func:`charges._find_row_differences`.</span>

<span class="sd">    Now, the goal is to calculate the sums :math:`C_{i,j} = sum_k A_{i,k} B_{k,j}`,</span>
<span class="sd">    analogous to step 3) above. This is implemented in :func:`_tensordot_worker`.</span>
<span class="sd">    It is done &#39;naively&#39; by explicit loops over ``i``, ``j`` and ``k``.</span>
<span class="sd">    However, this is not as bad as it sounds:</span>
<span class="sd">    First, we loop only over existent ``i`` and ``j``</span>
<span class="sd">    (in the sense that there is at least some non-zero block with these ``i`` and ``j``).</span>
<span class="sd">    Second, if the ``i`` and ``j`` are not compatible with the new total charge,</span>
<span class="sd">    we know that ``C_{i,j}`` will be zero.</span>
<span class="sd">    Third, given ``i`` and ``j``, the sum over ``k`` runs only over</span>
<span class="sd">    ``k1`` with nonzero :math:`A_{i,k1}`, and ``k2` with nonzero :math:`B_{k2,j}`.</span>

<span class="sd">    How many multiplications :math:`A_{i,k} B_{k,j}` we actually have to perform</span>
<span class="sd">    depends on the sparseness. In the ideal case, if ``k`` (i.e. a LegPipe of the legs summed over)</span>
<span class="sd">    is completely blocked by charge, the &#39;sum&#39; over ``k`` will contain at most one term!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chinfo</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">stored_blocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># special case: `a` or `b` is 0</span>
        <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[:</span><span class="o">-</span><span class="n">axes</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">axes</span><span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[]),</span>
                     <span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
    <span class="n">cut_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">-</span> <span class="n">axes</span>
    <span class="n">cut_b</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="n">a_pre_result</span><span class="p">,</span> <span class="n">b_pre_result</span><span class="p">,</span> <span class="n">fast_dot_sum</span><span class="p">,</span> <span class="n">res_dtype</span> <span class="o">=</span> <span class="n">_tensordot_pre_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cut_a</span><span class="p">,</span> <span class="n">cut_b</span><span class="p">)</span>
    <span class="n">a_data</span><span class="p">,</span> <span class="n">a_qdata_contr</span><span class="p">,</span> <span class="n">a_qdata_keep</span><span class="p">,</span> <span class="n">a_shape_keep</span> <span class="o">=</span> <span class="n">a_pre_result</span>
    <span class="n">b_data</span><span class="p">,</span> <span class="n">b_qdata_contr</span><span class="p">,</span> <span class="n">b_qdata_keep</span><span class="p">,</span> <span class="n">b_shape_keep</span> <span class="o">=</span> <span class="n">b_pre_result</span>

    <span class="c1"># Step 3) loop over column/row of the result</span>

    <span class="c1"># first find output colum/row indices of the result, which are compatible with the charges</span>
    <span class="n">qtotal</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">qtotal</span><span class="p">)</span>
    <span class="n">a_charges_keep</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_partial_qtotal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[:</span><span class="n">cut_a</span><span class="p">],</span> <span class="n">a_qdata_keep</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># fast way to matb_charges_keep, ch the find the compatible indices</span>
    <span class="n">a_lookup_charges</span> <span class="o">=</span> <span class="n">list_to_dict_list</span><span class="p">(</span><span class="n">a_charges_keep</span><span class="p">)</span>  <span class="c1"># lookup table ``charge -&gt; [row_a]``</span>
    <span class="c1"># b_charges_match: for each row in a, which charge in b is compatible?</span>
    <span class="n">b_charges_match</span> <span class="o">=</span> <span class="n">charges</span><span class="o">.</span><span class="n">_partial_qtotal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">cut_b</span><span class="p">:],</span> <span class="n">b_qdata_keep</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>

    <span class="c1"># (rows_a changes faster than cols_b, such that the resulting array is qdata lex-sorted)</span>
    <span class="c1"># determine output qdata</span>
    <span class="n">res_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_qdata_a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_qdata_b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col_b</span><span class="p">,</span> <span class="n">charge_match</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b_charges_match</span><span class="p">):</span>
        <span class="n">rows_a</span> <span class="o">=</span> <span class="n">a_lookup_charges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">charge_match</span><span class="p">),</span> <span class="p">[])</span>  <span class="c1"># empty list if no match</span>
        <span class="k">for</span> <span class="n">row_a</span> <span class="ow">in</span> <span class="n">rows_a</span><span class="p">:</span>
            <span class="n">block_contr</span> <span class="o">=</span> <span class="n">fast_dot_sum</span><span class="p">(</span><span class="n">a_data</span><span class="p">[</span><span class="n">row_a</span><span class="p">],</span> <span class="n">b_data</span><span class="p">[</span><span class="n">col_b</span><span class="p">],</span> <span class="n">a_qdata_contr</span><span class="p">[</span><span class="n">row_a</span><span class="p">],</span>
                                       <span class="n">b_qdata_contr</span><span class="p">[</span><span class="n">col_b</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">block_contr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># no common blocks</span>
                <span class="c1"># Step 4) reshape back to tensors</span>
                <span class="n">block_contr</span> <span class="o">=</span> <span class="n">block_contr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a_shape_keep</span><span class="p">[</span><span class="n">row_a</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_shape_keep</span><span class="p">[</span><span class="n">col_b</span><span class="p">])</span>
                <span class="n">res_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_contr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">res_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="n">res_qdata_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_qdata_keep</span><span class="p">[</span><span class="n">row_a</span><span class="p">])</span>
                <span class="n">res_qdata_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_qdata_keep</span><span class="p">[</span><span class="n">col_b</span><span class="p">])</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[:</span><span class="n">cut_a</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="n">cut_b</span><span class="p">:],</span> <span class="n">res_dtype</span><span class="p">,</span> <span class="n">qtotal</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="c1"># (at least one entry is non-empty, so res_qdata[keep] is also not empty)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">res_qdata_a</span><span class="p">,</span> <span class="n">res_qdata_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">res</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">res_data</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_svd_worker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">qtotal_LR</span><span class="p">,</span> <span class="n">inner_qconj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main work of svd. Assumes that `a` is 2D and completely blocked.&quot;&quot;&quot;</span>
    <span class="n">chinfo</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span>
    <span class="n">qtotal_L</span><span class="p">,</span> <span class="n">qtotal_R</span> <span class="o">=</span> <span class="n">qtotal_LR</span>
    <span class="n">at</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># will be gradually increased, counting the number of singular values</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
        <span class="n">U_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">VH_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_leg_slices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_leg_slices_full</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">at_full</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">blocks_kept</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># main loop</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">)):</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
            <span class="n">U_b</span><span class="p">,</span> <span class="n">S_b</span><span class="p">,</span> <span class="n">VH_b</span> <span class="o">=</span> <span class="n">svd_flat</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">anynan</span><span class="p">(</span><span class="n">U_b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anynan</span><span class="p">(</span><span class="n">VH_b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anynan</span><span class="p">(</span><span class="n">S_b</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Svd (gesdd) gave NaNs. Try again with gesvd&quot;</span><span class="p">)</span>
                <span class="c1"># give it another try with the other (more stable) svd driver</span>
                <span class="n">U_b</span><span class="p">,</span> <span class="n">S_b</span><span class="p">,</span> <span class="n">VH_b</span> <span class="o">=</span> <span class="n">svd_flat</span><span class="p">(</span><span class="n">block</span><span class="p">,</span>
                                          <span class="n">full_matrices</span><span class="p">,</span>
                                          <span class="kc">True</span><span class="p">,</span>
                                          <span class="n">overwrite_a</span><span class="p">,</span>
                                          <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">lapack_driver</span><span class="o">=</span><span class="s1">&#39;gesvd&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">anynan</span><span class="p">(</span><span class="n">U_b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anynan</span><span class="p">(</span><span class="n">VH_b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">anynan</span><span class="p">(</span><span class="n">S_b</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;NaN in U_b </span><span class="si">{0:d}</span><span class="s2"> and/or VH_b: </span><span class="si">{1:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">U_b</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">VH_b</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S_b</span> <span class="o">=</span> <span class="n">svd_flat</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">anynan</span><span class="p">(</span><span class="n">S_b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;NaN in S: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">S_b</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_b</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">)</span>  <span class="c1"># bool array</span>
            <span class="n">S_b</span> <span class="o">=</span> <span class="n">S_b</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
                <span class="n">U_b</span> <span class="o">=</span> <span class="n">U_b</span><span class="p">[:,</span> <span class="n">keep</span><span class="p">]</span>
                <span class="n">VH_b</span> <span class="o">=</span> <span class="n">VH_b</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S_b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># have new singular values</span>
            <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
                <span class="n">blocks_kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">new_leg_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
                <span class="n">new_leg_slices_full</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at_full</span><span class="p">)</span>
                <span class="n">at_full</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">at</span> <span class="o">+=</span> <span class="n">num</span>
                <span class="n">U_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">U_b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="n">VH_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">VH_b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;SVD found no singluar values&quot;</span><span class="p">)</span>  <span class="c1"># (at least none &gt; cutoff)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">compute_uv</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># else: compute_uv is True</span>
    <span class="n">blocks_kept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">blocks_kept</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">nblocks</span> <span class="o">=</span> <span class="n">blocks_kept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">qi_L</span><span class="p">,</span> <span class="n">qi_R</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">[</span><span class="n">blocks_kept</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">qi_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nblocks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">U_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">qi_L</span><span class="p">,</span> <span class="n">qi_C</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">VH_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">qi_C</span><span class="p">,</span> <span class="n">qi_R</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_leg_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
    <span class="n">new_leg_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_leg_slices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">new_leg_charges</span> <span class="o">=</span> <span class="p">(</span><span class="n">qtotal_R</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi_R</span><span class="p">))</span> <span class="o">*</span> <span class="n">inner_qconj</span>
    <span class="n">new_leg_charges</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">new_leg_charges</span><span class="p">)</span>
    <span class="n">new_leg_R</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qind</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">new_leg_slices</span><span class="p">,</span> <span class="n">new_leg_charges</span><span class="p">,</span> <span class="n">inner_qconj</span><span class="p">)</span>
    <span class="n">new_leg_L</span> <span class="o">=</span> <span class="n">new_leg_R</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">full_matrices</span><span class="p">:</span>
        <span class="n">new_leg_slices_full</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at_full</span><span class="p">)</span>
        <span class="n">new_leg_slices_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_leg_slices_full</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">new_leg_full</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qind</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">new_leg_slices_full</span><span class="p">,</span> <span class="n">new_leg_charges</span><span class="p">,</span>
                                           <span class="n">inner_qconj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># new_leg_R is fine</span>
            <span class="n">new_leg_L</span> <span class="o">=</span> <span class="n">new_leg_full</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># new_leg_L is fine</span>
            <span class="n">new_leg_R</span> <span class="o">=</span> <span class="n">new_leg_full</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_leg_L</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal_L</span><span class="p">)</span>
    <span class="n">VH</span> <span class="o">=</span> <span class="n">Array</span><span class="p">([</span><span class="n">new_leg_R</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">qtotal_R</span><span class="p">)</span>
    <span class="n">U</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">U_data</span>
    <span class="n">U</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U_qdata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">U</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata_sorted</span>
    <span class="n">VH</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">VH_data</span>
    <span class="n">VH</span><span class="o">.</span><span class="n">_qdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">VH_qdata</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">VH</span><span class="o">.</span><span class="n">_qdata_sorted</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_qdata_sorted</span>
    <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VH</span>


<span class="k">def</span> <span class="nf">_eig_worker</span><span class="p">(</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Worker for ``eig``, ``eigh``&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expect a square matrix!&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-trivial qtotal -&gt; Nilpotent. Not diagonizable!?&quot;</span><span class="p">)</span>

    <span class="n">piped_axes</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>  <span class="c1"># ensure complete blocking</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span> <span class="k">if</span> <span class="n">hermitian</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span>
    <span class="n">resw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">resv</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># w, v now default to 0 and the Identity</span>
    <span class="k">for</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>  <span class="c1"># non-zero blocks on the diagonal</span>
        <span class="k">if</span> <span class="n">hermitian</span><span class="p">:</span>
            <span class="n">rw</span><span class="p">,</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">UPLO</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rw</span><span class="p">,</span> <span class="n">rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># apply sorting options</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">qi</span> <span class="o">=</span> <span class="n">qindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># both `a` and `resv` are sorted and share the same qindices</span>
        <span class="n">resv</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span>  <span class="c1"># replace idendity block</span>
        <span class="n">resw</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rw</span>  <span class="c1"># replace eigenvalues</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">piped_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">resv</span> <span class="o">=</span> <span class="n">resv</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># the &#39;outer&#39; facing leg is permuted back.</span>
    <span class="k">return</span> <span class="n">resw</span><span class="p">,</span> <span class="n">resv</span>


<span class="k">def</span> <span class="nf">_eigvals_worker</span><span class="p">(</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Worker for ``eigvals``, ``eigvalsh``&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expect a square matrix!&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-trivial qtotal -&gt; Nilpotent. Not diagonizable!?&quot;</span><span class="p">)</span>
    <span class="n">piped_axes</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>  <span class="c1"># ensure complete blocking</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span> <span class="k">if</span> <span class="n">hermitian</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span>
    <span class="n">resw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># w now default to 0</span>
    <span class="k">for</span> <span class="n">qindices</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_qdata</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>  <span class="c1"># non-zero blocks on the diagonal</span>
        <span class="k">if</span> <span class="n">hermitian</span><span class="p">:</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">UPLO</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># apply sorting options</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
        <span class="n">qi</span> <span class="o">=</span> <span class="n">qindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># both `a` and `resv` are sorted and share the same qindices</span>
        <span class="n">resw</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rw</span>  <span class="c1"># replace eigenvalues</span>
    <span class="k">return</span> <span class="n">resw</span>


<span class="k">def</span> <span class="nf">__pyx_unpickle_Array</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="n">checksum</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Allow to unpickle Arrays created with Cython-compiled TenPy version 0.3.0&quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">Array</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># doesn&#39;t happen on my computer...</span>
        <span class="n">res</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Tenpy Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Sep 26, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>