
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tenpy.networks.mpo &#8212; TeNPy 0.4.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tenpy.networks.mpo</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Matrix product operator (MPO).</span>

<span class="sd">An MPO is the generalization of an :class:`~tenpy.networks.mps.MPS` to operators. Graphically::</span>

<span class="sd">    |      ^        ^        ^</span>
<span class="sd">    |      |        |        |</span>
<span class="sd">    |  -&gt;- W[0] -&gt;- W[1] -&gt;- W[2] -&gt;- ...</span>
<span class="sd">    |      |        |        |</span>
<span class="sd">    |      ^        ^        ^</span>

<span class="sd">So each &#39;matrix&#39; has two physical legs ``p, p*`` instead of just one,</span>
<span class="sd">i.e. the entries of the &#39;matrices&#39; are local operators.</span>
<span class="sd">Valid boundary conditions of an MPO are the same as for an MPS</span>
<span class="sd">(i.e. ``&#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;``).</span>
<span class="sd">(In general, you can view the MPO as an MPS with larger physical space and bring it into</span>
<span class="sd">canoncial form. However, unlike for an MPS, this doesn&#39;t simplify calculations.</span>
<span class="sd">Thus, an MPO has no `form`.)</span>

<span class="sd">We use the following label convention for the `W` (where arrows indicate `qconj`)::</span>

<span class="sd">    |            p*</span>
<span class="sd">    |            ^</span>
<span class="sd">    |            |</span>
<span class="sd">    |     wL -&gt;- W -&gt;- wR</span>
<span class="sd">    |            |</span>
<span class="sd">    |            ^</span>
<span class="sd">    |            p</span>


<span class="sd">If an MPO describes a sum of local terms (e.g. most Hamiltonians),</span>
<span class="sd">some bond indices correspond to &#39;only identities to the left/right&#39;.</span>
<span class="sd">We store these indices in `IdL` and `IdR` (if there are such indices).</span>

<span class="sd">Similar as for the MPS, a bond index ``i`` is *left* of site `i`,</span>
<span class="sd">i.e. between sites ``i-1`` and ``i``.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">np_conserved</span> <span class="k">as</span> <span class="n">npc</span>
<span class="kn">from</span> <span class="nn">.site</span> <span class="k">import</span> <span class="n">group_sites</span><span class="p">,</span> <span class="n">Site</span>
<span class="kn">from</span> <span class="nn">..tools.string</span> <span class="k">import</span> <span class="n">vert_join</span>
<span class="kn">from</span> <span class="nn">.mps</span> <span class="k">import</span> <span class="n">MPS</span> <span class="k">as</span> <span class="n">_MPS</span>  <span class="c1"># only for MPS._valid_bc</span>
<span class="kn">from</span> <span class="nn">.mps</span> <span class="k">import</span> <span class="n">MPSEnvironment</span>
<span class="kn">from</span> <span class="nn">.terms</span> <span class="k">import</span> <span class="n">OnsiteTerms</span><span class="p">,</span> <span class="n">CouplingTerms</span><span class="p">,</span> <span class="n">MultiCouplingTerms</span>
<span class="kn">from</span> <span class="nn">..tools.misc</span> <span class="k">import</span> <span class="n">add_with_None_0</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MPO&#39;</span><span class="p">,</span> <span class="s1">&#39;MPOGraph&#39;</span><span class="p">,</span> <span class="s1">&#39;MPOEnvironment&#39;</span><span class="p">,</span> <span class="s1">&#39;grid_insert_ops&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="MPO"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO">[docs]</a><span class="k">class</span> <span class="nc">MPO</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Matrix product operator, finite (MPO) or infinite (iMPO).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sites : list of :class:`~tenpy.models.lattice.Site`</span>
<span class="sd">        Defines the local Hilbert space for each site.</span>
<span class="sd">    Ws : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        The matrices of the MPO. Should have labels ``wL, wR, p, p*``.</span>
<span class="sd">    bc : {&#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;}</span>
<span class="sd">        Boundary conditions as described in :mod:`~tenpy.networks.mps`.</span>
<span class="sd">        ``&#39;finite&#39;`` requires ``Ws[0].get_leg(&#39;wL&#39;).ind_len = 1``.</span>
<span class="sd">    IdL : (iterable of) {int | None}</span>
<span class="sd">        Indices on the bonds, which correpond to &#39;only identities to the left&#39;.</span>
<span class="sd">        A single entry holds for all bonds.</span>
<span class="sd">    IdR : (iterable of) {int | None}</span>
<span class="sd">        Indices on the bonds, which correpond to &#39;only identities to the right&#39;.</span>
<span class="sd">    max_range : int | np.inf | None</span>
<span class="sd">        Maximum range of hopping/interactions (in unit of sites) of the MPO. ``None`` for unknown.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        ``len(sites)``. For an iMPS, this is the number of sites in the MPS unit cell.</span>
<span class="sd">    chinfo : :class:`~tenpy.linalg.np_conserved.ChargeInfo`</span>
<span class="sd">        The nature of the charge.</span>
<span class="sd">    sites : list of :class:`~tenpy.models.lattice.Site`</span>
<span class="sd">        Defines the local Hilbert space for each site.</span>
<span class="sd">    dtype : type</span>
<span class="sd">        The data type of the `_W`.</span>
<span class="sd">    bc : {&#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;}</span>
<span class="sd">        Boundary conditions as described in :mod:`~tenpy.networks.mps`.</span>
<span class="sd">        ``&#39;finite&#39;`` requires ``Ws[0].get_leg(&#39;wL&#39;).ind_len = 1``.</span>
<span class="sd">    IdL : list of {int | None}</span>
<span class="sd">        Indices on the bonds (length `L`+1), which correpond to &#39;only identities to the left&#39;.</span>
<span class="sd">        ``None`` for bonds where it is not set.</span>
<span class="sd">        In standard form, this is `0` (except for unset bonds in finite case)</span>
<span class="sd">    IdR : list of {int | None}</span>
<span class="sd">        Indices on the bonds (length `L`+1), which correpond to &#39;only identities to the right&#39;.</span>
<span class="sd">        ``None`` for bonds where it is not set.</span>
<span class="sd">        In standard form, this is the last index on the bond (except for unset bonds in finite case).</span>
<span class="sd">    max_range : int | np.inf | None</span>
<span class="sd">        Maximum range of hopping/interactions (in unit of sites) of the MPO. ``None`` for unknown.</span>
<span class="sd">    grouped : int</span>
<span class="sd">        Number of sites grouped together, see :meth:`group_sites`.</span>
<span class="sd">    _W : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        The matrices of the MPO. Labels are ``&#39;wL&#39;, &#39;wR&#39;, &#39;p&#39;, &#39;p*&#39;``.</span>
<span class="sd">    _valid_bc : tuple of str</span>
<span class="sd">        Valid boundary conditions. The same as for an MPS.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_valid_bc</span> <span class="o">=</span> <span class="n">_MPS</span><span class="o">.</span><span class="n">_valid_bc</span>  <span class="c1"># same valid boundary conditions as an MPS.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">IdL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">IdR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">W</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">W</span> <span class="ow">in</span> <span class="n">Ws</span><span class="p">],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_W</span> <span class="o">=</span> <span class="p">[</span><span class="n">W</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">W</span> <span class="ow">in</span> <span class="n">Ws</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IdL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Id</span><span class="p">(</span><span class="n">IdL</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IdR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_Id</span><span class="p">(</span><span class="n">IdR</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">bc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="o">=</span> <span class="n">max_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>

<div class="viewcode-block" id="MPO.from_grids"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.from_grids">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_grids</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                   <span class="n">sites</span><span class="p">,</span>
                   <span class="n">grids</span><span class="p">,</span>
                   <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span>
                   <span class="n">IdL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">IdR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">Ws_qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">leg0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">max_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an MPO from `grids`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sites : list of :class:`~tenpy.models.lattice.Site`</span>
<span class="sd">            Defines the local Hilbert space for each site.</span>
<span class="sd">        grids : list of list of list of entries</span>
<span class="sd">            For each site (outer-most list) a matrix-grid (corresponding to ``wL, wR``)</span>
<span class="sd">            with entries being or representing (see :func:`grid_insert_ops`) onsite-operators.</span>
<span class="sd">        bc : {&#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;}</span>
<span class="sd">            Boundary conditions as described in :mod:`~tenpy.networks.mps`.</span>
<span class="sd">        IdL : (iterable of) {int | None}</span>
<span class="sd">            Indices on the bonds, which correpond to &#39;only identities to the left&#39;.</span>
<span class="sd">            A single entry holds for all bonds.</span>
<span class="sd">        IdR : (iterable of) {int | None}</span>
<span class="sd">            Indices on the bonds, which correpond to &#39;only identities to the right&#39;.</span>
<span class="sd">        Ws_qtotal : (list of) total charge</span>
<span class="sd">            The `qtotal` to be used for each grid. Defaults to zero charges.</span>
<span class="sd">        leg0 : :class:`~tenpy.linalg.charge.LegCharge`</span>
<span class="sd">            LegCharge for &#39;wL&#39; of the left-most `W`. By default, construct it.</span>
<span class="sd">        max_range : int | np.inf | None</span>
<span class="sd">            Maximum range of hopping/interactions (in unit of sites) of the MPO.</span>
<span class="sd">            ``None`` for unknown.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        grid_insert_ops : used to plug in `entries` of the grid.</span>
<span class="sd">        tenpy.linalg.np_conserved.grid_outer : used for final conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chinfo</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span> <span class="o">==</span> <span class="n">L</span>  <span class="c1"># wrong arguments?</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_insert_ops</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">grids</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">Ws_qtotal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Ws_qtotal</span> <span class="o">=</span> <span class="p">[</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ws_qtotal</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">Ws_qtotal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Ws_qtotal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">Ws_qtotal</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ws_qtotal</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="n">IdL</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_Id</span><span class="p">(</span><span class="n">IdL</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">IdR</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_Id</span><span class="p">(</span><span class="n">IdR</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bc</span> <span class="o">!=</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">leg0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># ensure that we have only a single entry in the first and last leg</span>
                <span class="c1"># i.e. project grids[0][:, :] -&gt; grids[0][IdL[0], :]</span>
                <span class="c1"># and         grids[-1][:, :] -&gt; grids[-1][:,IdR[-1], :]</span>
                <span class="n">first_grid</span> <span class="o">=</span> <span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">last_grid</span> <span class="o">=</span> <span class="n">grids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_grid</span><span class="p">[</span><span class="n">IdL</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">IdL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">IdR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">last_grid</span><span class="p">]</span>
                    <span class="n">IdR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">legs</span> <span class="o">=</span> <span class="n">_calc_grid_legs_finite</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="p">,</span> <span class="n">leg0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">legs</span> <span class="o">=</span> <span class="n">_calc_grid_legs_infinite</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="p">,</span> <span class="n">leg0</span><span class="p">,</span> <span class="n">IdL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># now build the `W` from the grid</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">legs</span><span class="p">)</span> <span class="o">==</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">grid_outer</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">[</span><span class="n">legs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">legs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span> <span class="n">Ws_qtotal</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">W</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">])</span>
            <span class="n">Ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">IdL</span><span class="p">,</span> <span class="n">IdR</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPO.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity check. Raises Errors if something is wrong.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_bc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid MPO boundary conditions: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">S</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">))</span>
            <span class="n">S</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;p*&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                <span class="n">W2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">W</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">W2</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wL&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IdL</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IdR</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of `IdL`/`IdR`&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of physical sites. For an iMPO the len of the MPO unit cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of local physical dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Distinguish MPO (``True; bc=&#39;finite&#39;, &#39;segment&#39;`` ) vs. iMPO (``False; bc=&#39;infinite&#39;``)&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_bc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">!=</span> <span class="s1">&#39;infinite&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensions of the (nontrivial) virtual bonds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">W</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span> <span class="k">for</span> <span class="n">W</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span><span class="p">]</span>

<div class="viewcode-block" id="MPO.get_W"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.get_W">[docs]</a>    <span class="k">def</span> <span class="nf">get_W</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return `W` at site `i`.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="MPO.set_W"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.set_W">[docs]</a>    <span class="k">def</span> <span class="nf">set_W</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set `W` at site `i`.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span></div>

<div class="viewcode-block" id="MPO.get_IdL"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.get_IdL">[docs]</a>    <span class="k">def</span> <span class="nf">get_IdL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index of `IdL` at bond to the *left* of site `i`.</span>

<span class="sd">        May be ``None``.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">IdL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="MPO.get_IdR"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.get_IdR">[docs]</a>    <span class="k">def</span> <span class="nf">get_IdR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index of `IdR` at bond to the *right* of site `i`.</span>

<span class="sd">        May be ``None``.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">IdR</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="MPO.group_sites"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.group_sites">[docs]</a>    <span class="k">def</span> <span class="nf">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify `self` inplace to group sites.</span>

<span class="sd">        Group each `n` sites together using the :class:`~tenpy.networks.site.GroupedSite`.</span>
<span class="sd">        This might allow to do TEBD with a Trotter decomposition,</span>
<span class="sd">        or help the convergence of DMRG (in case of too long range interactions).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of sites to be grouped together.</span>
<span class="sd">        grouped_sites : None | list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grouped_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grouped_sites</span> <span class="o">=</span> <span class="n">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">grouped_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_sites</span> <span class="o">==</span> <span class="n">n</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span> <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">grouped_sites</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="o">//</span> <span class="n">min_n</span><span class="p">))</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">IdL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">IdR</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">IdR</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">grouped_sites</span><span class="p">:</span>
            <span class="n">new_W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span><span class="p">):</span>
                <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">])</span>
                <span class="n">new_W</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">new_W</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">))]</span>
            <span class="n">new_W</span> <span class="o">=</span> <span class="n">new_W</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">comb</span><span class="p">,</span> <span class="n">pipes</span><span class="o">=</span><span class="p">[</span><span class="n">gs</span><span class="o">.</span><span class="n">leg</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">conj</span><span class="p">()])</span>
            <span class="n">Ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_W</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">]))</span>
            <span class="n">IdL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_IdL</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span>
            <span class="n">IdR</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_IdR</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">IdL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IdL</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IdL</span> <span class="o">=</span> <span class="n">IdL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IdR</span> <span class="o">=</span> <span class="n">IdR</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_W</span> <span class="o">=</span> <span class="n">Ws</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">grouped_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">*</span> <span class="n">n</span></div>

<div class="viewcode-block" id="MPO.expectation_value"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.expectation_value">[docs]</a>    <span class="k">def</span> <span class="nf">expectation_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate ``&lt;psi|self|psi&gt;/&lt;psi|psi&gt;``.</span>

<span class="sd">        For a finite MPS, simply contract the network ``&lt;psi|self|psi&gt;``.</span>
<span class="sd">        For an infinite MPS, it assumes that `self` is the a of terms, with :attr:`IdL`</span>
<span class="sd">        and :attr:`IdR` defined on each site.  Under this assumption,</span>
<span class="sd">        it calculates the expectation value of terms with the left-most non-trivial</span>
<span class="sd">        operator inside the MPO unit cell and returns the average value per site.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psi : :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">            State for which the expectation value should be taken.</span>
<span class="sd">        tol : float</span>
<span class="sd">            Ignored for finite `psi`.</span>
<span class="sd">            For infinite MPO containing exponentially decaying long-range terms, stop evaluating</span>
<span class="sd">            further terms if the terms in `LP` have norm &lt; `tol`.</span>
<span class="sd">        max_range : int</span>
<span class="sd">            Ignored for finite `psi`.</span>
<span class="sd">            Contract at most ``self.L * max_range`` sites, even if `tol` is not reached.</span>
<span class="sd">            In that case, issue a warning.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exp_val : float/complex</span>
<span class="sd">            The expectation value of `self` with respect to the state `psi`.</span>
<span class="sd">            For an infinite MPS: the density per site.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">psi</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MPOEnvironment</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span><span class="o">.</span><span class="n">full_contraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">LP0</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">init_LP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mpo</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">masks_L_no_IdL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">masks_R_no_IdRL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">W</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">):</span>
            <span class="n">mask_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">mask_L</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_IdL</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">masks_L_no_IdL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_L</span><span class="p">)</span>
            <span class="n">mask_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">mask_R</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_IdL</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mask_R</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_IdR</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">masks_R_no_IdRL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_R</span><span class="p">)</span>
        <span class="c1"># contract first site with theta</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP0</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]])</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_range</span> <span class="o">*</span> <span class="n">L</span><span class="p">):</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">L</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">:</span>
                <span class="c1"># have one full unit cell: don&#39;t use further terms starting with IdL</span>
                <span class="n">mask_L</span> <span class="o">=</span> <span class="n">masks_L_no_IdL</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span>
                <span class="n">LP</span><span class="o">.</span><span class="n">iproject</span><span class="p">(</span><span class="n">mask_L</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">)</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">W</span><span class="o">.</span><span class="n">iproject</span><span class="p">(</span><span class="n">mask_L</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]])</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]])</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">L</span><span class="p">:</span>
                <span class="n">RP</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">init_RP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mpo</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">current_value</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span>
                                          <span class="n">RP</span><span class="p">,</span>
                                          <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]],</span>
                                          <span class="n">do_conj</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">LP_converged</span> <span class="o">=</span> <span class="n">LP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">LP_converged</span><span class="o">.</span><span class="n">iproject</span><span class="p">(</span><span class="n">masks_R_no_IdRL</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="s1">&#39;wR&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">LP_converged</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># no more terms left</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no break</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tolerance </span><span class="si">{0:.2e}</span><span class="s2"> not reached within </span><span class="si">{1:d}</span><span class="s2"> sites&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tol</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_value</span> <span class="o">/</span> <span class="n">L</span></div>

<div class="viewcode-block" id="MPO.dagger"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.dagger">[docs]</a>    <span class="k">def</span> <span class="nf">dagger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return hermition conjugate copy of self.&quot;&quot;&quot;</span>
        <span class="c1"># complex conjugate and transpose everything</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">]</span>
        <span class="c1"># and now revert conjugation of the wL/wR legs</span>
        <span class="c1"># rename labels &#39;wL*&#39; -&gt; &#39;wL&#39;, &#39;wR*&#39; -&gt; &#39;wR&#39;</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Ws</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">ireplace_labels</span><span class="p">([</span><span class="s1">&#39;wL*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">])</span>
        <span class="c1"># flip charges and qconj back</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">Ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wR</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flip_charges_qconj</span><span class="p">()</span>
            <span class="n">Ws</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wR</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="n">Ws</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wR</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flip_charges_qconj</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="n">Ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flip_charges_qconj</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ws</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wR</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">MPO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">IdL</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">IdR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPO.is_hermitian"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.is_hermitian">[docs]</a>    <span class="k">def</span> <span class="nf">is_hermitian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if `self` is a hermitian MPO.</span>

<span class="sd">        Shorthand for ``self.is_equal(self.dagger(), eps, max_range)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dagger</span><span class="p">(),</span> <span class="n">eps</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPO.is_equal"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.is_equal">[docs]</a>    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if `self` and `other` represent the same MPO to precision `eps`.</span>

<span class="sd">        To compare them efficiently we view `self` and `other` as MPS and compare the overlaps</span>
<span class="sd">        ``abs(&lt;self|self&gt; + &lt;other|other&gt; - 2 Re(&lt;self|other&gt;)) &lt; eps*(&lt;self|self&gt;+&lt;other|other&gt;)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`MPO`</span>
<span class="sd">            The MPO to compare to.</span>
<span class="sd">        eps : float</span>
<span class="sd">            Precision threshold what counts as zero.</span>
<span class="sd">        max_range : None | int</span>
<span class="sd">            Ignored for finite MPS; for finite MPS we consider only the terms contained in the</span>
<span class="sd">            sites with indices ``range(self.L + max_range)``.</span>
<span class="sd">            None defaults to :attr:`max_range` (or :attr:`L` in case this is infinite or None).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equal : bool</span>
<span class="sd">            Whether `self` equals `other` to the desired precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="n">max_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">max_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span>
            <span class="n">max_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="n">max_range</span>

        <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;&lt;A|B&gt; on sites 0 to max_i&quot;&quot;&quot;</span>
            <span class="n">wA</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">take_slice</span><span class="p">([</span><span class="n">A</span><span class="o">.</span><span class="n">get_IdL</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;wL&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">wB</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">take_slice</span><span class="p">([</span><span class="n">B</span><span class="o">.</span><span class="n">get_IdL</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;wL&#39;</span><span class="p">])</span>
            <span class="n">trAdB</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">wA</span><span class="p">,</span> <span class="n">wB</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]])</span>  <span class="c1"># wR* wR</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_i</span><span class="p">):</span>
                <span class="n">trAdB</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">trAdB</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;wR*&#39;</span><span class="p">,</span> <span class="s1">&#39;wL*&#39;</span><span class="p">])</span>
                <span class="n">trAdB</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">trAdB</span><span class="p">,</span>
                                      <span class="n">B</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                      <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]])</span>
            <span class="n">trAdB</span> <span class="o">=</span> <span class="n">trAdB</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wR*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">])[</span><span class="n">A</span><span class="o">.</span><span class="n">get_IdR</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">get_IdR</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">trAdB</span>

        <span class="n">self_other</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">overlap</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="n">norms</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">overlap</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">norms</span> <span class="o">-</span> <span class="n">self_other</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">norms</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_to_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure `i` is a valid index (depending on `self.bc`).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;i = </span><span class="si">{0:d}</span><span class="s2"> out of bounds for finite MPO&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">i</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_Id</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;parse the IdL or IdR argument of __init__&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">Id</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">Id</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="MPO.get_grouped_mpo"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.get_grouped_mpo">[docs]</a>    <span class="k">def</span> <span class="nf">get_grouped_mpo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocklen</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;contract blocklen subsequent tensors into a single one and return result as a new MPO object&quot;&quot;&quot;</span>
        <span class="n">groupedMPO</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">groupedMPO</span><span class="o">.</span><span class="n">group_sites</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">blocklen</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">groupedMPO</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPO.get_full_hamiltonian"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.get_full_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">get_full_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mf">1e6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;extract the full Hamiltonian as a d**L x d**L matrix&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxsize</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix dimension exceeds maxsize&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">singlesitempo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grouped_mpo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">npc</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">singlesitempo</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;wL&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;wR&#39;</span><span class="p">]])</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an MPO representing `self + other`.</span>

<span class="sd">        Requires both `self` and `other` to be in standard sum form with `IdL` and `IdR` being set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`MPO`</span>
<span class="sd">            MPO to be added to `self`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum_mpo : :class:`MPO`</span>
<span class="sd">            The sum `self + other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bc</span>
        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="n">L</span>

        <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_projections</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">po</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_get_block_projections</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">block_</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">of</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">pl</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">pr</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># else</span>
            <span class="k">return</span> <span class="n">block_</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span>

        <span class="c1"># l/r = left/rigth,  s/o = self/other</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">IdL</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">IdL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">IdR</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">IdR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">])</span>
            <span class="n">wo</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">])</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">o</span> <span class="o">=</span> <span class="p">(</span><span class="n">wo</span><span class="p">,</span> <span class="n">po</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">po</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">onsite</span> <span class="o">=</span> <span class="n">add_with_None_0</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">block</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">w_grid</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">block</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">onsite</span>        <span class="p">],</span>
                <span class="p">[</span><span class="kc">None</span><span class="p">,</span>           <span class="n">block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span>           <span class="n">block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
                <span class="p">[</span><span class="kc">None</span><span class="p">,</span>           <span class="kc">None</span><span class="p">,</span>           <span class="n">block</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">block</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
                <span class="p">[</span><span class="kc">None</span><span class="p">,</span>           <span class="kc">None</span><span class="p">,</span>           <span class="kc">None</span><span class="p">,</span>           <span class="n">block</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="p">]</span>  <span class="c1"># yapf: disable</span>
            <span class="n">w_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">IdL</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">w_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">IdR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># now drop rows and columns which are completely zero</span>
            <span class="n">w_is_None</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[(</span><span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_row</span><span class="p">]</span> <span class="k">for</span> <span class="n">w_row</span> <span class="ow">in</span> <span class="n">w_grid</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">w_grid</span> <span class="o">=</span> <span class="n">w_grid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">w_is_None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="p">:]</span>
            <span class="n">w_grid</span> <span class="o">=</span> <span class="n">w_grid</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">w_is_None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span>
            <span class="n">Ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">grid_concat</span><span class="p">(</span><span class="n">w_grid</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">max_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_range</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_range</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">max_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_range</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">MPO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">,</span> <span class="n">IdL</span><span class="p">,</span> <span class="n">IdR</span><span class="p">,</span> <span class="n">max_range</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_block_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;projecteions onto (IdL, other, IdR) on bond `i` in range(0, L+1)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>  <span class="c1"># allows i = L for finite bc</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
                <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span>
        <span class="n">IdL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">IdL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">IdR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">IdR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">proj_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">IdL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">proj_IdL</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj_IdL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">proj_IdL</span><span class="p">[</span><span class="n">IdL</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">proj_other</span><span class="p">[</span><span class="n">IdL</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">IdR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">proj_IdR</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj_IdR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">proj_IdR</span><span class="p">[</span><span class="n">IdR</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">proj_other</span><span class="p">[</span><span class="n">IdR</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">IdR</span> <span class="o">!=</span> <span class="n">IdL</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">IdL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">IdR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">proj_other</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">proj_IdL</span><span class="p">,</span> <span class="n">proj_other</span><span class="p">,</span> <span class="n">proj_IdR</span><span class="p">)</span></div>


<div class="viewcode-block" id="MPOGraph"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph">[docs]</a><span class="k">class</span> <span class="nc">MPOGraph</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Representation of an MPO by a graph, based on a &#39;finite state machine&#39;.</span>

<span class="sd">    This representation is used for building H_MPO from the interactions.</span>
<span class="sd">    The idea is to view the MPO as a kind of &#39;finite state machine&#39;.</span>
<span class="sd">    The **states** or **keys** of this finite state machine life on the MPO bonds *between* the</span>
<span class="sd">    `Ws`. They label the indices of the virtul bonds of the MPOs, i.e., the indices on legs</span>
<span class="sd">    ``wL`` and ``wR``. They can be anything hash-able like a ``str``, ``int`` or a tuple of them.</span>

<span class="sd">    The **edges** of the graph are the entries ``W[keyL, keyR]``, which itself are onsite operators</span>
<span class="sd">    on the local Hilbert space. The indices `keyL` and `keyR` correspond to the legs ``&#39;wL&#39;, &#39;wR&#39;``</span>
<span class="sd">    of the MPO. The entry ``W[keyL, keyR]`` connects the state ``keyL`` on bond ``(i-1, i)``</span>
<span class="sd">    with the state ``keyR`` on bond ``(i, i+1)``.</span>

<span class="sd">    The keys ``&#39;IdR&#39;`` (for &#39;idenity left&#39;) and ``&#39;IdR&#39;`` (for &#39;identity right&#39;) are reserved to</span>
<span class="sd">    represent only ``&#39;Id&#39;`` (=identity) operators to the left and right of the bond, respectively.</span>

<span class="sd">    .. todo ::</span>
<span class="sd">        might be useful to add a &quot;cleanup&quot; function which removes operators cancelling each other</span>
<span class="sd">        and/or unused states. Or better use a &#39;compress&#39; of the MPO?</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sites : list of :class:`~tenpy.models.lattice.Site`</span>
<span class="sd">        Local sites of the Hilbert space.</span>
<span class="sd">    bc : {&#39;finite&#39;, &#39;infinite&#39;}</span>
<span class="sd">        MPO boundary conditions.</span>
<span class="sd">    max_range : int | np.inf | None</span>
<span class="sd">        Maximum range of hopping/interactions (in unit of sites) of the MPO. ``None`` for unknown.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    L</span>
<span class="sd">    sites : list of :class:`~tenpy.models.lattice.Site`</span>
<span class="sd">        Defines the local Hilbert space for each site.</span>
<span class="sd">    chinfo : :class:`~tenpy.linalg.np_conserved.ChargeInfo`</span>
<span class="sd">        The nature of the charge.</span>
<span class="sd">    bc : {&#39;finite&#39;, &#39;infinite&#39;}</span>
<span class="sd">        MPO boundary conditions.</span>
<span class="sd">    max_range : int | np.inf | None</span>
<span class="sd">        Maximum range of hopping/interactions (in unit of sites) of the MPO. ``None`` for unknown.</span>
<span class="sd">    states : list of set of keys</span>
<span class="sd">        ``states[i]`` gives the possible keys at the virtual bond ``(i-1, i)`` of the MPO.</span>
<span class="sd">    graph : list of dict of dict of list of tuples</span>
<span class="sd">        For each site `i` a dictionary ``{keyL: {keyR: [(opname, strength)]}}`` with</span>
<span class="sd">        ``keyL in vertices[i]`` and ``keyR in vertices[i+1]``.</span>
<span class="sd">    _grid_legs : None | list of LegCharge</span>
<span class="sd">        The charges for the MPO</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">bc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span> <span class="o">=</span> <span class="n">max_range</span>
        <span class="c1"># empty graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>

<div class="viewcode-block" id="MPOGraph.from_terms"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.from_terms">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_terms</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">onsite_terms</span><span class="p">,</span> <span class="n">coupling_terms</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an :class:`MPOGraph` from OnsiteTerms and CouplingTerms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        onsite_terms : :class:`~tenpy.networks.terms.OnsiteTerms`</span>
<span class="sd">            Onsite terms to be added to the new :class:`MPOGraph`.</span>
<span class="sd">        coupling_terms :class:`~tenpy.networks.terms.CouplingTerms` | :class:`~tenpy.networks.terms.MultiCouplingTerms`</span>
<span class="sd">            Coupling terms to be added to the new :class:`MPOGraph`.</span>
<span class="sd">        sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            Local sites of the Hilbert space.</span>
<span class="sd">        bc : ``&#39;finite&#39; | &#39;infinite&#39;``</span>
<span class="sd">            MPO boundary conditions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        graph : :class:`MPOGraph`</span>
<span class="sd">            Initialized with the given terms.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        from_term_list : equivalent for other representation terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">coupling_terms</span><span class="o">.</span><span class="n">max_range</span><span class="p">())</span>
        <span class="n">onsite_terms</span><span class="o">.</span><span class="n">add_to_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">coupling_terms</span><span class="o">.</span><span class="n">add_to_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_missing_IdL_IdR</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">graph</span></div>

<div class="viewcode-block" id="MPOGraph.from_term_list"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.from_term_list">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_term_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">term_list</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize form a list of operator terms and prefactors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        term_list : :class:`~tenpy.networks.mps.TermList`</span>
<span class="sd">            Terms to be added to the MPOGraph.</span>
<span class="sd">        sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            Local sites of the Hilbert space.</span>
<span class="sd">        bc : ``&#39;finite&#39; | &#39;infinite&#39;``</span>
<span class="sd">            MPO boundary conditions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        graph : :class:`MPOGraph`</span>
<span class="sd">            Initialized with the given terms.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        from_terms : equivalent for other representation of terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ot</span><span class="p">,</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">term_list</span><span class="o">.</span><span class="n">to_OnsiteTerms_CouplingTerms</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_terms</span><span class="p">(</span><span class="n">ot</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPOGraph.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity check. Raises ValueErrors, if something is wrong.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MPO</span><span class="o">.</span><span class="n">_valid_bc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid MPO boundary conditions: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid ChargeInfo for site </span><span class="si">{i:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
            <span class="n">stL</span><span class="p">,</span> <span class="n">stR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="c1"># check graph</span>
            <span class="n">gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">keyL</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">keyL</span> <span class="ow">in</span> <span class="n">stL</span>
                <span class="k">for</span> <span class="n">keyR</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">[</span><span class="n">keyL</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="n">keyR</span> <span class="ow">in</span> <span class="n">stR</span>
                    <span class="k">for</span> <span class="n">opname</span><span class="p">,</span> <span class="n">strength</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">[</span><span class="n">keyL</span><span class="p">][</span><span class="n">keyR</span><span class="p">]:</span>
                        <span class="k">assert</span> <span class="n">site</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">opname</span><span class="p">)</span></div>
        <span class="c1"># done</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of physical sites. For an iMPS the length of the unit cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>

<div class="viewcode-block" id="MPOGraph.add"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keyL</span><span class="p">,</span> <span class="n">keyR</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">check_op</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an edge into the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Site index at which the edge of the graph is to be inserted.</span>
<span class="sd">        keyL : hashable</span>
<span class="sd">            The state at bond (i-1, i) to connect from.</span>
<span class="sd">        keyR : hashable</span>
<span class="sd">            The state at bond (i, i+1) to connect to.</span>
<span class="sd">        opname : str</span>
<span class="sd">            Name of the operator.</span>
<span class="sd">        strength : str</span>
<span class="sd">            Prefactor of the operator to be inserted.</span>
<span class="sd">        check_op : bool</span>
<span class="sd">            Whether to check that &#39;opname&#39; exists on the given `site`.</span>
<span class="sd">        skip_existing : bool</span>
<span class="sd">            If ``True``, skip adding the graph node if it exists (with same keys and `opname`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="n">check_op</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">opname</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator </span><span class="si">{0!r}</span><span class="s2"> not existent on site </span><span class="si">{1:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">keyL</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">keyL</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keyR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">keyR</span><span class="p">)</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">keyL</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="n">keyR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
            <span class="n">D</span><span class="p">[</span><span class="n">keyR</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">opname</span><span class="p">,</span> <span class="n">strength</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">keyR</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_existing</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">op</span> <span class="o">==</span> <span class="n">opname</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">]):</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">opname</span><span class="p">,</span> <span class="n">strength</span><span class="p">))</span></div>

<div class="viewcode-block" id="MPOGraph.add_string"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.add_string">[docs]</a>    <span class="k">def</span> <span class="nf">add_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">opname</span><span class="o">=</span><span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="n">check_op</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert a bunch of edges for an &#39;operator string&#39; into the graph.</span>

<span class="sd">        Terms like :math:`S^z_i S^z_j` actually stand for</span>
<span class="sd">        :math:`S^z_i \otimes \prod_{i &lt; k &lt; j} \mathbb{1}_k \otimes S^z_j`.</span>
<span class="sd">        This function adds the :math:`\mathbb{1}` terms to the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j: int</span>
<span class="sd">            An edge is inserted on all bonds between `i` and `j`, `i &lt; j`.</span>
<span class="sd">            `j` can be larger than :attr:`L`, in which case the operators are supposed to act on</span>
<span class="sd">            different MPS unit cells.</span>
<span class="sd">        key: hashable</span>
<span class="sd">            The state at bond (i-1, i) to connect from and on bond (j-1, j) to connect to.</span>
<span class="sd">            Also used for the intermediate states.</span>
<span class="sd">            No operator is inserted on a site `i &lt; k &lt; j` if ``has_edge(k, key, key)``.</span>
<span class="sd">        opname : str</span>
<span class="sd">            Name of the operator to be used for the string.</span>
<span class="sd">            Useful for the Jordan-Wigner transformation to fermions.</span>
<span class="sd">        skip_existing : bool</span>
<span class="sd">            Whether existing graph nodes should be skipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        label_j : hashable</span>
<span class="sd">            The `key` on the left of site j to connect to. Usually the same as the parameter `key`,</span>
<span class="sd">            except if ``j - i &gt; self.L``, in which case we use the additional labels ``(key, 1)``,</span>
<span class="sd">            ``(key, 2)``, ... to generate couplings over multiple unit cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;j &lt; i not allowed&quot;</span><span class="p">)</span>
        <span class="n">keyL</span> <span class="o">=</span> <span class="n">keyR</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># necessary to extend key because keyL is already in use at this bond</span>
                <span class="n">keyR</span> <span class="o">=</span> <span class="n">keyL</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="n">opname</span><span class="p">)</span>  <span class="c1"># same structure as for other standard keys</span>
                <span class="c1"># (i, op_i, op_str_right_of_i) e.g. in MultiCouplingTerms.add_to_graph</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">keyL</span><span class="p">,</span> <span class="n">keyR</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">keyL</span><span class="p">,</span> <span class="n">keyR</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">check_op</span><span class="o">=</span><span class="n">check_op</span><span class="p">,</span> <span class="n">skip_existing</span><span class="o">=</span><span class="n">skip_existing</span><span class="p">)</span>
            <span class="n">keyL</span> <span class="o">=</span> <span class="n">keyR</span>
        <span class="k">return</span> <span class="n">keyL</span></div>

<div class="viewcode-block" id="MPOGraph.add_missing_IdL_IdR"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.add_missing_IdL_IdR">[docs]</a>    <span class="k">def</span> <span class="nf">add_missing_IdL_IdR</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add missing identity (&#39;Id&#39;) edges connecting ``&#39;IdL&#39;-&gt;&#39;IdL&#39; and ``&#39;IdR&#39;-&gt;&#39;IdR&#39;``.</span>

<span class="sd">        For ``bc=&#39;infinite&#39;``, insert missing identities at *all* bonds.</span>
<span class="sd">        For ``bc=&#39;finite&#39; | &#39;segment&#39;`` only insert</span>
<span class="sd">        ``&#39;IdL&#39;-&gt;&#39;IdL&#39;`` to the left of the rightmost existing &#39;IdL&#39; and</span>
<span class="sd">        ``&#39;IdR&#39;-&gt;&#39;IdR&#39;`` to the right of the leftmost existing &#39;IdR&#39;.</span>

<span class="sd">        This function should be called *after* all other operators have been inserted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="n">max_IdL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>  <span class="c1"># add identities for all sites</span>
            <span class="n">min_IdR</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_IdL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;IdL&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
            <span class="n">min_IdR</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;IdR&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_IdL</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;IdL&#39;</span><span class="p">,</span> <span class="s1">&#39;IdL&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;IdL&#39;</span><span class="p">,</span> <span class="s1">&#39;IdL&#39;</span><span class="p">,</span> <span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_IdR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;IdR&#39;</span><span class="p">,</span> <span class="s1">&#39;IdR&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;IdR&#39;</span><span class="p">,</span> <span class="s1">&#39;IdR&#39;</span><span class="p">,</span> <span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span></div>
        <span class="c1"># done</span>

<div class="viewcode-block" id="MPOGraph.has_edge"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.has_edge">[docs]</a>    <span class="k">def</span> <span class="nf">has_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">keyL</span><span class="p">,</span> <span class="n">keyR</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if there is an edge from `keyL` on bond (i-1, i) to `keyR` on bond (i, i+1).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">keyR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyL</span><span class="p">,</span> <span class="p">[])</span></div>

<div class="viewcode-block" id="MPOGraph.build_MPO"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOGraph.html#tenpy.networks.mpo.MPOGraph.build_MPO">[docs]</a>    <span class="k">def</span> <span class="nf">build_MPO</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">leg0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build the MPO represented by the graph (`self`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ws_qtotal : None | (list of) charges</span>
<span class="sd">            The `qtotal` for each of the Ws to be generated., default (``None``) means 0 charge.</span>
<span class="sd">            A single qtotal holds for each site.</span>
<span class="sd">        leg0 : None | :class:`npc.LegCharge`</span>
<span class="sd">            The charges to be used for the very first leg (which is a gauge freedom).</span>
<span class="sd">            If ``None`` (default), use zeros.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mpo : :class:`MPO`</span>
<span class="sd">            the MPO which self represents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="c1"># pre-work: generate the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ordered_states</span><span class="p">()</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_grids</span><span class="p">()</span>
        <span class="n">IdL</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IdL&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_states</span><span class="p">]</span>
        <span class="n">IdR</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IdR&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_states</span><span class="p">]</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">MPO</span><span class="o">.</span><span class="n">from_grids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">,</span> <span class="n">IdL</span><span class="p">,</span> <span class="n">IdR</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="p">,</span> <span class="n">leg0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_range</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;MPOGraph L=</span><span class="si">{L:d}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;string showing the graph for debug output.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">strs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">keyL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">keyL</span><span class="p">)]</span>
                <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">D</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyL</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">for</span> <span class="n">keyR</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">keyR</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">optuple</span> <span class="ow">in</span> <span class="n">D</span><span class="p">[</span><span class="n">keyR</span><span class="p">]:</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">optuple</span><span class="p">))</span>
                <span class="n">strs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vert_join</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="s1">&#39;|&#39;</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># &amp; states on last MPO bond</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vert_join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">keyR</span><span class="p">)</span> <span class="k">for</span> <span class="n">keyR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">delim</span><span class="o">=</span><span class="s1">&#39; |&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_ordered_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define an ordering of the &#39;states&#39; on each MPO bond.</span>

<span class="sd">        Set ``self._ordered_states`` to a list of dictionaries ``{state: index}``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_mpo_graph_state_order</span><span class="p">)):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;translate the graph dictionaries into grids for the `Ws`.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ordered_states</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># make sure that _set_ordered_states was called</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">stL</span><span class="p">,</span> <span class="n">stR</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># ``{keyL: {keyR: [(opname, strength)]}}``</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">stL</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">keyL</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">stL</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">stR</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">keyR</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">keyL</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">stR</span><span class="p">[</span><span class="n">keyR</span><span class="p">]</span>
                    <span class="n">row</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
            <span class="n">grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grids</span></div>


<div class="viewcode-block" id="MPOEnvironment"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOEnvironment.html#tenpy.networks.mpo.MPOEnvironment">[docs]</a><span class="k">class</span> <span class="nc">MPOEnvironment</span><span class="p">(</span><span class="n">MPSEnvironment</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores partial contractions of :math:`&lt;bra|H|ket&gt;` for an MPO `H`.</span>

<span class="sd">    The network for a contraction :math:`&lt;bra|H|ket&gt;` of an MPO `H` bewteen two MPS looks like::</span>

<span class="sd">        |     .------&gt;-M[0]--&gt;-M[1]--&gt;-M[2]--&gt;- ...  -&gt;--.</span>
<span class="sd">        |     |        |       |       |                 |</span>
<span class="sd">        |     |        ^       ^       ^                 |</span>
<span class="sd">        |     |        |       |       |                 |</span>
<span class="sd">        |     LP[0] -&gt;-W[0]--&gt;-W[1]--&gt;-W[2]--&gt;- ...  -&gt;- RP[-1]</span>
<span class="sd">        |     |        |       |       |                 |</span>
<span class="sd">        |     |        ^       ^       ^                 |</span>
<span class="sd">        |     |        |       |       |                 |</span>
<span class="sd">        |     .------&lt;-N[0]*-&lt;-N[1]*-&lt;-N[2]*-&lt;- ...  -&lt;--.</span>

<span class="sd">    We use the following label convention (where arrows indicate `qconj`)::</span>

<span class="sd">        |    .--&gt;- vR           vL -&gt;-.</span>
<span class="sd">        |    |                        |</span>
<span class="sd">        |    LP-&gt;- wR           wL -&gt;-RP</span>
<span class="sd">        |    |                        |</span>
<span class="sd">        |    .--&lt;- vR*         vL* -&lt;-.</span>

<span class="sd">    To avoid recalculations of the whole network e.g. in the DMRG sweeps,</span>
<span class="sd">    we store the contractions up to some site index in this class.</span>
<span class="sd">    For ``bc=&#39;finite&#39;,&#39;segment&#39;``, the very left and right part ``LP[0]`` and</span>
<span class="sd">    ``RP[-1]`` are trivial and don&#39;t change in the DMRG algorithm,</span>
<span class="sd">    but for iDMRG (``bc=&#39;infinite&#39;``) they are also updated</span>
<span class="sd">    (by inserting another unit cell to the left/right).</span>

<span class="sd">    The MPS `bra` and `ket` have to be in canonical form.</span>
<span class="sd">    All the environments are constructed without the singular values on the open bond.</span>
<span class="sd">    In other words, we contract left-canonical `A` to the left parts `LP`</span>
<span class="sd">    and right-canonical `B` to the right parts `RP`.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bra : :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        The MPS to project on. Should be given in usual &#39;ket&#39; form;</span>
<span class="sd">        we call `conj()` on the matrices directly.</span>
<span class="sd">    H : :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">        The MPO sandwiched between `bra` and `ket`.</span>
<span class="sd">        Should have &#39;IdL&#39; and &#39;IdR&#39; set on the first and last bond.</span>
<span class="sd">    ket : :class:`~tenpy.networks.mpo.MPS`</span>
<span class="sd">        The MPS on which `H` acts. May be identical with `bra`.</span>
<span class="sd">    init_LP : ``None`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        Initial very left part ``LP``. If ``None``, build trivial one with</span>
<span class="sd">        :meth:`~tenpy.networks.mps.MPS.init_LP`.</span>
<span class="sd">    init_RP : ``None`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        Initial very right part ``RP``. If ``None``, build trivial one with</span>
<span class="sd">        :meth:`~tenpy.networks.mps.MPS.init_RP`.</span>
<span class="sd">    age_LP : int</span>
<span class="sd">        The number of physical sites involved into the contraction yielding `firstLP`.</span>
<span class="sd">    age_RP : int</span>
<span class="sd">        The number of physical sites involved into the contraction yielding `lastRP`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    H : :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">        The MPO sandwiched between `bra` and `ket`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">ket</span><span class="p">,</span> <span class="n">init_LP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init_RP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">age_LP</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">age_RP</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ket</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ket</span> <span class="o">=</span> <span class="n">bra</span>
        <span class="k">if</span> <span class="n">ket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bra</span><span class="p">:</span>
            <span class="n">ket</span><span class="o">.</span><span class="n">_gauge_compatible_vL_vR</span><span class="p">(</span><span class="n">bra</span><span class="p">)</span>  <span class="c1"># ensure matching charges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bra</span> <span class="o">=</span> <span class="n">bra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ket</span> <span class="o">=</span> <span class="n">ket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finite</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">finite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">bra</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ket</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP_age</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP_age</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="k">if</span> <span class="n">init_LP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">init_LP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_LP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">init_LP</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age_LP</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_RP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">init_RP</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_RP</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">init_RP</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age_RP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">finite</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">finite</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">finite</span><span class="p">)</span>
        <span class="c1"># check that the network is contractable</span>
        <span class="k">for</span> <span class="n">b_s</span><span class="p">,</span> <span class="n">H_s</span><span class="p">,</span> <span class="n">k_s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="n">b_s</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">k_s</span><span class="o">.</span><span class="n">leg</span><span class="p">)</span>
            <span class="n">b_s</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">H_s</span><span class="o">.</span><span class="n">leg</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">any</span><span class="p">([</span><span class="n">LP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">LP</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">any</span><span class="p">([</span><span class="n">RP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">RP</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span><span class="p">])</span>

<div class="viewcode-block" id="MPOEnvironment.get_LP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOEnvironment.html#tenpy.networks.mpo.MPOEnvironment.get_LP">[docs]</a>    <span class="k">def</span> <span class="nf">get_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate LP at given site from nearest available one (including `i`).</span>

<span class="sd">        The returned ``LP_i`` corresponds to the following contraction,</span>
<span class="sd">        where the M&#39;s and the N&#39;s are in the &#39;A&#39; form::</span>

<span class="sd">            |     .-------M[0]--- ... --M[i-1]---&gt;-   &#39;vR&#39;</span>
<span class="sd">            |     |       |             |</span>
<span class="sd">            |     LP[0]---W[0]--- ... --W[i-1]---&gt;-   &#39;wR&#39;</span>
<span class="sd">            |     |       |             |</span>
<span class="sd">            |     .-------N[0]*-- ... --N[i-1]*--&lt;-   &#39;vR*&#39;</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            The returned `LP` will contain the contraction *strictly* left of site `i`.</span>
<span class="sd">        store : bool</span>
<span class="sd">            Wheter to store the calculated `LP` in `self` (``True``) or discard them (``False``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        LP_i : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Contraction of everything left of site `i`,</span>
<span class="sd">            with labels ``&#39;vR*&#39;, &#39;wR&#39;, &#39;vR&#39;`` for `bra`, `H`, `ket`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># actually same as MPSEnvironment, just updated the labels in the doc string.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_LP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPOEnvironment.get_RP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOEnvironment.html#tenpy.networks.mpo.MPOEnvironment.get_RP">[docs]</a>    <span class="k">def</span> <span class="nf">get_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate RP at given site from nearest available one (including `i`).</span>

<span class="sd">        The returned ``RP_i`` corresponds to the following contraction,</span>
<span class="sd">        where the M&#39;s and the N&#39;s are in the &#39;B&#39; form::</span>

<span class="sd">            |     &#39;vL&#39;  -&gt;---M[i+1]-- ... --M[L-1]----.</span>
<span class="sd">            |                |              |         |</span>
<span class="sd">            |     &#39;wL&#39;  -&gt;---W[i+1]-- ... --W[L-1]----RP[-1]</span>
<span class="sd">            |                |              |         |</span>
<span class="sd">            |     &#39;vL*&#39; -&lt;---N[i+1]*- ... --N[L-1]*---.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            The returned `RP` will contain the contraction *strictly* rigth of site `i`.</span>
<span class="sd">        store : bool</span>
<span class="sd">            Wheter to store the calculated `RP` in `self` (``True``) or discard them (``False``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RP_i : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Contraction of everything right of site `i`,</span>
<span class="sd">            with labels ``&#39;vL*&#39;, &#39;wL&#39;, &#39;vL&#39;`` for `bra`, `H`, `ket`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># actually same as MPSEnvironment, just updated the labels in the doc string.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_RP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPOEnvironment.full_contraction"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.MPOEnvironment.html#tenpy.networks.mpo.MPOEnvironment.full_contraction">[docs]</a>    <span class="k">def</span> <span class="nf">full_contraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the energy by a full contraction of the network.</span>

<span class="sd">        The full contraction of the environments gives the value</span>
<span class="sd">        ``&lt;bra|H|ket&gt; / (norm(|bra&gt;)*norm(|ket&gt;))``,</span>
<span class="sd">        i.e. if `bra` is `ket` and normalized, the total energy.</span>
<span class="sd">        For this purpose, this function contracts</span>
<span class="sd">        ``get_LP(i0+1, store=False)`` and ``get_RP(i0, store=False)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i0 : int</span>
<span class="sd">            Site index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># same as MPSEnvironment.full_contraction, but also contract &#39;wL&#39; with &#39;wR&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">finite</span> <span class="ow">and</span> <span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="c1"># special case to handle `_to_valid_index` correctly:</span>
            <span class="c1"># get_LP(L) is not valid for finite b.c, so we use need to calculate it explicitly.</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_LP</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_LP</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">LP</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_LP</span><span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># multiply with `S`: a bit of a hack: use &#39;private&#39; MPS._scale_axis_B</span>
        <span class="n">S_bra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">_scale_axis_B</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">S_bra</span><span class="p">,</span> <span class="n">form_diff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">axis_B</span><span class="o">=</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
        <span class="c1"># cutoff is not used for form_diff = 1</span>
        <span class="n">S_ket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">_scale_axis_B</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">S_ket</span><span class="p">,</span> <span class="n">form_diff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">axis_B</span><span class="o">=</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_RP</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">npc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]],</span> <span class="n">do_conj</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_contract_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">LP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Contract LP with the tensors on site `i` to form ``self._LP[i+1]``&quot;&quot;&quot;</span>
        <span class="c1"># same as MPSEnvironment._contract_LP, but also contract with `H.get_W(i)`</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">LP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">]))</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span>
                           <span class="n">LP</span><span class="p">,</span>
                           <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">LP</span>  <span class="c1"># labels &#39;vR*&#39;, &#39;wR&#39;, &#39;vR&#39;</span>

    <span class="k">def</span> <span class="nf">_contract_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">RP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Contract RP with the tensors on site `i` to form ``self._RP[i-1]``&quot;&quot;&quot;</span>
        <span class="c1"># same as MPSEnvironment._contract_RP, but also contract with `H.get_W(i)`</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">]))</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span>
                           <span class="n">RP</span><span class="p">,</span>
                           <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">RP</span>  <span class="c1"># labels &#39;vL&#39;, &#39;wL&#39;, &#39;vL*&#39;</span></div>


<div class="viewcode-block" id="grid_insert_ops"><a class="viewcode-back" href="../../../reference/tenpy.networks.mpo.grid_insert_ops.html#tenpy.networks.mpo.grid_insert_ops">[docs]</a><span class="k">def</span> <span class="nf">grid_insert_ops</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replaces entries representing operators in a grid of ``W[i]`` with npc.Arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    site : :class:`~tenpy.networks.site`</span>
<span class="sd">        The site on which the grid acts.</span>
<span class="sd">    grid : list of list of `entries`</span>
<span class="sd">        Represents a single matrix `W` of an MPO, i.e. the lists correspond to the legs</span>
<span class="sd">        ``&#39;vL&#39;, &#39;vR&#39;``, and entries to onsite operators acting on the given `site`.</span>
<span class="sd">        `entries` may be ``None``, :class:`~tenpy.linalg.np_conserved.Array`, a single string</span>
<span class="sd">        or of the form ``[(&#39;opname&#39;, strength), ...]``, where ``&#39;opname&#39;`` labels an operator in</span>
<span class="sd">        the `site`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : list of list of {None | :class:`~tenpy.linalg.np_conserved.Array`}</span>
<span class="sd">        Copy of `grid` with entries ``[(&#39;opname&#39;, strength), ...]`` replaced by</span>
<span class="sd">        ``sum([strength*site.get_op(&#39;opname&#39;) for opname, strength in entry])``</span>
<span class="sd">        and entries ``&#39;opname&#39;`` replaced by ``site.get_op(&#39;opname&#39;)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_grid</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="n">new_row</span> <span class="o">=</span> <span class="n">new_grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">new_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">opname</span><span class="p">,</span> <span class="n">strength</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="n">site</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">opname</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">opname</span><span class="p">,</span> <span class="n">strength</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">strength</span> <span class="o">*</span> <span class="n">site</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">opname</span><span class="p">)</span>
                <span class="n">new_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>  <span class="c1"># replace entry</span>
                <span class="c1"># new_row[j] = sum([strength*site.get_op(opname) for opname, strength in entry])</span>
    <span class="k">return</span> <span class="n">new_grid</span></div>


<span class="k">def</span> <span class="nf">_calc_grid_legs_finite</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="p">,</span> <span class="n">leg0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate LegCharges from `grids` for a finite MPO.</span>

<span class="sd">    This is the easier case. We just gauge the very first leg to the left to zeros,</span>
<span class="sd">    then all other charges (hopefully) follow from the entries of the grid.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">leg0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;finite MPO with len of first bond != 1&quot;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()</span>
        <span class="n">leg0</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">leg0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grids</span><span class="p">):</span>
        <span class="n">gr_legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">legs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">gr_legs</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">detect_grid_outer_legcharge</span><span class="p">(</span><span class="n">gr</span><span class="p">,</span>
                                                  <span class="n">gr_legs</span><span class="p">,</span>
                                                  <span class="n">qtotal</span><span class="o">=</span><span class="n">Ws_qtotal</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                  <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                                  <span class="n">bunch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gr_legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">legs</span>


<span class="k">def</span> <span class="nf">_calc_grid_legs_infinite</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="p">,</span> <span class="n">leg0</span><span class="p">,</span> <span class="n">IdL_0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;calculate LegCharges from `grids` for an iMPO.</span>

<span class="sd">    The hard case. Initially, we do not know all charges of the first leg; and they have to</span>
<span class="sd">    be consistent with the final leg.</span>

<span class="sd">    The way this workso: gauge &#39;IdL&#39; on the very left leg to 0,</span>
<span class="sd">    then gradually calculate the charges by going along the edges of the graph (maybe also over the iMPO boundary).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">leg0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># have charges of first leg: simple case, can use the _calc_grid_legs_finite version.</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="n">_calc_grid_legs_finite</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">grids</span><span class="p">,</span> <span class="n">Ws_qtotal</span><span class="p">,</span> <span class="n">leg0</span><span class="p">)</span>
        <span class="n">legs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># consistent?</span>
        <span class="k">return</span> <span class="n">legs</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>
    <span class="n">chis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">]</span>
    <span class="n">charges</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">chi</span> <span class="k">for</span> <span class="n">chi</span> <span class="ow">in</span> <span class="n">chis</span><span class="p">]</span>
    <span class="n">charges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">charges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># the *same* list is shared for 0 and -1.</span>

    <span class="n">charges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">IdL_0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># default charge = 0.</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">L</span><span class="p">):</span>  <span class="c1"># I don&#39;t expect interactions with larger range than that...</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">QsL</span><span class="p">,</span> <span class="n">QsR</span> <span class="o">=</span> <span class="n">charges</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">vL</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="n">qL</span> <span class="o">=</span> <span class="n">QsL</span><span class="p">[</span><span class="n">vL</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">qL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># don&#39;t know the charge on the left yet</span>
                <span class="k">for</span> <span class="n">vR</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># calculate charge qR from the entry of the grid</span>
                    <span class="n">qR</span> <span class="o">=</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qL</span> <span class="o">+</span> <span class="n">op</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">Ws_qtotal</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">QsR</span><span class="p">[</span><span class="n">vR</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">QsR</span><span class="p">[</span><span class="n">vR</span><span class="p">]</span> <span class="o">=</span> <span class="n">qR</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">QsR</span><span class="p">[</span><span class="n">vR</span><span class="p">]</span> <span class="o">!=</span> <span class="n">qR</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible charges while creating the MPO&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">Qs</span> <span class="ow">in</span> <span class="n">charges</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Qs</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># no `break` in the for loop, i.e. we are unable to determine all grid legcharges.</span>
        <span class="c1"># this should not happen (if we have no bugs), but who knows ^_^</span>
        <span class="c1"># if it happens, there might be unconnected parts in the graph</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t determine LegCharge for the MPO&quot;</span><span class="p">)</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">qflat</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">qflat</span> <span class="ow">in</span> <span class="n">charges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">legs</span>


<span class="k">def</span> <span class="nf">_mpo_graph_state_order</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Key-function for sorting they `states` of an MPO Graph.</span>

<span class="sd">    For standard TeNPy MPOs we expect keys of the form</span>
<span class="sd">    ``&#39;IdL&#39;``, ``&#39;IdR&#39;``, ``(i, op_i, opstr)`` and recursively ``key + (j, op_j, opstr)``,</span>
<span class="sd">    (Note that op_j can be opstr if ``j-i &gt;= L``.)</span>

<span class="sd">    The goal is to ensure that standard TeNPy MPOs yield an upper-right W for the MPO.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;IdL&#39;</span><span class="p">:</span>  <span class="c1"># should be first</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;IdR&#39;</span><span class="p">:</span>  <span class="c1"># should be last</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="p">)</span>
    <span class="c1"># fallback: compare strings</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Tenpy Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Jun 27, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.0.
    </div>
  </body>
</html>