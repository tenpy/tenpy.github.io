
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tenpy.networks.mps &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tenpy.networks.mps</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;This module contains a base class for a Matrix Product State (MPS).</span>

<span class="sd">An MPS looks roughly like this::</span>

<span class="sd">    |   -- B[0] -- B[1] -- B[2] -- ...</span>
<span class="sd">    |       |       |      |</span>

<span class="sd">We use the following label convention for the `B` (where arrows indicate `qconj`)::</span>

<span class="sd">    |  vL -&gt;- B -&gt;- vR</span>
<span class="sd">    |         |</span>
<span class="sd">    |         ^</span>
<span class="sd">    |         p</span>

<span class="sd">We store one 3-leg tensor `_B[i]` with labels ``&#39;vL&#39;, &#39;vR&#39;, &#39;p&#39;`` for each of the `L` sites</span>
<span class="sd">``0 &lt;= i &lt; L``.</span>
<span class="sd">Additionally, we store ``L+1`` singular value arrays `_S[ib]` on each bond ``0 &lt;= ib &lt;= L``,</span>
<span class="sd">independent of the boundary conditions.</span>
<span class="sd">``_S[ib]`` gives the singlur values on the bond ``i-1, i``.</span>
<span class="sd">However, be aware that e.g. :attr:`~tenpy.networks.mps.MPS.chi` returns only the dimensions of the</span>
<span class="sd">:attr:`~tenpy.networks.mps.MPS.nontrivial_bonds` depending on the boundary conditions.</span>

<span class="sd">The matrices and singular values always represent a normalized state</span>
<span class="sd">(i.e. ``np.linalg.norm(psi._S[ib]) == 1`` up to roundoff errors),</span>
<span class="sd">but (for finite MPS) we keep track of the norm in :attr:`~tenpy.networks.mps.MPS.norm`</span>
<span class="sd">(which is respected by :meth:`~tenpy.networks.mps.MPS.overlap`, ...).</span>

<span class="sd">Valid MPS boundary conditions (not to confuse with `bc_coupling` of</span>
<span class="sd">:class:`tenpy.models.model.CouplingModel`)  are the following:</span>

<span class="sd">==========  ===================================================================================</span>
<span class="sd">`bc`        description</span>
<span class="sd">==========  ===================================================================================</span>
<span class="sd">&#39;finite&#39;    Finite MPS, ``G0 s1 G1 ... s{L-1} G{l-1}``. This is acchieved</span>
<span class="sd">            by using a trivial left and right bond ``s[0] = s[-1] = np.array([1.])``.</span>
<span class="sd">&#39;segment&#39;   Generalization of &#39;finite&#39;, describes an MPS embedded in left and right</span>
<span class="sd">            environments. The left environment is described by ``chi[0]`` *orthonormal* states</span>
<span class="sd">            which are weighted by the singular values ``s[0]``. Similar, ``s[L]`` weight some</span>
<span class="sd">            right orthonormal states. You can think of the left and right states to be</span>
<span class="sd">            generated by additional MPS, such that the overall structure is something like</span>
<span class="sd">            ``... s L s L [s0 G0 s1 G1 ... s{L-1} G{L-1} s{L}] R s R s R ...``</span>
<span class="sd">            (where we save the part in the brackets ``[ ... ]`` ).</span>
<span class="sd">&#39;infinite&#39;  infinite MPS (iMPS): we save a &#39;MPS unit cell&#39; ``[s0 G0 s1 G1 ... s{L-1} G{L-1}]``</span>
<span class="sd">            which is repeated periodically, identifying all indices modulo ``self.L``.</span>
<span class="sd">            In particular, the last bond ``L`` is identified with ``0``.</span>
<span class="sd">            (The MPS unit cell can differ from a lattice unit cell).</span>
<span class="sd">            bond is identified with the first one.</span>
<span class="sd">==========  ===================================================================================</span>

<span class="sd">An MPS can be in different &#39;canonical forms&#39; (see [Vidal2004]_, [Schollwoeck2011]_).</span>
<span class="sd">To take care of the different canonical forms, algorithms should use functions like</span>
<span class="sd">:meth:`~tenpy.networks.mps.MPS.get_theta`, :meth:`~tenpy.networks.mps.MPS.get_B`</span>
<span class="sd">and :meth:`~tenpy.networks.mps.MPS.set_B` instead of accessing them directly,</span>
<span class="sd">as they return the `B` in the desired form (which can be chosen as an argument).</span>
<span class="sd">The values of the tuples for the form correspond to the exponent of the singular values</span>
<span class="sd">on the left and right.</span>
<span class="sd">To keep track of a &quot;mixed&quot; canonical form ``A A A s B B``, we save the tuples for each</span>
<span class="sd">site of the MPS in :attr:`MPS.form`.</span>

<span class="sd">======== ========== ==========================================================================</span>
<span class="sd">`form`   tuple      description</span>
<span class="sd">======== ========== ==========================================================================</span>
<span class="sd">``&#39;B&#39;``  (0, 1)     right canonical: ``_B[i] = -- Gamma[i] -- s[i+1]--``</span>
<span class="sd">                    The default form, which algorithms asssume.</span>
<span class="sd">``&#39;C&#39;``  (0.5, 0.5) symmetric form: ``_B[i] = -- s[i]**0.5 -- Gamma[i] -- s[i+1]**0.5--``</span>
<span class="sd">``&#39;A&#39;``  (1, 0)     left canonical: ``_B[i] = -- s[i] -- Gamma[i] --``.</span>
<span class="sd">``&#39;G&#39;``  (0, 0)     Save only ``_B[i] = -- Gamma[i] --``.</span>
<span class="sd">``&#39;Th&#39;`` (1, 1)     Form of a local wave function `theta` with singular value on both sides.</span>
<span class="sd">                    ``psi.get_B(i, &#39;Th&#39;) is equivalent to ``psi.get_theta(i, n=1)``.</span>
<span class="sd">``None`` ``None``   General non-canoncial form.</span>
<span class="sd">                    Valid form for initialization, but you need to call</span>
<span class="sd">                    :meth:`~tenpy.networks.mps.MPS.canonical_form` (or similar)</span>
<span class="sd">                    before using algorithms.</span>
<span class="sd">======== ========== ==========================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg.eigen.arpack</span>

<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">np_conserved</span> <span class="k">as</span> <span class="n">npc</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">.site</span> <span class="k">import</span> <span class="n">GroupedSite</span><span class="p">,</span> <span class="n">group_sites</span>
<span class="kn">from</span> <span class="nn">..tools.misc</span> <span class="k">import</span> <span class="n">to_iterable</span><span class="p">,</span> <span class="n">argsort</span>
<span class="kn">from</span> <span class="nn">..tools.math</span> <span class="k">import</span> <span class="n">lcm</span><span class="p">,</span> <span class="n">speigs</span><span class="p">,</span> <span class="n">entropy</span>
<span class="kn">from</span> <span class="nn">..algorithms.truncation</span> <span class="k">import</span> <span class="n">TruncationError</span><span class="p">,</span> <span class="n">svd_theta</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MPS&#39;</span><span class="p">,</span> <span class="s1">&#39;MPSEnvironment&#39;</span><span class="p">,</span> <span class="s1">&#39;TransferMatrix&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="MPS"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS">[docs]</a><span class="k">class</span> <span class="nc">MPS</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A Matrix Product State, finite (MPS) or infinite (iMPS).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        Defines the local Hilbert space for each site.</span>
<span class="sd">    Bs : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        The &#39;matrices&#39; of the MPS. Labels are ``vL, vR, p`` (in any order).</span>
<span class="sd">    SVs : list of 1D array</span>
<span class="sd">        The singular values on *each* bond. Should always have length `L+1`.</span>
<span class="sd">        Entries out of :attr:`nontrivial_bonds` are ignored.</span>
<span class="sd">    bc : ``&#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;``</span>
<span class="sd">        Boundary conditions as described in the tabel of the module doc-string.</span>
<span class="sd">    form : (list of) {``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | &#39;Th&#39; | None`` | tuple(float, float)}</span>
<span class="sd">        The form of the stored &#39;matrices&#39;, see table in module doc-string.</span>
<span class="sd">        A single choice holds for all of the entries.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    L</span>
<span class="sd">    chi</span>
<span class="sd">    finite</span>
<span class="sd">    nontrivial_bonds</span>
<span class="sd">    sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        Defines the local Hilbert space for each site.</span>
<span class="sd">    bc : {&#39;finite&#39;, &#39;segment&#39;, &#39;infinite&#39;}</span>
<span class="sd">        Boundary conditions as described in above table.</span>
<span class="sd">    form : list of {``None`` | tuple(float, float)}</span>
<span class="sd">        Describes the canonical form on each site.</span>
<span class="sd">        ``None`` means non-canonical form.</span>
<span class="sd">        For ``form = (nuL, nuR)``, the stored ``_B[i]`` are</span>
<span class="sd">        ``s**form[0] -- Gamma -- s**form[1]`` (in Vidal&#39;s notation).</span>
<span class="sd">    chinfo : :class:`~tenpy.linalg.np_conserved.ChargeInfo`</span>
<span class="sd">        The nature of the charge.</span>
<span class="sd">    dtype : type</span>
<span class="sd">        The data type of the ``_B``.</span>
<span class="sd">    norm : float</span>
<span class="sd">        The norm of the state, i.e. ``sqrt(&lt;psi|psi&gt;)``.</span>
<span class="sd">        Ignored for (normalized) :meth:`expectation_value`, but important for :meth:`overlap`.</span>
<span class="sd">    grouped : int</span>
<span class="sd">        Number of sites grouped together, see :meth:`group_sites`.</span>
<span class="sd">    _B : list of :class:`npc.Array`</span>
<span class="sd">        The &#39;matrices&#39; of the MPS. Labels are ``vL, vR, p`` (in any order).</span>
<span class="sd">        We recommend using :meth:`get_B` and :meth:`set_B`, which will take care of the different</span>
<span class="sd">        canonical forms.</span>
<span class="sd">    _S : list of (``None`` | 1D array)</span>
<span class="sd">        The singular values on each virtual bond, length ``L+1``.</span>
<span class="sd">        May be ``None`` if the MPS is not in canonical form.</span>
<span class="sd">        Otherwise, ``_S[i]`` is to the left of ``_B[i]``.</span>
<span class="sd">        We recommend using :meth:`get_SL`, :meth:`get_SR`, :meth:`set_SL`, :meth:`set_SR`, which</span>
<span class="sd">        takes proper care of the boundary conditions.</span>
<span class="sd">    _valid_forms : dict</span>
<span class="sd">        Mapping for canonical forms to a tuple ``(nuL, nuR)`` indicating that</span>
<span class="sd">        ``self._Bs[i] = s[i]**nuL -- Gamma[i] -- s[i]**nuR`` is saved.</span>
<span class="sd">    _valid_bc : tuple of str</span>
<span class="sd">        Valid boundary conditions.</span>
<span class="sd">    _transfermatrix_keep : int</span>
<span class="sd">        How many states to keep at least when diagonalizing a :class:`TransferMatrix`.</span>
<span class="sd">        Important if the state develops a near-degeneracy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Canonical form conventions: the saved B = s**nu[0]--Gamma--s**nu[1].</span>
    <span class="c1"># For the canonical forms, ``nu[0] + nu[1] = 1``</span>
    <span class="n">_valid_forms</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>
        <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
        <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span>
        <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>  <span class="c1"># like Vidal&#39;s `Gamma`.</span>
        <span class="s1">&#39;Th&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span>
        <span class="kc">None</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># means &#39;not in any canonical form&#39;</span>
    <span class="p">}</span>

    <span class="c1"># valid boundary conditions. Don&#39;t overwrite this!</span>
    <span class="n">_valid_bc</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="s1">&#39;infinite&#39;</span><span class="p">)</span>
    <span class="c1"># the &quot;physical&quot; labels for each B</span>
    <span class="n">_p_label</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
    <span class="n">_p_label_star</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">]</span>
    <span class="c1"># All labels of each tensor in _B (order is used!)</span>
    <span class="n">_B_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">SVs</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">B</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">Bs</span><span class="p">],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_form</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">bc</span>  <span class="c1"># one of ``&#39;finite&#39;, &#39;periodic&#39;, &#39;segment&#39;``.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># make copies of Bs and SVs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">)</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">Bs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">nontrivial_bonds</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SVs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfermatrix_keep</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>

<div class="viewcode-block" id="MPS.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity check. Raises Errors if something is wrong.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_bc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid boundary condition: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of self._B&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of self._S&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">B</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;B has wrong labels </span><span class="si">{0!r}</span><span class="s2">, expected </span><span class="si">{1!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">B</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span> <span class="ow">or</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">B</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ind_len</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape of B incompatible with len of singular values&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                <span class="n">B2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span>
                <span class="n">B</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="n">B2</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;non-trivial outer bonds for finite MPS&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;iMPS with S[0] != S[L]&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="MPS.from_product_state"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.from_product_state">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_product_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                           <span class="n">sites</span><span class="p">,</span>
                           <span class="n">p_state</span><span class="p">,</span>
                           <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                           <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span>
                           <span class="n">chargeL</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a matrix product state from a given product state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            The sites defining the local Hilbert space.</span>
<span class="sd">        p_state : iterable of {int | str | 1D array}</span>
<span class="sd">            Defines the product state to be represented.</span>
<span class="sd">            If ``p_state[i]`` is str, then site ``i`` is in state</span>
<span class="sd">            ``self.sites[i].state_labels(p_state[i])``.</span>
<span class="sd">            If ``p_state[i]`` is int, then site ``i`` is in state ``p_state[i]``.</span>
<span class="sd">            If ``p_state[i]`` is an array, then site ``i`` wavefunction is ``p_state[i]``.</span>
<span class="sd">        bc : {&#39;infinite&#39;, &#39;finite&#39;, &#39;segmemt&#39;}</span>
<span class="sd">            MPS boundary conditions. See docstring of :class:`MPS`.</span>
<span class="sd">        dtype : type or string</span>
<span class="sd">            The data type of the array entries.</span>
<span class="sd">        permute : bool</span>
<span class="sd">            The :class:`~tenpy.networks.Site` might permute the local basis states if charge</span>
<span class="sd">            conservation gets enabled.</span>
<span class="sd">            If `permute` is True (default), we permute the given `p_state` locally according to</span>
<span class="sd">            each site&#39;s :attr:`~tenpy.networks.Site.perm`.</span>
<span class="sd">            The `p_state` argument should then always be given as if `conserve=None` in the Site.</span>
<span class="sd">        form : (list of) {``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | None`` | tuple(float, float)}</span>
<span class="sd">            Defines the canonical form. See module doc-string.</span>
<span class="sd">            A single choice holds for all of the entries.</span>
<span class="sd">        chargeL : charges</span>
<span class="sd">            Leg charge at bond 0, which are purely conventional.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        product_mps : :class:`MPS`</span>
<span class="sd">            An MPS representing the specified product state.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To get a Neel state:</span>

<span class="sd">        &gt;&gt;&gt; M = SpinChain(model_params)</span>
<span class="sd">        &gt;&gt;&gt; p_state = [&quot;up&quot;, &quot;down&quot;]*(L//2)  # repeats entries L/2 times</span>
<span class="sd">        &gt;&gt;&gt; psi = MPS.from_product_state(M.lat.mps_sites(), p_state, bc=M.lat.bc_MPS)</span>

<span class="sd">        For Spin S=1/2, you could get a state with all sites pointing in negative x-direction with:</span>

<span class="sd">        &gt;&gt;&gt; neg_x_state = np.array([1., -1.])</span>
<span class="sd">        &gt;&gt;&gt; p_state = [neg_x_state/np.linalg.norm(neg_x_state)]*L  # other parameters as above</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">p_state</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_state</span><span class="p">)</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of p_state does not match number of sites.&quot;</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chargeL</span> <span class="o">=</span> <span class="n">ci</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">chargeL</span><span class="p">)</span>  <span class="c1"># sets to zero if `None`</span>
        <span class="n">legL</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="p">[</span><span class="n">chargeL</span><span class="p">])</span>  <span class="c1"># (no need to bunch)</span>
        <span class="k">for</span> <span class="n">p_st</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p_state</span><span class="p">,</span> <span class="n">sites</span><span class="p">):</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">permute</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p_st</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">p_st</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">state_labels</span><span class="p">[</span><span class="n">p_st</span><span class="p">]</span>  <span class="c1"># translate labels into &quot;int&quot;</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">p_st</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_st</span><span class="p">)</span> <span class="o">!=</span> <span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;p_state incompatible with local dim:&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p_st</span><span class="p">))</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_st</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># just an int for p_st</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
                <span class="n">B</span><span class="p">[</span><span class="n">p_st</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">perm</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">perm</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">Bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">SVs</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_Bflat</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">SVs</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">legL</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.from_Bflat"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.from_Bflat">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_Bflat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">Bflat</span><span class="p">,</span> <span class="n">SVs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">legL</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a matrix product state from a set of numpy arrays `Bflat` and singular vals.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            The sites defining the local Hilbert space.</span>
<span class="sd">        Bflat : iterable of numpy ndarrays</span>
<span class="sd">            The matrix defining the MPS on each site, with legs ``&#39;p&#39;, &#39;vL&#39;, &#39;vR&#39;``</span>
<span class="sd">            (physical, virtual left/right).</span>
<span class="sd">        SVs : list of 1D array | ``None``</span>
<span class="sd">            The singular values on *each* bond. Should always have length `L+1`.</span>
<span class="sd">            By default (``None``), set all singular values to the same value.</span>
<span class="sd">            Entries out of :attr:`nontrivial_bonds` are ignored.</span>
<span class="sd">        bc : {&#39;infinite&#39;, &#39;finite&#39;, &#39;segmemt&#39;}</span>
<span class="sd">            MPS boundary conditions. See docstring of :class:`MPS`.</span>
<span class="sd">        dtype : type or string</span>
<span class="sd">            The data type of the array entries. Defaults to the common dtype of `Bflat`.</span>
<span class="sd">        permute : bool</span>
<span class="sd">            The :class:`~tenpy.networks.Site` might permute the local basis states if charge</span>
<span class="sd">            conservation gets enabled.</span>
<span class="sd">            If `permute` is True (default), we permute the given `Bflat` locally according to</span>
<span class="sd">            each site&#39;s :attr:`~tenpy.networks.Site.perm`.</span>
<span class="sd">            The `p_state` argument should then always be given as if `conserve=None` in the Site.</span>
<span class="sd">        form : (list of) {``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | None`` | tuple(float, float)}</span>
<span class="sd">            Defines the canonical form of `Bflat`. See module doc-string.</span>
<span class="sd">            A single choice holds for all of the entries.</span>
<span class="sd">        leg_L : LegCharge | ``None``</span>
<span class="sd">            Leg charges at bond 0, which are purely conventional.</span>
<span class="sd">            If ``None``, use trivial charges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mps : :class:`MPS`</span>
<span class="sd">            An MPS with the matrices `Bflat` converted to npc arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">Bflat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Bflat</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Bflat</span><span class="p">)</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of Bflat does not match number of sites.&quot;</span><span class="p">)</span>
        <span class="n">ci</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="k">if</span> <span class="n">legL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">legL</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span> <span class="p">[</span><span class="n">ci</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">Bflat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">legL</span> <span class="o">=</span> <span class="n">legL</span><span class="o">.</span><span class="n">bunch</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">SVs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">SVs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">Bflat</span><span class="p">]</span>
            <span class="n">SVs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Bflat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Bflat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="o">*</span><span class="n">Bflat</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sites</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Bflat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">permute</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">perm</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="c1"># calculate the LegCharge of the right leg</span>
            <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="p">,</span> <span class="n">legL</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>  <span class="c1"># other legs are known</span>
            <span class="n">legs</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">detect_legcharge</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">ci</span><span class="p">,</span> <span class="n">legs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">legs</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">B</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
            <span class="n">Bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">legL</span> <span class="o">=</span> <span class="n">legs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>  <span class="c1"># prepare for next `i`</span>
        <span class="k">if</span> <span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="c1"># for an iMPS, the last leg has to match the first one.</span>
            <span class="c1"># so we need to gauge `qtotal` of the last `B` such that the right leg matches.</span>
            <span class="n">chdiff</span> <span class="o">=</span> <span class="n">Bs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Bs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Bs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Bs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">gauge_total_charge</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">ci</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">chdiff</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">SVs</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.from_full"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.from_full">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_full</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.e-16</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct an MPS from a single tensor `psi` with one leg per physical site.</span>

<span class="sd">        Performs a sequence of SVDs of psi to split off the `B` matrices and obtain the singular</span>
<span class="sd">        values, the result will be in canonical form.</span>
<span class="sd">        Obviously, this is only well-defined for `finite` boundary conditions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            The sites defining the local Hilbert space.</span>
<span class="sd">        psi : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The full wave function to be represented as an MPS.</span>
<span class="sd">            Should have labels ``&#39;p0&#39;, &#39;p1&#39;, ...,  &#39;p{L-1}&#39;``.</span>
<span class="sd">        form  : ``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39;``</span>
<span class="sd">            The canonical form of the resulting MPS, see module doc-string.</span>
<span class="sd">        cutoff : float</span>
<span class="sd">            Cutoff of singular values used in the SVDs.</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            Whether the resulting MPS should have &#39;norm&#39; 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        psi_mps : :class:`MPS`</span>
<span class="sd">            MPS representation of `psi`, in canonical form and possibly normalized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">form</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid form: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">form</span><span class="p">))</span>
        <span class="c1"># perform SVDs to bring it into &#39;B&#39; form, afterwards change the form.</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">L</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">B_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="n">S_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="n">normalize</span> <span class="k">else</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>
        <span class="n">psi</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="c1"># combine legs from left</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">add_trivial_leg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># combines the legs until `i`</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">add_trivial_leg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># now psi has only three legs: ``&#39;(((vL.p0).p1)...p{L-2})&#39;, &#39;p{L-1}&#39;, &#39;vR&#39;``</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># split off B[i]</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
            <span class="n">psi</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">],</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c1"># normalize</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">B_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span>
            <span class="n">S_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
            <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
        <span class="n">psi</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span>
            <span class="n">psi</span><span class="p">,</span> <span class="n">qtotal_LR</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">psi</span><span class="o">.</span><span class="n">qtotal</span><span class="p">],</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">],</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">S_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">B_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">B_list</span><span class="p">,</span> <span class="n">S_list</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">form</span> <span class="o">!=</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">convert_form</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="MPS.from_singlets"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.from_singlets">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_singlets</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                      <span class="n">site</span><span class="p">,</span>
                      <span class="n">L</span><span class="p">,</span>
                      <span class="n">pairs</span><span class="p">,</span>
                      <span class="n">up</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">,</span>
                      <span class="n">down</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">,</span>
                      <span class="n">lonely</span><span class="o">=</span><span class="p">[],</span>
                      <span class="n">lonely_state</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">,</span>
                      <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an MPS of entangled singlets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        site : :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            The `site` defining the local Hilbert space, taken uniformly for all sites.</span>
<span class="sd">        L : int</span>
<span class="sd">            The number of sites.</span>
<span class="sd">        pairs : list of (int, int)</span>
<span class="sd">            Pairs of sites to be entangled; the returned MPS will have a singlet</span>
<span class="sd">            for each pair in `pairs`.</span>
<span class="sd">        up, down : int | str</span>
<span class="sd">            A singlet is defined as ``(|up down&gt; - |down up&gt;)/2**0.5``,</span>
<span class="sd">            ``up`` and ``down`` give state indices or labels defined on the corresponding site.</span>
<span class="sd">        lonely : list of int</span>
<span class="sd">            Sites which are not included into a singlet pair.</span>
<span class="sd">        lonely_state : int | str</span>
<span class="sd">            The state for the lonely sites.</span>
<span class="sd">        bc : {&#39;infinite&#39;, &#39;finite&#39;, &#39;segmemt&#39;}</span>
<span class="sd">            MPS boundary conditions. See docstring of :class:`MPS`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        singlet_mps : :class:`MPS`</span>
<span class="sd">            An MPS representing singlets on the specified pairs of sites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort each pair s.t. i &lt; j</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="k">else</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
        <span class="c1"># sort by smaller site of the pair</span>
        <span class="n">pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
        <span class="n">lonely</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lonely</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">L</span><span class="p">]</span>
        <span class="c1"># generate building block tensors</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">state_index</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">state_index</span><span class="p">(</span><span class="n">down</span><span class="p">)</span>
        <span class="n">lonely_state</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">state_index</span><span class="p">(</span><span class="n">lonely_state</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Open</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="p">)[:,</span> <span class="n">mask</span><span class="p">]</span>
        <span class="n">Close</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="n">Close</span><span class="p">[</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">Close</span><span class="p">[</span><span class="n">down</span><span class="p">,</span> <span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">Close</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray</span><span class="p">(</span><span class="n">Close</span><span class="p">,</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="p">])</span>  <span class="c1"># no conj() !</span>
        <span class="n">Close</span> <span class="o">=</span> <span class="n">Close</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">eye_like</span><span class="p">(</span><span class="n">Close</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Lonely</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="n">Lonely</span><span class="p">[</span><span class="n">lonely_state</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Lonely</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray</span><span class="p">(</span><span class="n">Lonely</span><span class="p">,</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="p">])</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Ss</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">forms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">open_singlets</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the k-th open singlet should be closed at site open_singlets[k]</span>
        <span class="n">Ts</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the tensors on the current site</span>
        <span class="n">labels_L</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">labels_R</span> <span class="o">=</span> <span class="n">labels_L</span><span class="p">[:]</span>
            <span class="n">next_Ts</span> <span class="o">=</span> <span class="n">Ts</span><span class="p">[:]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># open a new singlet</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">lbl</span> <span class="o">=</span> <span class="s1">&#39;s</span><span class="si">{0:d}</span><span class="s1">-</span><span class="si">{1:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">open_singlets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">next_Ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Id</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">lbl</span><span class="p">]))</span>
                <span class="n">Open</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">lbl</span><span class="p">])</span>
                <span class="n">Ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Open</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="n">labels_R</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
                <span class="n">forms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">lonely</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># just a lonely state</span>
                <span class="n">Ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lonely</span><span class="p">)</span>
                <span class="n">lonely</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">forms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># close a singlet</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">open_singlets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">Close</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="n">labels_L</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
                <span class="n">Ts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Close</span>
                <span class="n">next_Ts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">open_singlets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">labels_R</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">forms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="c1"># generate `B` from `Ts`</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">Ts</span><span class="p">)</span>
            <span class="n">labels_L</span> <span class="o">=</span> <span class="p">[</span><span class="n">lbl_</span> <span class="o">+</span> <span class="s1">&#39;L&#39;</span> <span class="k">for</span> <span class="n">lbl_</span> <span class="ow">in</span> <span class="n">labels_L</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_L</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_R</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="n">labels_L</span><span class="p">,</span> <span class="n">labels_R</span><span class="p">],</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">B</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">add_trivial_leg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">add_trivial_leg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">B</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="n">labels_R</span><span class="p">],</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">B</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">add_trivial_leg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># len(labels_R) == 0</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="n">labels_L</span><span class="p">],</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">B</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">add_trivial_leg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_R</span><span class="p">)</span>
            <span class="n">Ss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">Ts</span> <span class="o">=</span> <span class="n">next_Ts</span>
            <span class="n">labels_L</span> <span class="o">=</span> <span class="n">labels_R</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">([</span><span class="n">site</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">Ss</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">forms</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.copy"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a copy of `self`.</span>

<span class="sd">        The copy still shares the sites, chinfo, and LegCharges of the B tensors,</span>
<span class="sd">        but the values of B and S are deeply copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># __init__ makes deep copies of B, S</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">MPS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">_transfermatrix_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transfermatrix_keep</span>
        <span class="k">return</span> <span class="n">cp</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">L</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of physical sites. For an iMPS the len of the MPS unit cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of local physical dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Distinguish MPS (``True; bc=&#39;finite&#39;, &#39;segment&#39;`` ) vs. iMPS (``False; bc=&#39;infinite&#39;``)&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_bc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">!=</span> <span class="s1">&#39;infinite&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensions of the (nontrivial) virtual bonds.&quot;&quot;&quot;</span>
        <span class="c1"># s.shape[0] == len(s) for 1D numpy array, but works also for a 2D npc Array.</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nontrivial_bonds</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nontrivial_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice of the non-trivial bond indices, depending on ``self.bc``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

<div class="viewcode-block" id="MPS.get_B"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_B">[docs]</a>    <span class="k">def</span> <span class="nf">get_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.e-16</span><span class="p">,</span> <span class="n">label_p</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return (view of) `B` at site `i` in canonical form.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Index choosing the site.</span>
<span class="sd">        form : ``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | &#39;Th&#39; | None`` | tuple(float, float)</span>
<span class="sd">            The (canonical) form of the returned B.</span>
<span class="sd">            For ``None``, return the matrix in whatever form it is.</span>
<span class="sd">            If any of the tuple entry is None, also don&#39;t scale on the corresponding axis.</span>
<span class="sd">        copy : bool</span>
<span class="sd">            Whether to return a copy even if `form` matches the current form.</span>
<span class="sd">        cutoff : float</span>
<span class="sd">            During DMRG with a mixer, `S` may be a matrix for which we need the inverse.</span>
<span class="sd">            This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the</span>
<span class="sd">            singular values.</span>
<span class="sd">        label_p : None | str</span>
<span class="sd">            Ignored by default (``None``).</span>
<span class="sd">            Otherwise replace the physical label ``&#39;p&#39;`` with ``&#39;p&#39;+label_p&#39;``.</span>
<span class="sd">            (For derived classes with more than one &quot;physical&quot; leg, replace all the physical leg</span>
<span class="sd">            labels accordingly.)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        B : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The MPS &#39;matrix&#39; `B` at site `i` with leg labels ``&#39;vL&#39;, &#39;p&#39;, &#39;vR&#39;``.</span>
<span class="sd">            May be a view of the matrix (if ``copy=False``),</span>
<span class="sd">            or a copy (if the form changed or ``copy=True``).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if self is not in canoncial form and `form` is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">new_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_form</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="n">old_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">new_form</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">old_form</span> <span class="o">!=</span> <span class="n">new_form</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_form</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t convert form of non-canonical state!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_form</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_form</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_form</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_axis_B</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">new_form</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_form</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_form</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">new_form</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_form</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_axis_B</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">new_form</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_form</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label_p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_p_label</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">label_p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="MPS.set_B"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.set_B">[docs]</a>    <span class="k">def</span> <span class="nf">set_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set `B` at site `i`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Index choosing the site.</span>
<span class="sd">        B : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The &#39;matrix&#39; at site `i`. No copy is made!</span>
<span class="sd">            Should have leg labels ``&#39;vL&#39;, &#39;p&#39;, &#39;vR&#39;`` (not necessarily in that order).</span>
<span class="sd">        form : ``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | &#39;Th&#39; | None`` | tuple(float, float)</span>
<span class="sd">            The (canonical) form of the `B` to set.</span>
<span class="sd">            ``None`` stands for non-canonical form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_form</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.get_SL"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_SL">[docs]</a>    <span class="k">def</span> <span class="nf">get_SL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return singular values on the left of site `i`&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="MPS.get_SR"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_SR">[docs]</a>    <span class="k">def</span> <span class="nf">get_SR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return singular values on the right of site `i`&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="MPS.set_SL"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.set_SL">[docs]</a>    <span class="k">def</span> <span class="nf">set_SL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set singular values on the left of site `i`&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span></div>

<div class="viewcode-block" id="MPS.set_SR"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.set_SR">[docs]</a>    <span class="k">def</span> <span class="nf">set_SR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set singular values on the right of site `i`&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span></div>

<div class="viewcode-block" id="MPS.get_op"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_op">[docs]</a>    <span class="k">def</span> <span class="nf">get_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_list</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a list of operators, select the one corresponding to site `i`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op_list : (list of) {str | npc.array}</span>
<span class="sd">            List of operators from which we choose. We assume that ``op_list[j]`` acts on site</span>
<span class="sd">            ``j``. If the length is shorter than `L`, we repeat it periodically.</span>
<span class="sd">            Strings are translated using :meth:`~tenpy.networks.site.Site.get_op` of site `i`.</span>
<span class="sd">        i : int</span>
<span class="sd">            Index of the site on which the operator acts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        op : npc.array</span>
<span class="sd">            One of the entries in `op_list`, not copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op_list</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">op_list</span><span class="p">)]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div>

<div class="viewcode-block" id="MPS.get_theta"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_theta">[docs]</a>    <span class="k">def</span> <span class="nf">get_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.e-16</span><span class="p">,</span> <span class="n">formL</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">formR</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the `n`-site wavefunction on ``sites[i:i+n]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Site index.</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of sites. The result lives on ``sites[i:i+n]``.</span>
<span class="sd">        cutoff : float</span>
<span class="sd">            During DMRG with a mixer, `S` may be a matrix for which we need the inverse.</span>
<span class="sd">            This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the</span>
<span class="sd">            singular values.</span>
<span class="sd">        formL : float</span>
<span class="sd">            Exponent for the singular values to the left.</span>
<span class="sd">        formR : float</span>
<span class="sd">            Exponent for the singular values to the right.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        theta : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The n-site wave function with leg labels ``vL, p0, p1, .... p{n-1}, vR``.</span>
<span class="sd">            In Vidal&#39;s notation (with s=lambda, G=Gamma):</span>
<span class="sd">            ``theta = s**form_L G_i s G_{i+1} s ... G_{i+n-1} s**form_R``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="n">j</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t calculate theta for non-canonical form&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
        <span class="c1"># n &gt;= 2: contract some B&#39;s</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">formL</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># right form as stored</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">old_fR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>  <span class="c1"># non-empty range</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
            <span class="n">new_fR</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">formR</span>  <span class="c1"># right form as stored, except for last B</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">old_fR</span><span class="p">,</span> <span class="n">new_fR</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">old_fR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="MPS.convert_form"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.convert_form">[docs]</a>    <span class="k">def</span> <span class="nf">convert_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tranform self into different canonical form (by scaling the legs with singular values).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_form : (list of) {``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | &#39;Th&#39; | None`` | tuple(float, float)}</span>
<span class="sd">            The form the stored &#39;matrices&#39;. The table in module doc-string.</span>
<span class="sd">            A single choice holds for all of the entries.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if trying to convert from a ``None`` form. Use :meth:`canonical_form` instead!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_forms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_form</span><span class="p">(</span><span class="n">new_form</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">new_form</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_forms</span><span class="p">):</span>
            <span class="n">new_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">new_form</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># calculates the desired form.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_B</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">new_form</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.init_LP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.init_LP">[docs]</a>    <span class="k">def</span> <span class="nf">init_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bra</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mpo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build initial left part ``LP`` for an MPS/MPOEnvironment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Build ``LP`` left of site `i`.</span>
<span class="sd">        bra : :class:`MPS`</span>
<span class="sd">            Check leg compatiblity with a `bra`. Note that the returned `init_LP` will</span>
<span class="sd">            only be the contraction for the ``LP`` of  ``&lt;bra|self&gt;`` on the left most site `i` = 0</span>
<span class="sd">            of a finite MPS.</span>
<span class="sd">        mpo : None | :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">            If given, add a leg for the MPO. Requires the `MPO.IdL` on site `i` to be set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        init_LP : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Identity contractible with the `vL` leg of ``self.get_B(i)``, labels ``&#39;vR*&#39;, &#39;vR&#39;``.</span>
<span class="sd">            If `mpo` is given, multiplied with a unit vector nonzero in ``mpo.IdL[i]``,</span>
<span class="sd">            with labels ``&#39;vR*&#39;, &#39;wR&#39;, &#39;vR&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">leg_ket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leg_bra</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span>
            <span class="n">leg_ket</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">leg_bra</span><span class="p">)</span>
        <span class="n">init_LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">leg_ket</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">init_LP</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mpo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leg_mpo</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">IdL</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">get_IdL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">init_LP</span> <span class="o">=</span> <span class="n">init_LP</span><span class="o">.</span><span class="n">add_leg</span><span class="p">(</span><span class="n">leg_mpo</span><span class="p">,</span> <span class="n">IdL</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;wR&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init_LP</span></div>

<div class="viewcode-block" id="MPS.init_RP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.init_RP">[docs]</a>    <span class="k">def</span> <span class="nf">init_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bra</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mpo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build initial right part ``RP`` for an MPS/MPOEnvironment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Build ``RP`` rigth of site `i`.</span>
<span class="sd">        bra : :class:`MPS`</span>
<span class="sd">            Check leg compatiblity with a `bra`. Note that the returned `init_RP` will</span>
<span class="sd">            only be the contraction for the ``RP`` of  ``&lt;bra|self&gt;`` on the right most site</span>
<span class="sd">            `i` = L - 1 of a finite MPS.</span>
<span class="sd">        mpo : None | :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">            If given, add a leg for the MPO. Requires the `MPO.IdR` on site `i` to be set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        init_RP : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Identity contractible with the `vR` leg of ``self.get_B(i)``, labels ``&#39;vL*&#39;, &#39;vL&#39;``.</span>
<span class="sd">            If `mpo` is given, multiplied with a unit vector nonzero in ``mpo.IdR[i]``,</span>
<span class="sd">            with labels ``&#39;vL*&#39;, &#39;wL&#39;, &#39;vL&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">leg_ket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bra</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leg_bra</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span>
            <span class="n">leg_ket</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">leg_bra</span><span class="p">)</span>
        <span class="n">init_RP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">leg_ket</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">init_RP</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mpo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leg_mpo</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;wR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">IdR</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">get_IdR</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">init_RP</span> <span class="o">=</span> <span class="n">init_RP</span><span class="o">.</span><span class="n">add_leg</span><span class="p">(</span><span class="n">leg_mpo</span><span class="p">,</span> <span class="n">IdR</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;wL&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init_RP</span></div>

<div class="viewcode-block" id="MPS.group_sites"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.group_sites">[docs]</a>    <span class="k">def</span> <span class="nf">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify `self` inplace to group sites.</span>

<span class="sd">        Group each `n` sites together using the :class:`~tenpy.networks.site.GroupedSite`.</span>
<span class="sd">        This might allow to do TEBD with a Trotter decomposition,</span>
<span class="sd">        or help the convergence of DMRG (in case of too long range interactions).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of sites to be grouped together.</span>
<span class="sd">        grouped_sites : None | list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        group_split : Reverts the grouping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_form</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grouped_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grouped_sites</span> <span class="o">=</span> <span class="n">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">grouped_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_sites</span> <span class="o">==</span> <span class="n">n</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Ss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">B_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_forms</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">grouped_sites</span><span class="p">:</span>
            <span class="n">n_sites</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span>
            <span class="n">new_B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">formL</span><span class="o">=</span><span class="n">B_form</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">formR</span><span class="o">=</span><span class="n">B_form</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">comb_legs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lbl</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sites</span><span class="p">)]</span> <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">]</span>
            <span class="c1"># comb_legs = [[&#39;p0&#39;, &#39;p1&#39;, ... ]] for usual MPS</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">)))</span> <span class="c1"># [1]</span>
            <span class="n">new_B</span> <span class="o">=</span> <span class="n">new_B</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">comb_legs</span><span class="p">,</span> <span class="n">new_axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
            <span class="n">new_B</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">leg</span><span class="p">)</span>  <span class="c1"># test legcharge compatibility</span>
            <span class="n">Bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_B</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">))</span> <span class="c1"># [&#39;vL&#39;, &#39;p&#39;, &#39;vR&#39;]</span>
            <span class="n">Ss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">n_sites</span>
        <span class="n">Ss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># right-most singular values: need L+1 entries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span> <span class="o">=</span> <span class="n">Bs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">=</span> <span class="n">Ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">grouped_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">form</span> <span class="o">=</span> <span class="p">[</span><span class="n">B_form</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">*</span> <span class="n">n</span></div>

<div class="viewcode-block" id="MPS.group_split"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.group_split">[docs]</a>    <span class="k">def</span> <span class="nf">group_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Modify `self` inplace to split previously grouped sites.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trunc_par : dict</span>
<span class="sd">            Parameters for truncation, see :func:`~tenpy.algorithms.truncation.truncate`.</span>
<span class="sd">            `chi_max` defaults to ``max(self.chi)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`</span>
<span class="sd">            The error introduced by the truncation for the splitting.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        group_sites : Should have been used before to combine sites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_form</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">trunc_par</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;chi_max&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">))</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_sites</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Ss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trunc_err</span> <span class="o">=</span> <span class="n">TruncationError</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="n">sites</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span>
            <span class="n">Ss_new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">Bs_new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">B_gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">)</span> <span class="c1"># vL, p, vR</span>
            <span class="n">B_gr</span><span class="o">.</span><span class="n">idrop_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">)</span>  <span class="c1"># avoid warning: split label not called &#39;(...)&#39;</span>
            <span class="n">n_p_label</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">)</span>
            <span class="n">split_legs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_p_label</span><span class="p">))</span>
            <span class="n">transp</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n_p_label</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
            <span class="n">transp</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">transp</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">]</span>
            <span class="n">B_gr</span> <span class="o">=</span> <span class="n">B_gr</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="n">split_legs</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">transp</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">theta</span><span class="o">.</span><span class="n">idrop_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">))</span>  <span class="c1"># avoid warning</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="n">split_legs</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">transp</span><span class="p">)</span>
            <span class="c1"># for usual MPS, B_gr and theta have legs vL p0 p1 ... p{n-1} vR</span>
            <span class="c1"># for MPS with legs p, q, they have legs vL p0 q0 p1 q1 ... q{-n-1} vR</span>
            <span class="n">combine</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">B_gr</span><span class="o">.</span><span class="n">rank</span> <span class="o">-</span> <span class="n">n_p_label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_p_label</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">))]</span>
            <span class="c1"># combine = [[0, 1, .... {n-1}], [-2, -1]] for usual MPS</span>
            <span class="n">axes_contr</span> <span class="o">=</span> <span class="p">[</span><span class="n">combine</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">n_p_label</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># split off the right-most physical leg and vR from theta</span>
                <span class="c1"># theta: vL p0 ... pj vR</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">combine</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">svd_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
                <span class="n">Ss_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
                <span class="n">trunc_err</span> <span class="o">+=</span> <span class="n">err</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># vL p0 ... pj-1 vR</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_p_label</span><span class="p">):</span>
                    <span class="n">combine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">)</span> <span class="c1"># vL p vR</span>
                <span class="n">B_gr</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B_gr</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes_contr</span><span class="p">)</span> <span class="c1"># vL p0 ... pj-1 vR</span>
                <span class="n">Bs_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">Bs_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B_gr</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B_labels</span><span class="p">))</span>  <span class="c1"># inversion free :)</span>
            <span class="n">Ss_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">Bs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">Bs_new</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Ss</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">Ss_new</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Ss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span> <span class="o">=</span> <span class="n">Bs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_S</span> <span class="o">=</span> <span class="n">Ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grouped</span> <span class="o">//</span> <span class="n">n0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">form</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_valid_forms</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">trunc_err</span></div>

<div class="viewcode-block" id="MPS.get_grouped_mps"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_grouped_mps">[docs]</a>    <span class="k">def</span> <span class="nf">get_grouped_mps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocklen</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;contract blocklen subsequent tensors into a single one and return result as a new MPS.</span>

<span class="sd">        blocklen = number of subsequent sites to be combined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new MPS object with bunched sites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">groupedMPS</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">groupedMPS</span><span class="o">.</span><span class="n">group_sites</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">blocklen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groupedMPS</span></div>

<div class="viewcode-block" id="MPS.get_total_charge"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_total_charge">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate and return the `qtotal` of the whole MPS (when contracted).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        qtotal : charges</span>
<span class="sd">            The sum of the `qtotal` of the individual `B` tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qtotal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">B</span><span class="o">.</span><span class="n">qtotal</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.gauge_total_charge"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.gauge_total_charge">[docs]</a>    <span class="k">def</span> <span class="nf">gauge_total_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qtotal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vL_leg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vR_leg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gauge the legcharges of the virtual bonds such that the MPS has a total `qtotal`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qtotal : (list of) charges</span>
<span class="sd">            If a single set of charges is given, it is the desired total charge of the MPS</span>
<span class="sd">            (which :meth:`get_total_charge` will return afterwards).</span>
<span class="sd">            By default (``None``), use 0 charges, unless vL_leg and vR_leg are specified, in which</span>
<span class="sd">            case we adjust the total charge to match these legs.</span>
<span class="sd">        vL_leg : None | LegCharge</span>
<span class="sd">            Desired new virtual leg on the very left. Needs to have the same block strucuture as</span>
<span class="sd">            current leg, but can have shifted charge entries.</span>
<span class="sd">        vR_leg : None | LegCharge</span>
<span class="sd">            Desired new virtual leg on the very rigth. Needs to have the same block strucuture as</span>
<span class="sd">            current leg, but can have shifted charge entries.</span>
<span class="sd">            Should be `vL_leg.conj()` for infinite MPS, if `qtotal` is not given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">qnumber</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">vL_leg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vL_chdiff</span> <span class="o">=</span> <span class="n">vL_leg</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vR_leg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vR_chdiff</span> <span class="o">=</span> <span class="n">vR_leg</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qtotal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">vL_leg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vR_leg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_charge</span><span class="p">()</span> <span class="o">+</span> <span class="n">vL_chdiff</span> <span class="o">+</span> <span class="n">vR_chdiff</span>
        <span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">qtotal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qtotal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">qtotal_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">npc</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">)</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="n">qtotal_factor</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">qtotal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">qtotal</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">qnumber</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong shape of `qtotal`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vL_leg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">vL_chdiff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># adjust left leg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">gauge_total_charge</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">vL_chdiff</span><span class="p">,</span> <span class="n">vL_leg</span><span class="o">.</span><span class="n">qconj</span><span class="p">)</span>
            <span class="n">B</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">vL_leg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">desired_qtotal</span> <span class="o">=</span> <span class="n">qtotal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">chdiff</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">-</span> <span class="n">desired_qtotal</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">chdiff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">gauge_total_charge</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">desired_qtotal</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>  <span class="c1"># this &#39;vR&#39; is contracted with the &#39;vL&#39; of the next B</span>
                    <span class="c1"># so we need to adjust the next B as well</span>
                    <span class="n">nextB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextB</span><span class="o">.</span><span class="n">gauge_total_charge</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="n">nextB</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">+</span> <span class="n">chdiff</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_contractible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="c1"># just to check</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_total_charge</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qtotal</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">vR_leg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check that the charges match</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">vR_leg</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_contractable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">))</span></div>
        <span class="c1"># done</span>

<div class="viewcode-block" id="MPS.entanglement_entropy"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.entanglement_entropy">[docs]</a>    <span class="k">def</span> <span class="nf">entanglement_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">for_matrix_S</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</span>

<span class="sd">        Consider a bipartition of the sytem into :math:`A = \{ j: j &lt;= i_b \}` and</span>
<span class="sd">        :math:`B = \{ j: j &gt; i_b\}` and the reduced density matrix :math:`\rho_A = tr_B(\rho)`.</span>
<span class="sd">        The von-Neumann entanglement entropy is defined as</span>
<span class="sd">        :math:`S(A, n=1) = -tr(\rho_A \log(\rho_A)) = S(B, n=1)`.</span>
<span class="sd">        The generalization for ``n != 1, n&gt;0`` are the Renyi entropies:</span>
<span class="sd">        :math:`S(A, n) = \frac{1}{1-n} \log(tr(\rho_A^2)) = S(B, n=1)`</span>

<span class="sd">        This function calculates the entropy for a cut at different bonds `i`, for which the</span>
<span class="sd">        the eigenvalues of the reduced density matrix :math:`\rho_A` and :math:`\rho_B` is given</span>
<span class="sd">        by the squared schmidt values `S` of the bond.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int/float</span>
<span class="sd">            Selects which entropy to calculate;</span>
<span class="sd">            `n=1` (default) is the ususal von-Neumann entanglement entropy.</span>
<span class="sd">        bonds : ``None`` | (iterable of) int</span>
<span class="sd">            Selects the bonds at which the entropy should be calculated.</span>
<span class="sd">            ``None`` defaults to ``range(0, L+1)[self.nontrivial_bonds]``.</span>
<span class="sd">        for_matrix_S : bool</span>
<span class="sd">            Switch calculate the entanglement entropy even if the `_S` are matrices.</span>
<span class="sd">            Since :math:`O(\chi^3)` is expensive compared to the ususal :math:`O(\chi)`,</span>
<span class="sd">            we raise an error by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        entropies : 1D ndarray</span>
<span class="sd">            Entanglement entropies for half-cuts.</span>
<span class="sd">            `entropies[j]` contains the entropy for a cut at bond ``bonds[j]``</span>
<span class="sd">            (i.e. left to site ``bonds[j]``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bonds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nontrivial_bonds</span>
            <span class="n">bonds</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">nt</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entropy</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">for_matrix_S</span><span class="p">:</span>
                    <span class="c1"># explicitly calculate Schmidt values by diagonalizing (s^dagger s)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entropy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;entropy with non-diagonal schmidt values&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.entanglement_entropy_segment"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.entanglement_entropy_segment">[docs]</a>    <span class="k">def</span> <span class="nf">entanglement_entropy_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">first_site</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate entanglement entropy for general geometry of the bipartition.</span>

<span class="sd">        This function is similar as :meth:`entanglement_entropy`,</span>
<span class="sd">        but for more general geometry of the region `A` to be a segment of a *few* sites.</span>

<span class="sd">        This is acchieved by explicitly calculating the reduced density matrix of `A`</span>
<span class="sd">        and thus works only for small segments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : list of int</span>
<span class="sd">            Given a first site `i`, the region ``A_i`` is defined to be ``[i+j for j in segment]``.</span>
<span class="sd">        first_site : ``None`` | (iterable of) int</span>
<span class="sd">            Calculate the entropy for segments starting at these sites.</span>
<span class="sd">            ``None`` defaults to ``range(L-segment[-1])`` for finite</span>
<span class="sd">            or `range(L)` for infinite boundary conditions.</span>
<span class="sd">        n : int | float</span>
<span class="sd">            Selects which entropy to calculate;</span>
<span class="sd">            `n=1` (default) is the ususal von-Neumann entanglement entropy,</span>
<span class="sd">            otherwise the `n`-th Renyi entropy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        entropies : 1D ndarray</span>
<span class="sd">            ``entropies[i]`` contains the entropy for the the region ``A_i`` defined above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Side-Remark: there is a trick to calculate the entanglement for large regions `A_i`</span>
        <span class="c1"># of consecutive sites (in our notation, ``segment = range(La)``)</span>
        <span class="c1"># To get the entanglement entropy, diagonalize:</span>
        <span class="c1">#     --theta---</span>
        <span class="c1">#       | | |</span>
        <span class="c1">#     --theta*--</span>
        <span class="c1">#  Diagonalization is O(chi^6), compared to O(d^{3*La})</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">first_site</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
                <span class="n">first_site</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first_site</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">comb_legs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_labels</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">),</span> <span class="kc">False</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_labels</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">segment</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="n">first_site</span><span class="p">:</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rho_segment</span><span class="p">(</span><span class="n">segment</span> <span class="o">+</span> <span class="n">i0</span><span class="p">)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">comb_legs</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entropy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.entanglement_spectrum"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.entanglement_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">entanglement_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by_charge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;return entanglement energy spectrum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        by_charge : bool</span>
<span class="sd">            Wheter we should sort the spectrum on each bond by the possible charges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ent_spectrum : list</span>
<span class="sd">            For each (non-trivial) bond the entanglement spectrum.</span>
<span class="sd">            If `by_charge` is ``False``, return (for each bond) a sorted 1D ndarray</span>
<span class="sd">            with the convention :math:`S_i^2 = e^{-\xi_i}`, where :math:`S_i` labels a Schmidt</span>
<span class="sd">            value and :math:`\xi_i` labels the entanglement &#39;energy&#39; in the returned spectrum.</span>
<span class="sd">            If `by_charge` is True, return a a list of tuples ``(charge, sub_spectrum)``</span>
<span class="sd">            for each possible charge on that bond.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">by_charge</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">nontrivial_bonds</span><span class="p">]:</span>
                <span class="n">ss</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
                    <span class="n">leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># i == L: segment b.c.</span>
                    <span class="n">leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[(</span><span class="n">leg</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">qi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ss</span><span class="p">[</span><span class="n">leg</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)]))</span>
                            <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">block_number</span><span class="p">)]</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ss</span><span class="p">))</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nontrivial_bonds</span><span class="p">]]</span></div>

<div class="viewcode-block" id="MPS.get_rho_segment"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.get_rho_segment">[docs]</a>    <span class="k">def</span> <span class="nf">get_rho_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return reduced density matrix for a segment.</span>

<span class="sd">        Note that the dimension of rho_A scales exponentially in the length of the segment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : iterable of int</span>
<span class="sd">            Sites for which the reduced density matrix is to be calculated.</span>
<span class="sd">            Assumed to be sorted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rho : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Reduced density matrix of the segment sites.</span>
<span class="sd">            Labels ``&#39;p0&#39;, &#39;p1&#39;, ..., &#39;pk&#39;, &#39;p0*&#39;, &#39;p1*&#39;, ..., &#39;pk*&#39;`` with ``k=len(segment)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">segment</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># consecutive</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">rho</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">contract_axes</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">segment</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_p_label</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="n">contract_axes</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">rho</span></div>

<div class="viewcode-block" id="MPS.probability_per_charge"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.probability_per_charge">[docs]</a>    <span class="k">def</span> <span class="nf">probability_per_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return probabilites of charge value on the left of a given bond.</span>

<span class="sd">        For example for particle number conservation, define</span>
<span class="sd">        :math:`N_b = sum_{i&lt;b} n_i` for a given bond `b`.</span>
<span class="sd">        This function returns the possible values of `N_b` as rows of `charge_values`,</span>
<span class="sd">        and for each row the probabilty that this combination occurs in the given state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond : int</span>
<span class="sd">            The bond to be considered. The returned charges are summed on the left of this bond.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        charge_values : 2D array</span>
<span class="sd">            Columns correspond to the different charges in `self.chinfo`.</span>
<span class="sd">            Rows are the different charge fluctuations at this bond</span>
<span class="sd">        probabilities : 1D array</span>
<span class="sd">            For each row of `charge_values` the probablity for these values of charge fluctuations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span> <span class="ow">and</span> <span class="n">bond</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># usually the case</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">leg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">leg</span><span class="o">.</span><span class="n">qconj</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">leg</span><span class="o">.</span><span class="n">is_blocked</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;leg not blocked: can have duplicate entries in charge values&quot;</span><span class="p">)</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leg</span><span class="o">.</span><span class="n">block_number</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">leg</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">qi</span><span class="p">)</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">sl</span><span class="p">]))</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-10</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Probability_per_charge: Sum of probabilites not 1. Canonical form?&quot;</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">leg</span><span class="o">.</span><span class="n">charges</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">ps</span></div>

<div class="viewcode-block" id="MPS.average_charge"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.average_charge">[docs]</a>    <span class="k">def</span> <span class="nf">average_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the average charge for the block on the left of a given bond.</span>

<span class="sd">        For example for particle number conservation, define</span>
<span class="sd">        :math:`N_b = sum_{i&lt;b} n_i` for a given bond `b`.</span>
<span class="sd">        Then this function returns :math:`&lt;\psi| N_b |\psi&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond : int</span>
<span class="sd">            The bond to be considered.</span>
<span class="sd">            The returned charges are summed over the sites left of `bond`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        average_charge : 1D array</span>
<span class="sd">            For each type of charge in :attr:`chinfo`</span>
<span class="sd">            the average value when summing the charge values over sites left of the given bond.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">charges</span><span class="p">,</span> <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probability_per_charge</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ps</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">charges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.charge_variance"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.charge_variance">[docs]</a>    <span class="k">def</span> <span class="nf">charge_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the charge variance on the left of a given bond.</span>

<span class="sd">        For example for particle number conservation, define</span>
<span class="sd">        :math:`N_b = sum_{i&lt;b} n_i` for a given bond `b`.</span>
<span class="sd">        Then this function returns :math:`&lt;\psi| N_b^2 |\psi&gt; - (&lt;\psi| N_b |\psi&gt;)^2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond : int</span>
<span class="sd">            The bond to be considered.</span>
<span class="sd">            The returned charges are summed over the sites left of `bond`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        average_charge : 1D array</span>
<span class="sd">            For each type of charge in :attr:`chinfo`</span>
<span class="sd">            the variance of of the charge values left of the given bond.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">charges_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">average_charge</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="n">charges</span><span class="p">,</span> <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probability_per_charge</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ps</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">charges</span><span class="o">-</span><span class="n">charges_mean</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.mutinf_two_site"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.mutinf_two_site">[docs]</a>    <span class="k">def</span> <span class="nf">mutinf_two_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the two-site mutual information :math:`I(i:j)`.</span>

<span class="sd">        Calculates :math:`I(i:j) = S(i) + S(j) - S(i,j)`,</span>
<span class="sd">        where :math:`S(i)` is the single site entropy on site :math:`i`</span>
<span class="sd">        and :math:`S(i,j)` the two-site entropy on sites :math:`i,j`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_range : int</span>
<span class="sd">            Maximal distance ``|i-j|`` for which the mutual information should be calculated.</span>
<span class="sd">            ``None`` defaults to `L-1`.</span>
<span class="sd">        n : float</span>
<span class="sd">            Selects the entropy to use, see :func:`~tenpy.tools.math.entropy`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coords : 2D array</span>
<span class="sd">            Coordinates for the mutinf array.</span>
<span class="sd">        mutinf : 1D array</span>
<span class="sd">            ``mutinf[k]`` is the mutual information :math:`I(i:j)` between the</span>
<span class="sd">            sites ``i, j = coords[k]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Basically the code of get_rho_segment and entanglement_entropy,</span>
        <span class="c1">#  but optimized to run in O(L*max_range)</span>
        <span class="k">if</span> <span class="n">max_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">S_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entanglement_entropy_segment</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># single-site entropy</span>
        <span class="n">legs_ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_labels</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_labels</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># = ([&#39;p0&#39;, &#39;p1&#39;], [&#39;p0*&#39;, &#39;p1*&#39;])</span>
        <span class="n">contr_legs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span>  <span class="c1"># [&#39;vL&#39;, &#39;p1&#39;]</span>
            <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;1*&#39;</span><span class="p">))</span>  <span class="c1"># [&#39;vL*&#39;, &#39;p1*&#39;]</span>
        <span class="n">mutinf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">rho</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">))</span>
            <span class="n">jmax</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">max_range</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
                <span class="n">jmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">jmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jmax</span><span class="p">):</span>
                <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_p_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>  <span class="c1"># &#39;vL&#39;, &#39;vR&#39;, &#39;p1&#39;</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
                <span class="n">rho_ij</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">]))</span>
                <span class="n">rho_ij</span> <span class="o">=</span> <span class="n">rho_ij</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">legs_ij</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">S_ij</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">rho_ij</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">mutinf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">S_i</span><span class="p">[</span><span class="n">j</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">]</span> <span class="o">-</span> <span class="n">S_ij</span><span class="p">)</span>
                <span class="n">coord</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">jmax</span><span class="p">:</span>
                    <span class="n">rho</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="n">contr_legs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coord</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mutinf</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.overlap"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.overlap">[docs]</a>    <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">charge_sector</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_form</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute overlap ``&lt;self|other&gt;``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`MPS`</span>
<span class="sd">            An MPS with the same physical sites.</span>
<span class="sd">        charge_sector : None | charges | ``0``</span>
<span class="sd">            Selects the charge sector in which the dominant eigenvector of the TransferMatrix is.</span>
<span class="sd">            ``None`` stands for *all* sectors, ``0`` stands for the zero-charge sector.</span>
<span class="sd">            Defaults to ``0``, i.e., *assumes* the dominant eigenvector is in charge sector 0.</span>
<span class="sd">        ignore_form : bool</span>
<span class="sd">            If ``False`` (default), take into account the canonical form :attr:`form` at each site.</span>
<span class="sd">            If ``True``, we ignore the canonical form (i.e., whether the MPS is in left, right,</span>
<span class="sd">            mixed or no canonical form) and just contract all the :attr:`_B` as they are.</span>
<span class="sd">            (This can give different results!)</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Further keyword arguments given to :meth:`TransferMatrix.eigenvectors`;</span>
<span class="sd">            only used for infinite boundary conditions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        overlap : dtype.type</span>
<span class="sd">            The contraction ``&lt;self|other&gt; * self.norm * other.norm``</span>
<span class="sd">            (i.e., taking into account the :attr:`norm` of both MPS).</span>
<span class="sd">            For an infinite MPS, ``&lt;self|other&gt;`` is the overlap per unit cell, i.e.,</span>
<span class="sd">            the largest eigenvalue of the TransferMatrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ignore_form</span><span class="p">:</span>
                <span class="c1"># Use TransferMatrix with option to ignore the form</span>
                <span class="n">TM</span> <span class="o">=</span> <span class="n">TransferMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">charge_sector</span><span class="o">=</span><span class="n">charge_sector</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">matvec</span><span class="p">(</span><span class="n">TM</span><span class="o">.</span><span class="n">initial_guess</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>  <span class="c1"># apply transfer matrix to identity</span>
                <span class="k">return</span> <span class="n">npc</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">env</span> <span class="o">=</span> <span class="n">MPSEnvironment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">env</span><span class="o">.</span><span class="n">full_contraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># infinite</span>
            <span class="n">form</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ignore_form</span> <span class="k">else</span> <span class="s1">&#39;B&#39;</span>
            <span class="n">TM</span> <span class="o">=</span> <span class="n">TransferMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">charge_sector</span><span class="o">=</span><span class="n">charge_sector</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span>
            <span class="n">ov</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">norm</span></div>

<div class="viewcode-block" id="MPS.expectation_value"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.expectation_value">[docs]</a>    <span class="k">def</span> <span class="nf">expectation_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expectation value ``&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;`` of (n-site) operator(s).</span>

<span class="sd">        Given the MPS in canonical form, it calculates n-site expectation values.</span>
<span class="sd">        For example the contraction for a two-site (`n` = 2) operator on site `i` would look like::</span>

<span class="sd">            |          .--S--B[i]--B[i+1]--.</span>
<span class="sd">            |          |     |     |       |</span>
<span class="sd">            |          |     |-----|       |</span>
<span class="sd">            |          |     | op  |       |</span>
<span class="sd">            |          |     |-----|       |</span>
<span class="sd">            |          |     |     |       |</span>
<span class="sd">            |          .--S--B*[i]-B*[i+1]-.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ops : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }</span>
<span class="sd">            The operators, for wich the expectation value should be taken,</span>
<span class="sd">            All operators should all have the same number of legs (namely `2 n`).</span>
<span class="sd">            If less than `self.L` operators are given, we repeat them periodically.</span>
<span class="sd">            Strings (like ``&#39;Id&#39;, &#39;Sz&#39;``) are translated into single-site operators defined by</span>
<span class="sd">            :attr:`sites`.</span>
<span class="sd">        sites : None | list of int</span>
<span class="sd">            List of site indices. Expectation values are evaluated there.</span>
<span class="sd">            If ``None`` (default), the entire chain is taken (clipping for finite b.c.)</span>
<span class="sd">        axes : None | (list of str, list of str)</span>
<span class="sd">            Two lists of each `n` leg labels giving the physical legs of the operator used for</span>
<span class="sd">            contraction. The first `n` legs are contracted with conjugated `B`,</span>
<span class="sd">            the second `n` legs with the non-conjugated `B`.</span>
<span class="sd">            ``None`` defaults to ``([&#39;p&#39;], [&#39;p*&#39;])`` for single site operators (`n` = 1), or</span>
<span class="sd">            ``([&#39;p0&#39;, &#39;p1&#39;, ... &#39;p{n-1}&#39;], [&#39;p0*&#39;, &#39;p1*&#39;, .... &#39;p{n-1}*&#39;])`` for `n` &gt; 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exp_vals : 1D ndarray</span>
<span class="sd">            Expectation values, ``exp_vals[i] = &lt;psi|ops[i]|psi&gt;``, where ``ops[i]`` acts on</span>
<span class="sd">            site(s) ``j, j+1, ..., j+{n-1}`` with ``j=sites[i]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        One site examples (n=1):</span>

<span class="sd">        &gt;&gt;&gt; psi.expectation_value(&#39;Sz&#39;)</span>
<span class="sd">        [Sz0, Sz1, ..., Sz{L-1}]</span>
<span class="sd">        &gt;&gt;&gt; psi.expectation_value([&#39;Sz&#39;, &#39;Sx&#39;])</span>
<span class="sd">        [Sz0, Sx1, Sz2, Sx3, ... ]</span>
<span class="sd">        &gt;&gt;&gt; psi.expectation_value(&#39;Sz&#39;, sites=[0, 3, 4])</span>
<span class="sd">        [Sz0, Sz3, Sz4]</span>

<span class="sd">        Two site example (n=2), assuming homogeneous sites:</span>

<span class="sd">        &gt;&gt;&gt; SzSx = npc.outer(psi.sites[0].Sz.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p0&#39;, &#39;p0*&#39;]),</span>
<span class="sd">                             psi.sites[1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; psi.expectation_value(SzSx)</span>
<span class="sd">        [Sz0Sx1, Sz1Sx2, Sz2Sx3, ... ]   # with len L-1 for finite bc, or L for infinite</span>

<span class="sd">        Example measuring &lt;psi|SzSx|psi2&gt; on each second site, for inhomogeneous sites:</span>

<span class="sd">        &gt;&gt;&gt; SzSx_list = [npc.outer(psi.sites[i].Sz.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p0&#39;, &#39;p0*&#39;]),</span>
<span class="sd">                                   psi.sites[i+1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="sd">                         for i in range(0, psi.L-1, 2)]</span>
<span class="sd">        &gt;&gt;&gt; psi.expectation_value(SzSx_list, range(0, psi.L-1, 2))</span>
<span class="sd">        [Sz0Sx1, Sz2Sx3, Sz4Sx5, ...]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">op_ax_p</span><span class="p">,</span> <span class="n">op_ax_pstar</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expectation_value_args</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="n">ax_p</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">ax_pstar</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">(</span><span class="n">op_ax_p</span> <span class="o">+</span> <span class="n">op_ax_pstar</span><span class="p">,</span> <span class="n">ax_p</span> <span class="o">+</span> <span class="n">ax_pstar</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">ax_pstar</span><span class="p">,</span> <span class="n">ax_p</span><span class="p">])</span>  <span class="c1"># C has same labels as theta</span>
            <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">theta</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">do_conj</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">))</span></div>

<div class="viewcode-block" id="MPS.expectation_value_term"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.expectation_value_term">[docs]</a>    <span class="k">def</span> <span class="nf">expectation_value_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">autoJW</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Expectation value  ``&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;``.</span>

<span class="sd">        Calculates the expectation value of a tensor product of single-site operators</span>
<span class="sd">        acting on different sites `i0`, `i1`, ... (not necessarily next to each other).</span>
<span class="sd">        In other words, evaluate the expectation value of a term ``op0_i0 op1_i1 op2_i2 ...``.</span>

<span class="sd">        For example the contraction of three one-site operators on sites `i0`,</span>
<span class="sd">        `i1=i0+1`, `i2=i0+3` would look like::</span>

<span class="sd">            |          .--S--B[i0]---B[i0+1]--B[i0+2]--B[i0+3]--.</span>
<span class="sd">            |          |     |       |        |        |        |</span>
<span class="sd">            |          |    op1     op2       |       op3       |</span>
<span class="sd">            |          |     |       |        |        |        |</span>
<span class="sd">            |          .--S--B*[i0]--B*[i0+1]-B*[i0+2]-B*[i0+3]-.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        term : list of (str, int)</span>
<span class="sd">            List of tuples ``op, i`` where `i` is the MPS index of the site the operator</span>
<span class="sd">            named `op` acts on.</span>
<span class="sd">            The order inside `term` determines the order in which they act</span>
<span class="sd">            (in the mathematical convention: the last operator in `term` is right-most,</span>
<span class="sd">            so it acts first on a Ket).</span>
<span class="sd">        autoJW : bool</span>
<span class="sd">            If True (default), automatically insert Jordan Wigner strings for Fermions as needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exp_val : float/complex</span>
<span class="sd">            The expectation value of the tensorproduct of the given onsite operators,</span>
<span class="sd">            ``&lt;psi|op_i0 op_i1 ... op_iN |psi&gt;/&lt;psi|psi&gt;``,</span>
<span class="sd">            where ``|psi&gt;`` is the represented MPS.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        correlation_function : efficient way to evaluate many correlation functions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = psi.expectation_value_term([(&#39;Sx&#39;, 2), (&#39;Sz&#39;, 4)])</span>
<span class="sd">        &gt;&gt;&gt; b = psi.expectation_value_term([(&#39;Sz&#39;, 4), (&#39;Sx&#39;, 2)])</span>
<span class="sd">        &gt;&gt;&gt; c = psi.expectation_value_multi_sites([&#39;Sz&#39;, &#39;Id&#39;, &#39;Sz&#39;], i0=2)</span>
<span class="sd">        &gt;&gt;&gt; assert a == b == c</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># strategy: translate term into a list &quot;ops&quot; to be used for `expectation_value_multi_sites`</span>
        <span class="n">term</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">i_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">term</span><span class="p">])</span>
        <span class="n">i_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">term</span><span class="p">])</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">i_max</span> <span class="o">-</span> <span class="n">i_min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">count_JW</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">term</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">i_min</span> <span class="c1"># index in ops</span>
            <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ops</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">op</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ops</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
            <span class="k">if</span> <span class="n">autoJW</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">op_needs_JW</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="n">count_JW</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; JW&#39;</span>
                        <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; JW JW&#39;</span><span class="p">):</span>
                            <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39; JW JW&#39;</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;JW&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Id&#39;</span>
        <span class="k">if</span> <span class="n">count_JW</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Odd number of operators which need a Jordan Wigner string&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expectation_value_multi_sites</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">i_min</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.expectation_value_multi_sites"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.expectation_value_multi_sites">[docs]</a>    <span class="k">def</span> <span class="nf">expectation_value_multi_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="p">,</span> <span class="n">i0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Expectation value  ``&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;``.</span>

<span class="sd">        Calculates the expectation value of a tensor product of single-site operators</span>
<span class="sd">        acting on different sites next to each other.</span>
<span class="sd">        In other words, evaluate the expectation value of a term</span>
<span class="sd">        ``op0_i0 op1_{i0+1} op2_{i0+2} ...``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operators : List of { :class:`~tenpy.linalg.np_conserved.Array` | str }</span>
<span class="sd">            List of one-site operators. This method calculates the</span>
<span class="sd">            expectation value of the n-sites operator given by their tensor</span>
<span class="sd">            product.</span>
<span class="sd">        i0 : int</span>
<span class="sd">            The left most index on which an operator acts, i.e.,</span>
<span class="sd">            ``operators[i]`` acts on site ``i + i0``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exp_val : float/complex</span>
<span class="sd">            The expectation value of the tensorproduct of the given onsite operators,</span>
<span class="sd">            ``&lt;psi|operators[0]_{i0} operators[1]_{i0+1} ... |psi&gt;/&lt;psi|psi&gt;``,</span>
<span class="sd">            where ``|psi&gt;`` is the represented MPS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i0</span><span class="p">)]</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="s1">&#39;Th&#39;</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;vL*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="p">,[</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;vR*&#39;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">operators</span><span class="p">)):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">operators</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># the operator</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">j</span>  <span class="c1"># the site it acts on</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="s1">&#39;Id&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">exp_val</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">exp_val</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.expectation_value_terms_sum"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.expectation_value_terms_sum">[docs]</a>    <span class="k">def</span> <span class="nf">expectation_value_terms_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_list</span><span class="p">,</span> <span class="n">prefactors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate expectation values for a bunch of terms and sum them up.</span>

<span class="sd">        This is equivalent to the following expression::</span>

<span class="sd">            sum([self.expectation_value_term(term)*strength for term, strength in term_list])</span>

<span class="sd">        However, for effiency, the term_list is converted to an MPO and the expectation value</span>
<span class="sd">        of the MPO is evaluated.</span>

<span class="sd">        .. note ::</span>
<span class="sd">            Due to the way MPO expectation values are evaluated for infinite systems,</span>
<span class="sd">            it works only if all terms in the `term_list` start within the MPS unit cell.</span>

<span class="sd">        .. deprecated:: 0.4.0</span>
<span class="sd">            `prefactor` will be removed in version 1.0.0.</span>
<span class="sd">            Instead, directly give just ``TermList(term_list, prefactors)`` as argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        term_list : :class:`~tenpy.networks.terms.TermList`</span>
<span class="sd">            The terms and prefactors (`strength`) to be summed up.</span>
<span class="sd">        prefactors :</span>
<span class="sd">            Instead of specifying a :class:`~tenpy.networks.terms.TermList`,</span>
<span class="sd">            one can also specify the term_list and strength separately.</span>
<span class="sd">            This is deprecated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        terms_sum : list of (complex) float</span>
<span class="sd">            Equivalent to the expression</span>
<span class="sd">            ``sum([self.expectation_value_term(term)*strength for term, strength in term_list])``.</span>
<span class="sd">        _mpo :</span>
<span class="sd">            Intermediate results: the generated MPO.</span>
<span class="sd">            For a finite MPS, ``terms_sum = _mpo.expectation_value(self)``, for an infinite MPS</span>
<span class="sd">            ``terms_sum = _mpo.expectation_value(self) * self.L``</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        expectation_value_term : evaluates a single `term`.</span>
<span class="sd">        tenpy.networks.mpo.MPO.expectation_value : expectation value density of an MPO.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">mpo</span><span class="p">,</span> <span class="n">terms</span>
        <span class="k">if</span> <span class="n">prefactors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Deprecated argument prefactors: replace arguments with &quot;</span>
                          <span class="s2">&quot;``TermList(term_list, prefactors)``.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">term_list</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">TermList</span><span class="p">(</span><span class="n">term_list</span><span class="p">,</span> <span class="n">prefactors</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">term_list</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">term</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;term doesn&#39;t start in MPS unit cell: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">term</span><span class="p">))</span>
        <span class="c1"># conversion</span>
        <span class="n">ot</span><span class="p">,</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">term_list</span><span class="o">.</span><span class="n">to_OnsiteTerms_CouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="s1">&#39;finite&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span> <span class="k">else</span> <span class="s1">&#39;infinite&#39;</span>
        <span class="n">mpo_graph</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">MPOGraph</span><span class="o">.</span><span class="n">from_terms</span><span class="p">(</span><span class="n">ot</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
        <span class="n">mpo_</span> <span class="o">=</span> <span class="n">mpo_graph</span><span class="o">.</span><span class="n">build_MPO</span><span class="p">()</span>
        <span class="n">terms_sum</span> <span class="o">=</span> <span class="n">mpo_</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">max_range</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="n">terms_sum</span> <span class="o">=</span> <span class="n">terms_sum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">return</span> <span class="n">terms_sum</span><span class="p">,</span> <span class="n">mpo_</span></div>

<div class="viewcode-block" id="MPS.correlation_function"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.correlation_function">[docs]</a>    <span class="k">def</span> <span class="nf">correlation_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">ops1</span><span class="p">,</span>
                             <span class="n">ops2</span><span class="p">,</span>
                             <span class="n">sites1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">sites2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">opstr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">str_on_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">hermitian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Correlation function  ``&lt;psi|op1_i op2_j|psi&gt;/&lt;psi|psi&gt;`` of single site operators.</span>

<span class="sd">        Given the MPS in canonical form, it calculates n-site expectation values.</span>
<span class="sd">        For examples the contraction for a two-site operator on site `i` would look like::</span>

<span class="sd">            |          .--S--B[i]--B[i+1]--...--B[j]---.</span>
<span class="sd">            |          |     |     |            |      |</span>
<span class="sd">            |          |     |     |            op2    |</span>
<span class="sd">            |          |     op1   |            |      |</span>
<span class="sd">            |          |     |     |            |      |</span>
<span class="sd">            |          .--S--B*[i]-B*[i+1]-...--B*[j]--.</span>

<span class="sd">        Onsite terms are taken in the order ``&lt;psi | op1 op2 | psi&gt;``.</span>

<span class="sd">        If `opstr` is given and ``str_on_first=True``, it calculates::</span>

<span class="sd">            |           for i &lt; j                               for i &gt; j</span>
<span class="sd">            |</span>
<span class="sd">            |          .--S--B[i]---B[i+1]--...- B[j]---.     .--S--B[j]---B[j+1]--...- B[i]---.</span>
<span class="sd">            |          |     |      |            |      |     |     |      |            |      |</span>
<span class="sd">            |          |     opstr  opstr        op2    |     |     op2    |            |      |</span>
<span class="sd">            |          |     |      |            |      |     |     |      |            |      |</span>
<span class="sd">            |          |     op1    |            |      |     |     opstr  opstr        op1    |</span>
<span class="sd">            |          |     |      |            |      |     |     |      |            |      |</span>
<span class="sd">            |          .--S--B*[i]--B*[i+1]-...- B*[j]--.     .--S--B*[j]--B*[j+1]-...- B*[i]--.</span>

<span class="sd">        For ``i==j``, no `opstr` is included.</span>
<span class="sd">        For ``str_on_first=False``, the `opstr` on site ``min(i, j)`` is always left out.</span>

<span class="sd">        Strings (like ``&#39;Id&#39;, &#39;Sz&#39;``) in the operator lists are translated into single-site</span>
<span class="sd">        operators defined by the :class:`~tenpy.networks.site.Site` on which they act.</span>
<span class="sd">        Each operator should have the two legs ``&#39;p&#39;, &#39;p*&#39;``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ops1 : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }</span>
<span class="sd">            First operator of the correlation function (acting after ops2).</span>
<span class="sd">            ``ops1[x]`` acts on site ``sites1[x]``.</span>
<span class="sd">            If less than ``len(sites1)`` operators are given, we repeat them periodically.</span>
<span class="sd">        ops2 : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }</span>
<span class="sd">            Second operator of the correlation function (acting before ops1).</span>
<span class="sd">            ``ops2[y]`` acts on site ``sites2[y]``.</span>
<span class="sd">            If less than ``len(sites2)`` operators are given, we repeat them periodically.</span>
<span class="sd">        sites1 : None | int | list of int</span>
<span class="sd">            List of site indices; a single `int` is translated to ``range(0, sites1)``.</span>
<span class="sd">            ``None`` defaults to all sites ``range(0, L)``.</span>
<span class="sd">            Is sorted before use, i.e. the order is ignored.</span>
<span class="sd">        sites2 : None | int | list of int</span>
<span class="sd">            List of site indices; a single `int` is translated to ``range(0, sites2)``.</span>
<span class="sd">            ``None`` defaults to all sites ``range(0, L)``.</span>
<span class="sd">            Is sorted before use, i.e. the order is ignored.</span>
<span class="sd">        opstr : None | (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }</span>
<span class="sd">            Ignored by default (``None``).</span>
<span class="sd">            Operator(s) to be inserted between ``ops1`` and ``ops2``.</span>
<span class="sd">            If given as a list, ``opstr[r]`` is inserted at site `r` (independent of `sites1` and</span>
<span class="sd">            `sites2`).</span>
<span class="sd">        str_on_first : bool</span>
<span class="sd">            Whether the `opstr` is included on the site ``min(i, j)``.</span>
<span class="sd">            Note the order, which is chosen that way to handle fermionic Jordan-Wigner strings</span>
<span class="sd">            correctly. (In other words: choose ``str_on_first=True`` for fermions!)</span>
<span class="sd">        hermitian : bool</span>
<span class="sd">            Optimization flag: if ``sites1 == sites2`` and ``Ops1[i]^\dagger == Ops2[i]``</span>
<span class="sd">            (which is not checked explicitly!), the resulting ``C[x, y]`` will be hermitian.</span>
<span class="sd">            We can use that to avoid calculations, so ``hermitian=True`` will run faster.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        C : 2D ndarray</span>
<span class="sd">            The correlation function ``C[x, y] = &lt;psi|ops1[i] ops2[j]|psi&gt;``,</span>
<span class="sd">            where ``ops1[i]`` acts on site ``i=sites1[x]`` and ``ops2[j]`` on site ``j=sites2[y]``.</span>
<span class="sd">            If `opstr` is given, it gives (for ``str_on_first=True``):</span>

<span class="sd">            - For ``i &lt; j``: ``C[x, y] = &lt;psi|ops1[i] prod_{i &lt;= r &lt; j} opstr[r] ops2[j]|psi&gt;``.</span>
<span class="sd">            - For ``i &gt; j``: ``C[x, y] = &lt;psi|prod_{j &lt;= r &lt; i} opstr[r] ops1[i] ops2[j]|psi&gt;``.</span>
<span class="sd">            - For ``i = j``: ``C[x, y] = &lt;psi|ops1[i] ops2[j]|psi&gt;``.</span>

<span class="sd">            The condition ``&lt;= r`` is replaced by a strict ``&lt; r``, if ``str_on_first=False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ops1</span><span class="p">,</span> <span class="n">ops2</span><span class="p">,</span> <span class="n">sites1</span><span class="p">,</span> <span class="n">sites2</span><span class="p">,</span> <span class="n">opstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correlation_function_args</span><span class="p">(</span>
            <span class="n">ops1</span><span class="p">,</span> <span class="n">ops2</span><span class="p">,</span> <span class="n">sites1</span><span class="p">,</span> <span class="n">sites2</span><span class="p">,</span> <span class="n">opstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hermitian</span> <span class="ow">and</span> <span class="n">sites1</span> <span class="o">!=</span> <span class="n">sites2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;MPS correlation function can&#39;t use the hermitian flag&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">hermitian</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sites1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sites1</span><span class="p">):</span>
            <span class="c1"># j &gt; i</span>
            <span class="n">j_gtr</span> <span class="o">=</span> <span class="n">sites2</span><span class="p">[</span><span class="n">sites2</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j_gtr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">C_gtr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_up_diag</span><span class="p">(</span><span class="n">ops1</span><span class="p">,</span> <span class="n">ops2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j_gtr</span><span class="p">,</span> <span class="n">opstr</span><span class="p">,</span> <span class="n">str_on_first</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">C</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">sites2</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">C_gtr</span>
                <span class="k">if</span> <span class="n">hermitian</span><span class="p">:</span>
                    <span class="n">C</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">C_gtr</span><span class="p">)</span>
            <span class="c1"># j == i</span>
            <span class="n">j_eq</span> <span class="o">=</span> <span class="n">sites2</span><span class="p">[</span><span class="n">sites2</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">j_eq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># on-site correlation function</span>
                <span class="n">op12</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">ops1</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">ops2</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
                <span class="n">C</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">sites2</span> <span class="o">==</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">op12</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hermitian</span><span class="p">:</span>
            <span class="c1">#  j &lt; i</span>
            <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sites2</span><span class="p">):</span>
                <span class="n">i_gtr</span> <span class="o">=</span> <span class="n">sites1</span><span class="p">[</span><span class="n">sites1</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_gtr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">C</span><span class="p">[(</span><span class="n">sites1</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">),</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_up_diag</span><span class="p">(</span><span class="n">ops2</span><span class="p">,</span> <span class="n">ops1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i_gtr</span><span class="p">,</span> <span class="n">opstr</span><span class="p">,</span>
                                                            <span class="n">str_on_first</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="c1"># exchange ops1 and ops2 : they commute on different sites,</span>
                    <span class="c1"># but we apply opstr after op1 (using the last argument = False)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">C</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.norm_test"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.norm_test">[docs]</a>    <span class="k">def</span> <span class="nf">norm_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that self is in canonical form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm_error: array, shape (L, 2)</span>
<span class="sd">            For each site the norm error to the left and right.</span>
<span class="sd">            The error ``norm_error[i, 0]`` is defined as the norm-difference between</span>
<span class="sd">            the following networks::</span>

<span class="sd">                |   --theta[i]---.       --s[i]--.</span>
<span class="sd">                |       |        |    vs         |</span>
<span class="sd">                |   --theta*[i]--.       --s[i]--.</span>

<span class="sd">            Similarly, ``norm_errror[i, 1]`` is the norm-difference of::</span>

<span class="sd">                |   .--theta[i]---         .--s[i+1]--</span>
<span class="sd">                |   |    |          vs     |</span>
<span class="sd">                |   .--theta*[i]--         .--s[i+1]--</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">lbl_R</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">],</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;0*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">])</span>
        <span class="n">lbl_L</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span>
                 <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;0*&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">rho_L</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="n">lbl_R</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>  <span class="c1"># during DMRG with mixer, S may be a 2D npc.Array</span>
                <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expect 2D npc.Array or 1D numpy ndarray&quot;</span><span class="p">)</span>
                <span class="n">rho_L2</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho_L2</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">rho_L</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rho_L</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rho_L</span> <span class="o">-</span> <span class="n">rho_L2</span><span class="p">)</span>
            <span class="n">rho_R</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">th</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="n">lbl_L</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expect 2D npc.Array or 1D numpy ndarray&quot;</span><span class="p">)</span>
                <span class="n">rho_R2</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho_R2</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">rho_R</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rho_L</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rho_R</span> <span class="o">-</span> <span class="n">rho_R2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">err</span></div>

<div class="viewcode-block" id="MPS.canonical_form"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.canonical_form">[docs]</a>    <span class="k">def</span> <span class="nf">canonical_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bring self into canonical &#39;B&#39; form, (re-)calculate singular values.</span>

<span class="sd">        Simply calls :meth:`canonical_form_finite` or :meth:`canonical_form_infinite`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical_form_finite</span><span class="p">(</span><span class="n">renormalize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">canonical_form_infinite</span><span class="p">(</span><span class="n">renormalize</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.canonical_form_finite"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.canonical_form_finite">[docs]</a>    <span class="k">def</span> <span class="nf">canonical_form_finite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bring a finite (or segment) MPS into canonical form (in place).</span>

<span class="sd">        If any site is in :attr:`form` ``None``, it does *not* use any of the singular values `S`</span>
<span class="sd">        (for &#39;finite&#39; boundary conditions, or only the very left `S` for &#39;segment&#39; b.c.).</span>
<span class="sd">        If all sites have a `form`, it respects the `form` to ensure</span>
<span class="sd">        that one `S` is included per bond.</span>
<span class="sd">        The final state is always in right-canonical &#39;B&#39; form.</span>

<span class="sd">        Performs one sweep left to right doing QR decompositions, and one sweep right to left</span>
<span class="sd">        doing SVDs calculating the singular values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        renormalize: bool</span>
<span class="sd">            Whether a change in the norm should be discarded or used to update :attr:`norm`.</span>
<span class="sd">        cutoff : float | None</span>
<span class="sd">            Cutoff of singular values used in the SVDs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        U_L, V_R : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Only returned for ``&#39;segment&#39;`` boundary conditions.</span>
<span class="sd">            The unitaries defining the new left and right Schmidt states in terms of the old ones,</span>
<span class="sd">            with legs ``&#39;vL&#39;, &#39;vR&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">L</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># otherwise implement yourself...</span>
        <span class="c1"># normalize very left singular values</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need S[0] for segment boundary conditions.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_SL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">S</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>  <span class="c1"># must have correct singular values to the left...</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_SR</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># bc == &#39;finite&#39;:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_SL</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">]))</span>  <span class="c1"># trivial singular value on very left/right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_SR</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">]))</span>
        <span class="c1"># sweep from left to right to bring it into left canonical form.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">]):</span>
            <span class="c1"># ignore any &#39;S&#39; and canonical form</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">form</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we actually had a canonical form before, so we should *not* ignore the &#39;S&#39;</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;Th&#39;</span><span class="p">)</span>
            <span class="n">form</span> <span class="o">=</span> <span class="s1">&#39;B&#39;</span>  <span class="c1"># for other &#39;M&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="n">M</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">),</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="c1"># Q = unitary, R has to be multiplied to the right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="n">Q</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">),</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="c1"># Q is unitary, i.e. left canonical, R has to be multiplied to the right</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Q</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="c1"># also neet to calculate new singular values on the very right</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">VR_segment</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span>
                <span class="n">M</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">),</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="n">S</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_SR</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># sweep from right to left, calculating all the singular values</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="s1">&#39;vR&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                          <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">renormalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c1"># normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_SL</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span>
                <span class="n">M</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="s1">&#39;vR&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span>
                <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c1"># normalize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_SL</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># just a trivial phase factor, but better keep it</span>
        <span class="c1"># done. Discard the U for segment bc, although it might be a non-trivial unitary.</span>
        <span class="c1"># and just re-shuffling of the states left for &#39;segment&#39; bc)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">VR_segment</span></div>

<div class="viewcode-block" id="MPS.canonical_form_infinite"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.canonical_form_infinite">[docs]</a>    <span class="k">def</span> <span class="nf">canonical_form_infinite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol_xi</span><span class="o">=</span><span class="mf">1.e6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bring an infinite MPS into canonical form (in place).</span>

<span class="sd">        If any site is in :attr:`form` ``None``, it does *not* use any of the singular values `S`.</span>
<span class="sd">        If all sites have a `form`, it respects the `form` to ensure</span>
<span class="sd">        that one `S` is included per bond.</span>
<span class="sd">        The final state is always in right-canonical &#39;B&#39; form.</span>

<span class="sd">        Proceeds in three steps, namely 1) diagonalize right and left transfermatrix on a given</span>
<span class="sd">        bond to bring that bond into canonical form, and then</span>
<span class="sd">        2) sweep right to left, and 3) left to right to bringing other bonds into canonical form.</span>

<span class="sd">        .. warning :</span>
<span class="sd">            You might *loose* precision when calling this function.</span>
<span class="sd">            When we diagonalize the transfermatrix, we get the singular values squared as</span>
<span class="sd">            eigenvalues, with numerical noise on the order of machine precision (usually ~1.e-15).</span>
<span class="sd">            Taking the square root, the new singular values are only precise to *half* the machine</span>
<span class="sd">            precision (usually ~1.e-7).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        renormalize: bool</span>
<span class="sd">            Whether a change in the norm should be discarded or used to update :attr:`norm`.</span>
<span class="sd">        tol_xi : float</span>
<span class="sd">            Raise an error if the correlation length is larger than that</span>
<span class="sd">            (which indicates a degenerate &quot;cat&quot; state, e.g., for spontaneous symmetry breaking).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">)</span>  <span class="c1"># start at this bond</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">]):</span>
            <span class="c1"># ignore any &#39;S&#39; and canonical form, just state that we are in &#39;B&#39; form</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_form</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>  <span class="c1"># (is later used for guess of Gl)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># was in canonical form before; bring back into canonical form</span>
            <span class="c1"># -&gt; make sure we don&#39;t use multiple S on one bond in our definition of the MPS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convert_form</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">Wr_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>  <span class="c1"># right eigenvectors of TM on each bond after ..._correct_right</span>

        <span class="c1"># phase 1: bring bond (i1-1, i1) in canonical form</span>
        <span class="c1"># find dominant right eigenvector</span>
        <span class="n">norm</span><span class="p">,</span> <span class="n">Gr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_form_dominant_gram_matrix</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">tol_xi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>  <span class="c1"># correct norm</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">renormalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="c1"># make Gr diagonal to Wr</span>
        <span class="n">Wr</span><span class="p">,</span> <span class="n">Gl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_form_correct_right</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">Gr</span><span class="p">,</span> <span class="n">return_Gl_guess</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># find dominant left eigenvector</span>
        <span class="n">norm</span><span class="p">,</span> <span class="n">Gl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_form_dominant_gram_matrix</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tol_xi</span><span class="p">,</span> <span class="n">Gl</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">norm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-13</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Although we renormalized the TransferMatrix, &quot;</span>
                          <span class="s2">&quot;the largest eigenvalue is not 1&quot;</span><span class="p">)</span>  <span class="c1"># (this shouldn&#39;t happen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>  <span class="c1"># correct norm again</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">renormalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="c1"># bring bond to canonical form</span>
        <span class="n">Gl</span><span class="p">,</span> <span class="n">Wr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_form_correct_left</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">Gl</span><span class="p">,</span> <span class="n">Wr</span><span class="p">)</span>
        <span class="c1"># now the bond (i1-1,i1) is in canonical form</span>

        <span class="c1"># phase 2: sweep from right to left; find other right eigenvectors and make them diagonal</span>
        <span class="n">Wr_list</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Wr</span>  <span class="c1"># diag(Wr) is right eigenvector on bond (i1-1, i1)</span>
        <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">B1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span>  <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">]]</span>
            <span class="n">Gr</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B1</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">Wr</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">),</span> <span class="n">B1</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">Wr_list</span><span class="p">[</span><span class="n">j1</span> <span class="o">%</span> <span class="n">L</span><span class="p">]</span> <span class="o">=</span> <span class="n">Wr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_form_correct_right</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="n">Gr</span><span class="p">)</span>

        <span class="c1"># phase 3: sweep from left to right; find other left eigenvectors,</span>
        <span class="c1"># bring each bond into canonical form</span>
        <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span> <span class="o">-</span> <span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1"># find Gl on bond j1-1, j1</span>
            <span class="n">B1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">j1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">Gl</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
                <span class="n">B1</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span>  <span class="c1"># old B1; now on site j1-1</span>
                <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Gl</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]),</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">]])</span>
                <span class="c1"># axes=[[&#39;p*&#39;, &#39;vL*&#39;], [&#39;p&#39;, &#39;vR*&#39;]])</span>
            <span class="n">Gl</span><span class="p">,</span> <span class="n">Wr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_form_correct_left</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="n">Gl</span><span class="p">,</span> <span class="n">Wr_list</span><span class="p">[</span><span class="n">j1</span> <span class="o">%</span> <span class="n">L</span><span class="p">])</span></div>

<div class="viewcode-block" id="MPS.correlation_length"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.correlation_length">[docs]</a>    <span class="k">def</span> <span class="nf">correlation_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tol_ev0</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the correlation length by diagonalizing the transfer matrix.</span>

<span class="sd">        Assumes that `self` is in canonical form.</span>

<span class="sd">        Works only for infinite MPS, where the transfer matrix is a useful concept.</span>
<span class="sd">        Assuming a single-site unit cell, any correlation function splits into</span>
<span class="sd">        :math:`C(A_i, B_j) = A&#39;_i T^{j-i-1} B&#39;_j`</span>
<span class="sd">        with some parts left and right and the :math:`j-i-1`-th power of the transfer matrix in</span>
<span class="sd">        between. The largest eigenvalue is 1 (if self is properly normalized)</span>
<span class="sd">        and gives the dominant contribution of</span>
<span class="sd">        :math:`A&#39;_i E_1 * 1^{j-i-1} * E_1^T B&#39;_j = &lt;A&gt; &lt;B&gt;`,</span>
<span class="sd">        and the second largest one gives a contribution :math:`\propto \lambda_2^{j-i-1}`.</span>
<span class="sd">        Thus :math:`\lambda_2 = \exp(-\frac{1}{\xi})`.</span>

<span class="sd">        More general for a `L`-site unit cell we get :math:`\lambda_2 = \exp(-\frac{L}{\xi})`,</span>
<span class="sd">        where the `xi` is given in units of 1 lattice spacing in the MPS.</span>

<span class="sd">        .. warning ::</span>
<span class="sd">            For a higher-dimensional lattice (which the MPS class doesn&#39;t know about),</span>
<span class="sd">            the correct unit is the lattice spacing in x-direction, and the correct formula is</span>
<span class="sd">            :math:`\lambda_2 = \exp(-\frac{L_x}{\xi})`,</span>
<span class="sd">            where `L_x` is the number of lattice spacings in the infinite direction within the</span>
<span class="sd">            MPS unit cell, e.g. the number of &quot;rings&quot; of a cylinder in the MPS unit cell.</span>
<span class="sd">            To get to these units, divide the returned `xi` by the number of sites within a &quot;ring&quot;,</span>
<span class="sd">            for a lattice given in :attr:`~tenpy.networks.lattice.N_sites_per_ring`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : int</span>
<span class="sd">            We look for the `target` + 1 largest eigenvalues.</span>
<span class="sd">        tol_ev0 : float</span>
<span class="sd">            Print warning if largest eigenvalue deviates from 1 by more than `tol_ev0`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xi : float | 1D array</span>
<span class="sd">            If `target`=1, return just the correlation length,</span>
<span class="sd">            otherwise an array of the `target` largest correlation lengths.</span>
<span class="sd">            It is measured in units of a single lattice spacing in the MPS language,</span>
<span class="sd">            see the warning above.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">TransferMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">charge_sector</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transfermatrix_keep</span><span class="p">)</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E</span><span class="p">))]</span>  <span class="c1"># sort descending by magnitude</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_ev0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Correlation length: largest eigenvalue not one. &quot;</span>
                          <span class="s2">&quot;Not in canonical form/normalized?&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>  <span class="c1"># only a single eigenvector: zero correlation length</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span></div>

<div class="viewcode-block" id="MPS.add"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an MPS which represents ``alpha|self&gt; + beta |others&gt;``.</span>

<span class="sd">        Works only for ``&#39;finite&#39;, &#39;segment&#39;`` boundary conditions.</span>
<span class="sd">        For `segment` boundary conditions, the virtual legs on the very left/right are</span>
<span class="sd">        assumed to correspond to each other (i.e. self and other have the same state outside of</span>
<span class="sd">        the considered segment).</span>
<span class="sd">        Takes into account :attr:`norm`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : :class:`MPS`</span>
<span class="sd">            Another MPS of the same length to be added with self.</span>
<span class="sd">        alpha, beta : complex float</span>
<span class="sd">            Prefactors for self and other. We calculate</span>
<span class="sd">            ``alpha * |self&gt; + beta * |other&gt;``</span>
<span class="sd">        cutoff : float | None</span>
<span class="sd">            Cutoff of singular values used in the SVDs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum : :class:`MPS`</span>
<span class="sd">            An MPS representing ``alpha|self&gt; + beta |other&gt;``.</span>
<span class="sd">            Has same total charge as `self`.</span>
<span class="sd">        U_L, V_R : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Only returned for ``&#39;segment&#39;`` boundary conditions.</span>
<span class="sd">            The unitaries defining the new left and right Schmidt states in terms of the old ones,</span>
<span class="sd">            with legs ``&#39;vL&#39;, &#39;vR&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="n">L</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (if you need this, generalize this function...)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gauge_compatible_vL_vR</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_label</span>
        <span class="c1"># alpha and beta appear only on the first site</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">norm</span>
        <span class="n">Bs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">npc</span><span class="o">.</span><span class="n">grid_concat</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">alpha</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">legs</span><span class="p">),</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">legs</span><span class="p">)]],</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">B1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">legs</span><span class="p">)</span>
            <span class="n">B2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">legs</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="n">B1</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">B1</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">),</span> <span class="n">B2</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">B1</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">2</span><span class="p">:])],</span>
                    <span class="p">[</span><span class="n">npc</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">B2</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">),</span> <span class="n">B1</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">B1</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">B2</span><span class="p">]]</span>
            <span class="n">Bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">grid_concat</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">Bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">npc</span><span class="o">.</span><span class="n">grid_concat</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">legs</span><span class="p">)],</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">legs</span><span class="p">)]],</span>
                <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="n">Ss</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">Bs</span><span class="p">]</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="n">Bs</span><span class="p">,</span> <span class="n">Ss</span><span class="p">,</span> <span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># new class instance</span>
        <span class="c1"># bring to canonical form, calculate Ss</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;segment&#39;</span><span class="p">:</span>
            <span class="n">U_L</span><span class="p">,</span> <span class="n">V_R</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">canonical_form_finite</span><span class="p">(</span><span class="n">renormalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">psi</span><span class="p">,</span> <span class="n">U_L</span><span class="p">,</span> <span class="n">V_R</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psi</span><span class="o">.</span><span class="n">canonical_form_finite</span><span class="p">(</span><span class="n">renormalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">psi</span></div>

<div class="viewcode-block" id="MPS.apply_local_op"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.apply_local_op">[docs]</a>    <span class="k">def</span> <span class="nf">apply_local_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">unitary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a local operator to `self`.</span>


<span class="sd">        Note that this destroys the canonical form if the local operator is non-unitary.</span>
<span class="sd">        Therefore, this function calls :meth:`canonical_form` if necessary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Index of the site on which the operator should act.</span>
<span class="sd">        op : str | npc.Array</span>
<span class="sd">            A physical operator acting on site `i`, with legs ``&#39;p&#39;, &#39;p*&#39;``.</span>
<span class="sd">            Strings (like ``&#39;Id&#39;, &#39;Sz&#39;``) are translated into single-site operators defined by</span>
<span class="sd">            :attr:`sites`.</span>
<span class="sd">        unitary : None | bool</span>
<span class="sd">            Whether `op` is unitary, i.e., whether the canonical form is preserved (``True``)</span>
<span class="sd">            or whether we should call :meth:`canonical_form` (``False``).</span>
<span class="sd">            ``None`` checks whether ``norm(op dagger(op) - identity)`` is small.</span>
<span class="sd">        renormalize : bool</span>
<span class="sd">            Whether the final state should keep track of the norm (False, default) or be</span>
<span class="sd">            renormalized to have norm 1 (True).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unitary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">op_op_dagger</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
            <span class="n">unitary</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">op_op_dagger</span> <span class="o">-</span> <span class="n">npc</span><span class="o">.</span><span class="n">eye_like</span><span class="p">(</span><span class="n">op_op_dagger</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.e-14</span>
        <span class="n">opB</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">opB</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unitary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">(</span><span class="n">renormalize</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPS.swap_sites"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.swap_sites">[docs]</a>    <span class="k">def</span> <span class="nf">swap_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">swap_op</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Swap the two neighboring sites `i` and `i+1` (inplace).</span>

<span class="sd">        Exchange two neighboring sites: form theta, &#39;swap&#39; the physical legs and split</span>
<span class="sd">        with an svd. While the &#39;swap&#39; is just a transposition/relabeling for bosons, one needs to</span>
<span class="sd">        be careful about the sign for fermions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Swap the two sites at positions `i` and `i+1`.</span>
<span class="sd">        swap_op : ``None`` | ``&#39;auto&#39;`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The operator used to swap the phyiscal legs of the two-site wave function `theta`.</span>
<span class="sd">            For ``None``, just transpose/relabel the legs, for ``&#39;auto&#39;`` also take care of</span>
<span class="sd">            fermionic signs. Alternative give an npc :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            which represents the full operator used for the swap.</span>
<span class="sd">            Should have legs ``[&#39;p0&#39;, &#39;p1&#39;, &#39;p0*&#39;, &#39;p1*&#39;]`` whith ``&#39;p0&#39;, &#39;p1*&#39;`` contractible.</span>
<span class="sd">        trunc_par : dict</span>
<span class="sd">            Parameters for truncation, see :func:`~tenpy.algorithms.truncation.truncate`.</span>
<span class="sd">            `chi_max` defaults to ``max(self.chi)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`</span>
<span class="sd">            The error of the represented state introduced by the truncation after the swap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trunc_par</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;chi_max&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">))</span>
        <span class="n">siteL</span><span class="p">,</span> <span class="n">siteR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">swap_op</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="c1"># get sign for Fermions.</span>
            <span class="c1"># If we write the wave function as</span>
            <span class="c1"># psi = sum_{ [n_i]} psi_[n_i] prod_i (c^dagger_i)^{n_i}  |vac&gt;</span>
            <span class="c1"># we see that switching i &lt;-&gt; i+1 the phase to be introduced is by commuting</span>
            <span class="c1"># (c^dagger_i)^{n_i} with (c^dagger_{i+1})^{n_{i+1}}</span>
            <span class="c1"># This gives a sign (-1)^{n_i * n_{i+1}}.</span>
            <span class="c1"># site.JW_exponent is the `n_i` in the above equations, for each physical index.</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="n">siteL</span><span class="o">.</span><span class="n">JW_exponent</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">siteR</span><span class="o">.</span><span class="n">JW_exponent</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sign</span><span class="p">):</span>
                <span class="n">dL</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">siteL</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">siteR</span><span class="o">.</span><span class="n">dim</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sign</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">dL</span> <span class="o">*</span> <span class="n">dR</span><span class="p">])))</span>
                <span class="n">swap_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">dL</span><span class="p">,</span> <span class="n">dR</span><span class="p">,</span> <span class="n">dL</span><span class="p">,</span> <span class="n">dR</span><span class="p">])</span>
                <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="n">siteL</span><span class="o">.</span><span class="n">leg</span><span class="p">,</span> <span class="n">siteR</span><span class="o">.</span><span class="n">leg</span><span class="p">,</span> <span class="n">siteL</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">siteR</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">conj</span><span class="p">()]</span>
                <span class="n">swap_op</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="o">.</span><span class="n">from_ndarray</span><span class="p">(</span><span class="n">swap_op</span><span class="p">,</span> <span class="n">legs</span><span class="p">)</span>
                <span class="n">swap_op</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no sign necessary</span>
                <span class="n">swap_op</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># continue with transposition as for Bosons</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">formL</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>  <span class="c1"># inversion free, see also TEBDEngine.update_bond()</span>
        <span class="k">if</span> <span class="n">swap_op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># just replace the labels, effectively this is a transposition.</span>
            <span class="n">theta</span><span class="o">.</span><span class="n">ireplace_labels</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">])</span>
            <span class="n">C</span><span class="o">.</span><span class="n">ireplace_labels</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">swap_op</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">swap_op</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">]])</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">swap_op</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid swap_op: got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">swap_op</span><span class="p">))</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([(</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">)],</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">renormalize</span> <span class="o">=</span> <span class="n">svd_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="n">B_R</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ireplace_label</span><span class="p">(</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">)</span>
        <span class="n">B_L</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
            <span class="n">C</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">((</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">),</span> <span class="n">pipes</span><span class="o">=</span><span class="n">theta</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">V</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;(vR.p1)&#39;</span><span class="p">,</span> <span class="s1">&#39;(vR*.p1*)&#39;</span><span class="p">])</span>
        <span class="n">B_L</span><span class="o">.</span><span class="n">ireplace_labels</span><span class="p">([</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
        <span class="n">B_L</span> <span class="o">/=</span> <span class="n">renormalize</span>  <span class="c1"># re-normalize to &lt;psi|psi&gt; = 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_SR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">B_L</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">B_R</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">siteR</span>  <span class="c1"># swap &#39;sites&#39; as well</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">siteL</span>
        <span class="k">return</span> <span class="n">err</span></div>

<div class="viewcode-block" id="MPS.permute_sites"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.permute_sites">[docs]</a>    <span class="k">def</span> <span class="nf">permute_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">swap_op</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="p">{},</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the permutation perm to the state (inplace).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        perm : ndarray[ndim=1, int]</span>
<span class="sd">            The applied permutation, such that ``psi.permute_sites(perm)[i] = psi[perm[i]]``</span>
<span class="sd">            (where ``[i]`` indicates the `i`-th site).</span>
<span class="sd">        swap_op : ``None`` | ``&#39;auto&#39;`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The operator used to swap the phyiscal legs of a two-site wave function `theta`,</span>
<span class="sd">            see :meth:`swap_sites`.</span>
<span class="sd">        trunc_par : dict</span>
<span class="sd">            Parameters for truncation, see :func:`~tenpy.algorithms.truncation.truncate`.</span>
<span class="sd">            `chi_max` defaults to ``max(self.chi)``.</span>
<span class="sd">        verbose : float</span>
<span class="sd">            Level of verbosity, print status messages if verbose &gt; 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`</span>
<span class="sd">            The error of the represented state introduced by the truncation after the swaps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In order to keep sites close together, we always scan from the left,</span>
        <span class="c1"># keeping everything up to `i` in strictly ascending order.</span>
        <span class="c1"># =&gt; more or less an &#39;insertion&#39; sort algorithm.</span>
        <span class="c1"># Works nicely for permutations like [1,2,3,0,6,7,8,5] (swapping the 0 and 5 around).</span>
        <span class="c1"># For [ 2 3 4 5 6 7 0 1], it splits 0 and 1 apart (first swapping the 0 down, then the 1)</span>
        <span class="n">trunc_par</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;chi_max&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">))</span>
        <span class="n">trunc_err</span> <span class="o">=</span> <span class="n">TruncationError</span><span class="p">()</span>
        <span class="n">num_swaps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;: chi = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">trunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap_sites</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">swap_op</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_S</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;. eps = &quot;</span><span class="p">,</span> <span class="n">trunc</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
                <span class="n">num_swaps</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
                <span class="c1"># restart from very left; but we know it&#39;s already sorted up to i-1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">trunc_err</span> <span class="o">+=</span> <span class="n">trunc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total swaps in permute_sites:&quot;</span><span class="p">,</span> <span class="n">num_swaps</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">trunc_err</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">trunc_err</span></div>

<div class="viewcode-block" id="MPS.compute_K"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPS.html#tenpy.networks.mpo.MPS.compute_K">[docs]</a>    <span class="k">def</span> <span class="nf">compute_K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">swap_op</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">trunc_par</span><span class="o">=</span><span class="p">{},</span> <span class="n">canonicalize</span><span class="o">=</span><span class="mf">1.e-6</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</span>

<span class="sd">        Works for an infinite MPS living on a cylinder, infinitely long in `x` direction and with</span>
<span class="sd">        periodic boundary conditions in `y` directions.</span>
<span class="sd">        If the state is invariant under &#39;rotations&#39; around the cylinder axis, one can find the</span>
<span class="sd">        momentum quantum numbers of it. (The rotation is nothing more than a translation in `y`.)</span>
<span class="sd">        This function permutes some sites (on a copy of `self`) to enact the rotation, and then</span>
<span class="sd">        finds the dominant eigenvector of the mixed transfer matrix to get the quantum numbers,</span>
<span class="sd">        along the lines of [PollmannTurner2012]_, see also (the appendix and Fig. 11 in the arXiv</span>
<span class="sd">        version of) [CincioVidal2013]_.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        perm : 1D ndarray | :class:`~tenpy.models.lattice.Lattice`</span>
<span class="sd">            Permuation to be applied to the physical indices, see :meth:`permute_sites`.</span>
<span class="sd">            If a lattice is given, we use it to read out the lattice structure and shift</span>
<span class="sd">            each site by one lattice-vector in y-direction (assuming periodic boundary conditions).</span>
<span class="sd">            (If you have a :class:`~tenpy.models.model.CouplingModel`,</span>
<span class="sd">            give its `lat` attribute for this argument)</span>
<span class="sd">        swap_op : ``None`` | ``&#39;auto&#39;`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The operator used to swap the phyiscal legs of a two-site wave function `theta`,</span>
<span class="sd">            see :meth:`swap_sites`.</span>
<span class="sd">        trunc_par : dict</span>
<span class="sd">            Parameters for truncation, see :func:`~tenpy.algorithms.truncation.truncate`.</span>
<span class="sd">            `chi_max` defaults to ``max(self.chi)``.</span>
<span class="sd">        canonicalize : float</span>
<span class="sd">            Check that `self` is in canonical form; call :meth:`canonical_form`</span>
<span class="sd">            if :meth:`norm_test` yields ``np.linalg.norm(self.norm_test()) &gt; canonicalize``.</span>
<span class="sd">        verbose : float</span>
<span class="sd">            Level of verbosity, print status messages if verbose &gt; 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        U : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Unitary representation of the applied permutation on left Schmidt states.</span>
<span class="sd">        W : ndarray</span>
<span class="sd">            1D array of the form ``S**2 exp(i K)``, where `S` are the Schmidt values</span>
<span class="sd">            on the left bond. You can use :func:`np.abs` and :func:`np.angle` to extract the</span>
<span class="sd">            Schmidt values `S` and momenta `K` from `W`.</span>
<span class="sd">        q : :class:`~tenpy.linalg.charges.LegCharge`</span>
<span class="sd">            LegCharge corresponding to `W`.</span>
<span class="sd">        ov : complex</span>
<span class="sd">            The eigenvalue of the mixed transfer matrix `&lt;psi|T|psi&gt;` per :attr:`L` sites.</span>
<span class="sd">            An absolute value different smaller than 1 indicates that the state is not invariant</span>
<span class="sd">            under the permutation or that the truncation error `trunc_err` was too large!</span>
<span class="sd">        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`</span>
<span class="sd">            The error of the represented state introduced by the truncation after swaps when</span>
<span class="sd">            performing the truncation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..models.lattice</span> <span class="k">import</span> <span class="n">Lattice</span>  <span class="c1"># dynamical import to avoid import loops</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Works only for infinite b.c.&quot;</span><span class="p">)</span>
        <span class="n">trunc_par</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;chi_max&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">))</span>
        <span class="n">trunc_par</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">perm</span>
            <span class="k">assert</span> <span class="n">lat</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">2</span>  <span class="c1"># ensure that the lattice is at least 2D</span>
            <span class="k">assert</span> <span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="n">shifted_lat_order</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">shifted_lat_order</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">shifted_lat_order</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lat</span><span class="o">.</span><span class="n">Ls</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">lat2mps_idx</span><span class="p">(</span><span class="n">shifted_lat_order</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;permutation: &quot;</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
        <span class="c1"># preliminary: check canonical form</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_form</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">norm_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_test</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">norm_err</span> <span class="o">&gt;</span> <span class="n">canonicalize</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;self.norm_test() = </span><span class="si">{0!s}</span><span class="s2"> ==&gt; canonicalize&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_test</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">canonical_form</span><span class="p">()</span>
        <span class="c1"># get copy of self</span>
        <span class="n">psi_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># apply permutation</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">trunc_err</span> <span class="o">=</span> <span class="n">psi_t</span><span class="o">.</span><span class="n">permute_sites</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">swap_op</span><span class="p">,</span> <span class="n">trunc_par</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">/</span> <span class="mf">10.</span><span class="p">)</span>
        <span class="c1"># re-check canonical form</span>
        <span class="n">norm_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="o">.</span><span class="n">norm_test</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">norm_err</span> <span class="o">&gt;</span> <span class="n">canonicalize</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;psi_t.norm_test() = </span><span class="si">{0!s}</span><span class="s2"> ==&gt; canonicalize&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psi_t</span><span class="o">.</span><span class="n">norm_test</span><span class="p">()))</span>
        <span class="n">psi_t</span><span class="o">.</span><span class="n">convert_form</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="n">TM</span> <span class="o">=</span> <span class="n">TransferMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge_sector</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Find left dominant eigenvector of this mixed transfer matrix.</span>
        <span class="c1"># Because we are in B form and get the left eigenvector,</span>
        <span class="c1"># the resulting vector should be sUs up to a scaling.</span>
        <span class="n">ov</span><span class="p">,</span> <span class="n">sUs</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="n">num_ev</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_transfermatrix_keep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compute_K: overlap &quot;</span><span class="p">,</span> <span class="n">ov</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;, |o| = 1. -&quot;</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ov</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># (should be 1 if state is invariant under translations)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;compute_K: truncation error &quot;</span><span class="p">,</span> <span class="n">trunc_err</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">sUs</span> <span class="o">=</span> <span class="n">sUs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">sUs_blocked</span> <span class="o">=</span> <span class="n">sUs</span><span class="o">.</span><span class="n">as_completely_blocked</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">sUs_blocked</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="s1">&#39;m&gt;&#39;</span><span class="p">)</span>
        <span class="c1"># W = s^2 exp(i K ) up to overall scaling</span>
        <span class="c1"># Strip S&#39;s from U</span>
        <span class="n">inv_S</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">sUs</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">inv_S</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="n">inv_S</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># U should be unitary - scale it</span>
        <span class="n">U</span> <span class="o">*=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">U</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">W</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">W</span><span class="p">)),</span> <span class="n">sUs_blocked</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ov</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trunc_err</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Some status information about the MPS.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MPS, L=</span><span class="si">{L:d}</span><span class="s2">, bc=</span><span class="si">{bc!r}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">)]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;chi: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;first two sites: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;first two forms:&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;sites: &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;forms: &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">form</span><span class="p">]))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure `i` is a valid index (depending on `self.bc`).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;i = </span><span class="si">{0:d}</span><span class="s2"> out of bounds for finite MPS&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">_parse_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse `form` = (list of) {tuple | key of _valid_forms} to list of tuples&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">form</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="n">form</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">form</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">form</span> <span class="o">=</span> <span class="p">[</span><span class="n">form</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">form</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong len of `form`: &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">form</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_form</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">form</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_to_valid_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse `form` = {tuple | key of _valid_forms} to a tuple&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">form</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_forms</span><span class="p">[</span><span class="n">form</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_scale_axis_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">form_diff</span><span class="p">,</span> <span class="n">axis_B</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale an axis of B with S to bring it in desired form.</span>

<span class="sd">        If S is just 1D (as usual, e.g. during TEBD), this function just performs</span>
<span class="sd">        ``B.scale_axis(S**form_diff, axis_B)``.</span>

<span class="sd">        However, during the DMRG with mixer, S might acutally be a 2D matrix.</span>
<span class="sd">        For ``form_diff = -1``, we need to calculate the inverse of S, more precisely the</span>
<span class="sd">        (Moore-Penrose) pseudo inverse, see :func:`~tenpy.linalg.np_conserved.pinv`.</span>
<span class="sd">        The cutoff is only used in that case.</span>

<span class="sd">        Returns scaled B.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">form_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">B</span>  <span class="c1"># nothing to do</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="c1"># the usual case: S is a 1D array with singular values</span>
            <span class="k">if</span> <span class="n">form_diff</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">**</span><span class="n">form_diff</span>
            <span class="k">return</span> <span class="n">B</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis_B</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># e.g. during DMRG with a DensityMatrixMixer</span>
            <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expect 2D npc.Array or 1D numpy ndarray&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">form_diff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">form_diff</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t scale/tensordot a 2D `S` for non-integer `form_diff`&quot;</span><span class="p">)</span>

            <span class="c1"># Hack: mpo.MPOEnvironment.full_contraction uses ``axis_B == &#39;vL*&#39;``</span>
            <span class="k">if</span> <span class="n">axis_B</span> <span class="o">==</span> <span class="s1">&#39;vL&#39;</span> <span class="ow">or</span> <span class="n">axis_B</span> <span class="o">==</span> <span class="s1">&#39;vL*&#39;</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis_B</span><span class="p">])</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis_B</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis_B</span> <span class="o">==</span> <span class="s1">&#39;vR&#39;</span> <span class="ow">or</span> <span class="n">axis_B</span> <span class="o">==</span> <span class="s1">&#39;vR*&#39;</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">axis_B</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis_B</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This should never happen: unexpected leg for scaling with S&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">B</span>

    <span class="k">def</span> <span class="nf">_replace_p_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return npc Array `A` with replaced label, ``&#39;p&#39; -&gt; &#39;p&#39;+s``.</span>

<span class="sd">        This is done for each of the &#39;physical labels&#39; in :attr:`_p_label`.</span>
<span class="sd">        With a clever use of this function, the re-implementation of various functions</span>
<span class="sd">        (like get_theta) in derived classes with multiple legs per site can be avoided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">replace_label</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
        <span class="c1">#  return A.replace_labels(self._p_label, self._get_p_label(s))</span>

    <span class="k">def</span> <span class="nf">_get_p_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return  self._p_label with additional string `s`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">]</span>
        <span class="c1">#  return [lbl + s for lbl in self._p_label]</span>

    <span class="k">def</span> <span class="nf">_get_p_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">star</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Join ``self._get_p_label(str(k)) for k in range(ks)`` to a single list.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">star</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ks</span><span class="p">)]</span>
            <span class="c1">#  return [lbl + str(k) + &#39;*&#39; for k in range(ks) for lbl in self._p_label]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ks</span><span class="p">)]</span>
            <span class="c1">#  return [lbl + str(k) for k in range(ks) for lbl in self._p_label]</span>

    <span class="k">def</span> <span class="nf">_expectation_value_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;parse the arguments of self.expectation_value()&quot;&quot;&quot;</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">to_iterable_arrays</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">sites</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">s</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)]</span><span class="o">.</span><span class="n">rank</span> <span class="o">//</span> <span class="mi">2</span>  <span class="c1"># same as int(rank/2)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finite</span><span class="p">:</span>
                <span class="n">sites</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sites</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_p_labels</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_p_labels</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="c1"># check number of axes</span>
        <span class="n">ax_p</span><span class="p">,</span> <span class="n">ax_pstar</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax_p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax_pstar</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Len of axes does not match to n-site operator with n=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axes</span>

    <span class="k">def</span> <span class="nf">_correlation_function_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops1</span><span class="p">,</span> <span class="n">ops2</span><span class="p">,</span> <span class="n">sites1</span><span class="p">,</span> <span class="n">sites2</span><span class="p">,</span> <span class="n">opstr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get default arguments of self.correlation_function()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sites1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sites1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sites1</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sites1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sites1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sites2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sites2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sites2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sites2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sites2</span><span class="p">)</span>
        <span class="n">ops1</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">to_iterable_arrays</span><span class="p">(</span><span class="n">ops1</span><span class="p">)</span>
        <span class="n">ops2</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">to_iterable_arrays</span><span class="p">(</span><span class="n">ops2</span><span class="p">)</span>
        <span class="n">opstr</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">to_iterable_arrays</span><span class="p">(</span><span class="n">opstr</span><span class="p">)</span>
        <span class="n">sites1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sites1</span><span class="p">)</span>
        <span class="n">sites2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sites2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ops1</span><span class="p">,</span> <span class="n">ops2</span><span class="p">,</span> <span class="n">sites1</span><span class="p">,</span> <span class="n">sites2</span><span class="p">,</span> <span class="n">opstr</span>

    <span class="k">def</span> <span class="nf">_corr_up_diag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops1</span><span class="p">,</span> <span class="n">ops2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j_gtr</span><span class="p">,</span> <span class="n">opstr</span><span class="p">,</span> <span class="n">str_on_first</span><span class="p">,</span> <span class="n">apply_opstr_first</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;correlation function above the diagonal: for fixed i and all j in j_gtr, j &gt; i.&quot;&quot;&quot;</span>
        <span class="n">op1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">ops1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">opstr1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">opstr1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">apply_opstr_first</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]</span>
            <span class="n">op1</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">opstr1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">])</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]])</span>
        <span class="c1"># C has legs &#39;vR*&#39;, &#39;vR&#39;</span>
        <span class="n">js</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">j_gtr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># stack of j, sorted *descending*</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">js</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># js[0] is the maximum</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">js</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">Cij</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">ops2</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
                <span class="n">Cij</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Cij</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">]])</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Cij</span><span class="p">)</span>
                <span class="n">js</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">js</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">opstr</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">])</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_canonical_form_dominant_gram_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond0</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">tol_xi</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find dominant eigenvector of the transfer matrix starting between sites (bond0-1,bond0).</span>

<span class="sd">        Find right (transpose=False) or left (transpose=True) eigenvector of the transfermatrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TM</span> <span class="o">=</span> <span class="n">TransferMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">bond0</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="n">transpose</span><span class="p">,</span> <span class="n">charge_sector</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="n">bond0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="n">transpose</span> <span class="k">else</span> <span class="mf">1.</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">initial_guess</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="n">guess</span> <span class="o">=</span> <span class="n">guess</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pipes</span><span class="o">=</span><span class="n">TM</span><span class="o">.</span><span class="n">pipe</span><span class="p">)</span>
        <span class="n">eta</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transfermatrix_keep</span><span class="p">,</span> <span class="n">v0</span><span class="o">=</span><span class="n">guess</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transfermatrix_keep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eta</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">eta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">eta</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">tol_xi</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Degenerate spectrum of TransferMatrix &quot;</span>
                                 <span class="s2">&quot;(corr length xi=</span><span class="si">{xi:.3e}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xi</span><span class="o">=</span><span class="n">xi</span><span class="p">))</span>
        <span class="n">eta</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="n">eta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">split_legs</span><span class="p">()</span>
        <span class="c1"># note: the dominant eigenvector should be hermitian and positive</span>
        <span class="c1"># removes phase (arbitrary for eigenvectors!) and normalize</span>
        <span class="c1"># right eigenvectors should have trace chi, left ones trace 1</span>
        <span class="c1"># (since we expect something close to eye(chi) for right and diag(S**2) for left G)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="n">transpose</span> <span class="k">else</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">*=</span> <span class="n">norm</span> <span class="o">/</span> <span class="n">npc</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>  <span class="c1"># psi is real -&gt; G should be real</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
            <span class="n">G</span><span class="o">.</span><span class="n">iunary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eta</span><span class="p">,</span> <span class="n">G</span>  <span class="c1"># G has legs vL, vL* or vR, vR*</span>

    <span class="k">def</span> <span class="nf">_canonical_form_correct_right</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                      <span class="n">i1</span><span class="p">,</span>
                                      <span class="n">Gr</span><span class="p">,</span>
                                      <span class="n">return_Gl_guess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">eps</span><span class="o">=</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given the right gram matrix Gr, updated the bond (i0, i1), where i0 = i1 - 1.</span>

<span class="sd">        Diagonalise Gr = X^H Wr X and update</span>
<span class="sd">        ``B[i0] -&gt; B[i0] X^H / norm``,</span>
<span class="sd">        ``B[i1] -&gt; X B[i1] * norm``, where norm = sqrt(chi/sum(Wr)) == sqrt(chi/tr(Gr))</span>
<span class="sd">        If `Wr` has (almost) zero entries, reduce the bond dimension at the given bond.</span>
<span class="sd">        Then ``Gr -&gt; Wr``.</span>
<span class="sd">        Return Wr normalized to ``sum(Wr) = chi``.</span>
<span class="sd">        If `return_Gl_guess`, return also ``Gl_guess = X S[i1]**2 X^H``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Gr</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">])</span>
        <span class="n">W</span><span class="p">,</span> <span class="n">XH</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Gr</span><span class="p">)</span>  <span class="c1"># -&gt; XH has legs vL vL* = vL vR</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">W</span><span class="p">))])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># fix sign</span>
            <span class="n">W</span> <span class="o">=</span> <span class="o">-</span><span class="n">W</span>  <span class="c1"># should actually never happen:  we initially normalize tr(Gr) = chi &gt; 0</span>
        <span class="c1"># discard small values on order of machine precision</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">):</span>
            <span class="c1"># project into non-degenerate subspace, reducing the bond dimensions!</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;canonical_form_infinite: project to smaller bond dimension&quot;</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">XH</span><span class="o">.</span><span class="n">iproject</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">proj</span><span class="p">]</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">*=</span> <span class="n">norm</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>  <span class="c1"># (norm doesn&#39;t change eigenvalue of TM)</span>
        <span class="n">Kl</span> <span class="o">=</span> <span class="n">XH</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">norm</span><span class="p">)</span>
        <span class="n">Kr</span> <span class="o">=</span> <span class="n">XH</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">iconj</span><span class="p">()</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="n">norm</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i0</span><span class="p">),</span> <span class="n">Kl</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Kr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">return_Gl_guess</span><span class="p">:</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Kr</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_SL</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Kl</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">W</span><span class="p">,</span> <span class="n">guess</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">W</span>

    <span class="k">def</span> <span class="nf">_canonical_form_correct_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">Gl</span><span class="p">,</span> <span class="n">Wr</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bring into canonical form on bond (i0, i1) where i0= i1 - 1.</span>

<span class="sd">        Given the left Gram matrix Gl (with legs &#39;vR*&#39;, &#39;vR&#39;)</span>
<span class="sd">        and right diag(Wr), compute and diagonalize the density matrix</span>
<span class="sd">        ``rho = sqrt(Wr) Gl sqrt(Wr) -&gt; Y^H S^2 Y`` (Y acting on ket, Y^H on bra).</span>
<span class="sd">        Then we can update</span>
<span class="sd">        B[i0] -&gt; B[i0] sqrt(Wr) Y^H</span>
<span class="sd">        B[i1] -&gt; Y 1/sqrt(Wr) B[i1]</span>
<span class="sd">        Thus the new dominant left eigenvector is</span>
<span class="sd">        Gl -&gt; Y sqrt(Wr) Gl sqrt(Wr) Y^H = S^2</span>
<span class="sd">        and dominant right eigenvector is</span>
<span class="sd">        diag(Wr) -&gt; Y 1/sqrt(Wr) diag(Wr) 1/sqrt(W) Y^H = diag(1)</span>
<span class="sd">        i.e., we brought the bond to canonical form and `S` is the Schmidt spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sqrt_Wr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Wr</span><span class="p">)</span>
        <span class="n">Gl</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
        <span class="n">rhor</span> <span class="o">=</span> <span class="n">Gl</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">sqrt_Wr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="n">sqrt_Wr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">S2</span><span class="p">,</span> <span class="n">YH</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">rhor</span><span class="p">)</span>  <span class="c1"># YH has legs &#39;vR*&#39;, &#39;vR&#39;</span>
        <span class="n">S2</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>  <span class="c1"># equivalent to normalizing tr(rhor)=1</span>
        <span class="n">s_norm</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="c1"># discard small values on order of machine precision</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="p">(</span><span class="n">S2</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">S2</span><span class="p">):</span>
            <span class="c1"># project into non-degenerate subspace, reducing the bond dimensions!</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;canonical_form_infinite: project to smaller bond dimension&quot;</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">YH</span><span class="o">.</span><span class="n">iproject</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">S2</span><span class="p">[</span><span class="n">proj</span><span class="p">]</span>
            <span class="n">s_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S2</span><span class="p">))</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span> <span class="o">/</span> <span class="n">s_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_SL</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
        <span class="n">Yl</span> <span class="o">=</span> <span class="n">YH</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="n">sqrt_Wr</span> <span class="o">/</span> <span class="n">s_norm</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
        <span class="n">Yr</span> <span class="o">=</span> <span class="n">YH</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">iconj</span><span class="p">()</span><span class="o">.</span><span class="n">scale_axis</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">sqrt_Wr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i0</span><span class="p">),</span> <span class="n">Yl</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_B</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Yr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i1</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]))</span>
        <span class="n">Gl</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Gl</span><span class="p">,</span> <span class="n">Yl</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>
        <span class="n">Gl</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Yl</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">Gl</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR*&#39;</span><span class="p">])</span>  <span class="c1"># labels &#39;vR*&#39;, &#39;vR&#39;</span>
        <span class="n">Gl</span> <span class="o">/=</span> <span class="n">npc</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Gl</span><span class="p">)</span>
        <span class="c1"># Gl is diag(S**2) up to numerical errors...</span>
        <span class="k">return</span> <span class="n">Gl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Yr</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ind_len</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gauge_compatible_vL_vR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If necessary, gauge total charge of `other` to match the vL, vR legs of self.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">qnumber</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="kn">from</span> <span class="nn">tenpy.tools</span> <span class="k">import</span> <span class="n">optimization</span>
        <span class="n">need_gauge</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">with</span> <span class="n">optimization</span><span class="o">.</span><span class="n">temporary_level</span><span class="p">(</span><span class="n">optimization</span><span class="o">.</span><span class="n">OptimizationFlag</span><span class="o">.</span><span class="n">default</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">))</span>
                <span class="n">other</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">need_gauge</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">need_gauge</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">gauge_total_charge</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_total_charge</span><span class="p">()</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_total_charge</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self and other have different total charges!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MPSEnvironment"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment">[docs]</a><span class="k">class</span> <span class="nc">MPSEnvironment</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Stores partial contractions of :math:`&lt;bra|Op|ket&gt;` for local operators `Op`.</span>

<span class="sd">    The network for a contraction :math:`&lt;bra|Op|ket&gt;` of a local operator `Op`, say exemplary</span>
<span class="sd">    at sites `i, i+1` looks like::</span>

<span class="sd">        |     .-----M[0]--- ... --M[1]---M[2]--- ... -&gt;--.</span>
<span class="sd">        |     |     |             |      |               |</span>
<span class="sd">        |     |     |             |------|               |</span>
<span class="sd">        |     LP[0] |             |  Op  |               RP[-1]</span>
<span class="sd">        |     |     |             |------|               |</span>
<span class="sd">        |     |     |             |      |               |</span>
<span class="sd">        |     .-----N[0]*-- ... --N[1]*--N[2]*-- ... -&lt;--.</span>

<span class="sd">    Of course, we can also calculate the overlap `&lt;bra|ket&gt;` by using the special case ``Op = Id``.</span>

<span class="sd">    We use the following label convention (where arrows indicate `qconj`)::</span>

<span class="sd">        |    .--&gt;- vR           vL -&gt;-.</span>
<span class="sd">        |    |                        |</span>
<span class="sd">        |    LP                       RP</span>
<span class="sd">        |    |                        |</span>
<span class="sd">        |    .--&lt;- vR*         vL* -&lt;-.</span>

<span class="sd">    To avoid recalculations of the whole network e.g. in the DMRG sweeps,</span>
<span class="sd">    we store the contractions up to some site index in this class.</span>
<span class="sd">    For ``bc=&#39;finite&#39;,&#39;segment&#39;``, the very left and right part ``LP[0]`` and</span>
<span class="sd">    ``RP[-1]`` are trivial and don&#39;t change,</span>
<span class="sd">    but for ``bc=&#39;infinite&#39;`` they are might be updated</span>
<span class="sd">    (by inserting another unit cell to the left/right).</span>

<span class="sd">    The MPS `bra` and `ket` have to be in canonical form.</span>
<span class="sd">    All the environments are constructed without the singular values on the open bond.</span>
<span class="sd">    In other words, we contract left-canonical `A` to the left parts `LP`</span>
<span class="sd">    and right-canonical `B` to the right parts `RP`.</span>
<span class="sd">    Thus, the special case ``ket=bra`` should yield identity matrices for `LP` and `RP`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bra : :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        The MPS to project on. Should be given in usual &#39;ket&#39; form;</span>
<span class="sd">        we call `conj()` on the matrices directly.</span>
<span class="sd">        Stored in place, without making copies.</span>
<span class="sd">        If necessary to match charges, we call :meth:`~tenpy.networks.mps.MPS.gauge_total_charge`.</span>
<span class="sd">    ket : :class:`~tenpy.networks.mpo.MPO` | None</span>
<span class="sd">        The MPS on which the local operator acts.</span>
<span class="sd">        Stored in place, without making copies.</span>
<span class="sd">        If ``None``, use `bra`.</span>
<span class="sd">    init_LP : ``None`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        Initial very left part ``LP``. If ``None``, build trivial one.</span>
<span class="sd">    init_RP : ``None`` | :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">        Initial very right part ``RP``. If ``None``, build trivial one.</span>
<span class="sd">    age_LP : int</span>
<span class="sd">        The number of physical sites involved into the contraction yielding `firstLP`.</span>
<span class="sd">    age_RP : int</span>
<span class="sd">        The number of physical sites involved into the contraction yielding `lastRP`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        Number of physical sites. For iMPS the len of the MPS unit cell.</span>
<span class="sd">    bra, ket : :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">        The two MPS for the contraction.</span>
<span class="sd">    dtype : type</span>
<span class="sd">        The data type.</span>
<span class="sd">    _LP : list of {``None`` | :class:`~tenpy.linalg.np_conserved.Array`}</span>
<span class="sd">        Left parts of the environment, len `L`.</span>
<span class="sd">        ``LP[i]`` contains the contraction strictly left of site `i`</span>
<span class="sd">        (or ``None``, if we don&#39;t have it calculated).</span>
<span class="sd">    _RP : list of {``None`` | :class:`~tenpy.linalg.np_conserved.Array`}</span>
<span class="sd">        Right parts of the environment, len `L`.</span>
<span class="sd">        ``RP[i]`` contains the contraction strictly right of site `i`</span>
<span class="sd">        (or ``None``, if we don&#39;t have it calculated).</span>
<span class="sd">    _LP_age : list of int | ``None``</span>
<span class="sd">        Used for book-keeping, how large the DMRG system grew:</span>
<span class="sd">        ``_LP_age[i]`` stores the number of physical sites invovled into the contraction</span>
<span class="sd">        network which yields ``self._LP[i]``.</span>
<span class="sd">    _RP_age : list of int | ``None``</span>
<span class="sd">        Used for book-keeping, how large the DMRG system grew:</span>
<span class="sd">        ``_RP_age[i]`` stores the number of physical sites invovled into the contraction</span>
<span class="sd">        network which yields ``self._RP[i]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">ket</span><span class="p">,</span> <span class="n">init_LP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init_RP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">age_LP</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">age_RP</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ket</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ket</span> <span class="o">=</span> <span class="n">bra</span>
        <span class="k">if</span> <span class="n">ket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bra</span><span class="p">:</span>
            <span class="n">ket</span><span class="o">.</span><span class="n">_gauge_compatible_vL_vR</span><span class="p">(</span><span class="n">bra</span><span class="p">)</span> <span class="c1"># ensure matching charges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bra</span> <span class="o">=</span> <span class="n">bra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ket</span> <span class="o">=</span> <span class="n">ket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">bra</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ket</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finite</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">finite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP_age</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP_age</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="k">if</span> <span class="n">init_LP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">init_LP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bra</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_LP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">init_LP</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age_LP</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_RP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">init_RP</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bra</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_RP</span><span class="p">(</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">init_RP</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age_RP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">L</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">finite</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">finite</span><span class="p">)</span>
        <span class="c1"># check that the network is contractable</span>
        <span class="k">for</span> <span class="n">b_s</span><span class="p">,</span> <span class="n">k_s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">sites</span><span class="p">):</span>
            <span class="n">b_s</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">test_equal</span><span class="p">(</span><span class="n">k_s</span><span class="o">.</span><span class="n">leg</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">any</span><span class="p">([</span><span class="n">LP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">LP</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">any</span><span class="p">([</span><span class="n">RP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">RP</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span><span class="p">])</span>

<div class="viewcode-block" id="MPSEnvironment.get_LP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.get_LP">[docs]</a>    <span class="k">def</span> <span class="nf">get_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate LP at given site from nearest available one (including `i`).</span>

<span class="sd">        The returned ``LP_i`` corresponds to the following contraction,</span>
<span class="sd">        where the M&#39;s and the N&#39;s are in the &#39;A&#39; form::</span>

<span class="sd">            |     .-------M[0]--- ... --M[i-1]---&gt;-   &#39;vR&#39;</span>
<span class="sd">            |     |       |             |</span>
<span class="sd">            |     LP[0]   |             |</span>
<span class="sd">            |     |       |             |</span>
<span class="sd">            |     .-------N[0]*-- ... --N[i-1]*--&lt;-   &#39;vR*&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            The returned `LP` will contain the contraction *strictly* left of site `i`.</span>
<span class="sd">        store : bool</span>
<span class="sd">            Wheter to store the calculated `LP` in `self` (``True``) or discard them (``False``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        LP_i : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Contraction of everything left of site `i`,</span>
<span class="sd">            with labels ``&#39;vR*&#39;, &#39;vR&#39;`` for `bra`, `ket`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find nearest available LP to the left.</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i0</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">LP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># (for finite, LP[0] should always be set, so we should abort at latest with i0=0)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no break called</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No left part in the system???&quot;</span><span class="p">)</span>
        <span class="n">age_i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_LP_age</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_LP</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">LP</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_LP</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LP</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age_i0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LP</span></div>

<div class="viewcode-block" id="MPSEnvironment.get_RP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.get_RP">[docs]</a>    <span class="k">def</span> <span class="nf">get_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate RP at given site from nearest available one (including `i`).</span>

<span class="sd">        The returned ``RP_i`` corresponds to the following contraction,</span>
<span class="sd">        where the M&#39;s and the N&#39;s are in the &#39;B&#39; form::</span>

<span class="sd">            |     &#39;vL&#39;  -&gt;---M[i+1]-- ... --M[L-1]----.</span>
<span class="sd">            |                |              |         |</span>
<span class="sd">            |                |              |         RP[-1]</span>
<span class="sd">            |                |              |         |</span>
<span class="sd">            |     &#39;vL*&#39; -&lt;---N[i+1]*- ... --N[L-1]*---.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            The returned `RP` will contain the contraction *strictly* rigth of site `i`.</span>
<span class="sd">        store : bool</span>
<span class="sd">            Wheter to store the calculated `RP` in `self` (``True``) or discard them (``False``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        RP_i : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Contraction of everything left of site `i`,</span>
<span class="sd">            with labels ``&#39;vL*&#39;, &#39;vL&#39;`` for `bra`, `ket`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find nearest available RP to the right.</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i0</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">RP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># (for finite, RP[-1] should always be set, so we should abort at latest with i0=L-1)</span>
        <span class="n">age_i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_RP_age</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_RP</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">RP</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_RP</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="n">age_i0</span> <span class="o">+</span> <span class="n">i0</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RP</span></div>

<div class="viewcode-block" id="MPSEnvironment.get_LP_age"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.get_LP_age">[docs]</a>    <span class="k">def</span> <span class="nf">get_LP_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of physical sites in the contractions of get_LP(i). Might be ``None``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LP_age</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span></div>

<div class="viewcode-block" id="MPSEnvironment.get_RP_age"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.get_RP_age">[docs]</a>    <span class="k">def</span> <span class="nf">get_RP_age</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of physical sites in the contractions of get_LP(i). Might be ``None``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RP_age</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span></div>

<div class="viewcode-block" id="MPSEnvironment.set_LP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.set_LP">[docs]</a>    <span class="k">def</span> <span class="nf">set_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">LP</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store part to the left of site `i`.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP_age</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">age</span></div>

<div class="viewcode-block" id="MPSEnvironment.set_RP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.set_RP">[docs]</a>    <span class="k">def</span> <span class="nf">set_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">age</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store part to the right of site 1i1.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">RP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP_age</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">age</span></div>

<div class="viewcode-block" id="MPSEnvironment.del_LP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.del_LP">[docs]</a>    <span class="k">def</span> <span class="nf">del_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete stored part strictly to the left of site `i`.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LP_age</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MPSEnvironment.del_RP"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.del_RP">[docs]</a>    <span class="k">def</span> <span class="nf">del_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete storde part scrictly to the right of site `i`.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_RP_age</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MPSEnvironment.full_contraction"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.full_contraction">[docs]</a>    <span class="k">def</span> <span class="nf">full_contraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the overlap by a full contraction of the network.</span>

<span class="sd">        The full contraction of the environments gives the overlap ``&lt;bra|ket&gt;``,</span>
<span class="sd">        taking into account :attr:`MPS.norm` of both `bra` and `ket`.</span>
<span class="sd">        For this purpose, this function contracts</span>
<span class="sd">        ``get_LP(i0+1, store=False)`` and ``get_RP(i0, store=False)`` with appropriate singular</span>
<span class="sd">        values in between.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i0 : int</span>
<span class="sd">            Site index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">finite</span> <span class="ow">and</span> <span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">:</span>
            <span class="c1"># special case to handle `_to_valid_index` correctly:</span>
            <span class="c1"># get_LP(L) is not valid for finite b.c, so we use need to calculate it explicitly.</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_LP</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_LP</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">LP</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_LP</span><span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># multiply with `S`: a bit of a hack: use &#39;private&#39; MPS._scale_axis_B</span>
        <span class="n">S_bra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">_scale_axis_B</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">S_bra</span><span class="p">,</span> <span class="n">form_diff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">axis_B</span><span class="o">=</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
        <span class="c1"># cutoff is not used for form_diff = 1</span>
        <span class="n">S_ket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_SR</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">_scale_axis_B</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">S_ket</span><span class="p">,</span> <span class="n">form_diff</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">axis_B</span><span class="o">=</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_RP</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">contr</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">]],</span> <span class="n">do_conj</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">norm</span></div>

<div class="viewcode-block" id="MPSEnvironment.expectation_value"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mpo.MPSEnvironment.expectation_value">[docs]</a>    <span class="k">def</span> <span class="nf">expectation_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expectation value ``&lt;bra|ops|ket&gt;`` of (n-site) operator(s).</span>

<span class="sd">        Calculates n-site expectation values of operators sandwiched between bra and ket.</span>
<span class="sd">        For examples the contraction for a two-site operator on site `i` would look like::</span>

<span class="sd">            |          .--S--B[i]--B[i+1]--.</span>
<span class="sd">            |          |     |     |       |</span>
<span class="sd">            |          |     |-----|       |</span>
<span class="sd">            |          LP[i] | op  |       RP[i+1]</span>
<span class="sd">            |          |     |-----|       |</span>
<span class="sd">            |          |     |     |       |</span>
<span class="sd">            |          .--S--B*[i]-B*[i+1]-.</span>

<span class="sd">        Here, the `B` are taken from `ket`, the `B*` from `bra`.</span>
<span class="sd">        The call structure is the same as for :meth:`MPS.expectation_value`.</span>

<span class="sd">        .. warning :</span>
<span class="sd">            In contrast to :meth:`MPS.expectation_value`, this funciton does not normalize,</span>
<span class="sd">            thus it also takes into account :attr:`MPS.norm` of both `bra` and `ket`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ops : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }</span>
<span class="sd">            The operators, for wich the expectation value should be taken,</span>
<span class="sd">            All operators should all have the same number of legs (namely `2 n`).</span>
<span class="sd">            If less than ``len(sites)`` operators are given, we repeat them periodically.</span>
<span class="sd">            Strings (like ``&#39;Id&#39;, &#39;Sz&#39;``) are translated into single-site operators defined by</span>
<span class="sd">            :attr:`sites`.</span>
<span class="sd">        sites : list</span>
<span class="sd">            List of site indices. Expectation values are evaluated there.</span>
<span class="sd">            If ``None`` (default), the entire chain is taken (clipping for finite b.c.)</span>
<span class="sd">        axes : None | (list of str, list of str)</span>
<span class="sd">            Two lists of each `n` leg labels giving the physical legs of the operator used for</span>
<span class="sd">            contraction. The first `n` legs are contracted with conjugated `B`,</span>
<span class="sd">            the second `n` legs with the non-conjugated `B`.</span>
<span class="sd">            ``None`` defaults to ``([&#39;p&#39;], [&#39;p*&#39;])`` for single site (n=1), or</span>
<span class="sd">            ``([&#39;p0&#39;, &#39;p1&#39;, ... &#39;p{n-1}&#39;], [&#39;p0*&#39;, &#39;p1*&#39;, .... &#39;p{n-1}*&#39;])`` for `n` &gt; 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exp_vals : 1D ndarray</span>
<span class="sd">            Expectation values, ``exp_vals[i] = &lt;bra|ops[i]|ket&gt;``, where ``ops[i]`` acts on</span>
<span class="sd">            site(s) ``j, j+1, ..., j+{n-1}`` with ``j=sites[i]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        One site examples (n=1):</span>

<span class="sd">        &gt;&gt;&gt; env.expectation_value(&#39;Sz&#39;)</span>
<span class="sd">        [Sz0, Sz1, ..., Sz{L-1}]</span>
<span class="sd">        &gt;&gt;&gt; env.expectation_value([&#39;Sz&#39;, &#39;Sx&#39;])</span>
<span class="sd">        [Sz0, Sx1, Sz2, Sx3, ... ]</span>
<span class="sd">        &gt;&gt;&gt; env.expectation_value(&#39;Sz&#39;, sites=[0, 3, 4])</span>
<span class="sd">        [Sz0, Sz3, Sz4]</span>

<span class="sd">        Two site example (n=2), assuming homogeneous sites:</span>

<span class="sd">        &gt;&gt;&gt; SzSx = npc.outer(psi.sites[0].Sz.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p0&#39;, &#39;p0*&#39;]),</span>
<span class="sd">                             psi.sites[1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="sd">        &gt;&gt;&gt; env.expectation_value(SzSx)</span>
<span class="sd">        [Sz0Sx1, Sz1Sx2, Sz2Sx3, ... ]   # with len L-1 for finite bc, or L for infinite</span>

<span class="sd">        Example measuring &lt;bra|SzSx|ket&gt; on each second site, for inhomogeneous sites:</span>

<span class="sd">        &gt;&gt;&gt; SzSx_list = [npc.outer(psi.sites[i].Sz.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p0&#39;, &#39;p0*&#39;]),</span>
<span class="sd">                                   psi.sites[i+1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="sd">                         for i in range(0, psi.L-1, 2)]</span>
<span class="sd">        &gt;&gt;&gt; env.expectation_value(SzSx_list, range(0, psi.L-1, 2))</span>
<span class="sd">        [Sz0Sx1, Sz2Sx3, Sz4Sx5, ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">op_ax_p</span><span class="p">,</span> <span class="n">op_ax_pstar</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">_expectation_value_args</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="n">ax_p</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">ax_pstar</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
            <span class="n">LP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_LP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_RP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_op</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">(</span><span class="n">op_ax_p</span> <span class="o">+</span> <span class="n">op_ax_pstar</span><span class="p">,</span> <span class="n">ax_p</span> <span class="o">+</span> <span class="n">ax_pstar</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">th_labels</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>  <span class="c1"># vL, vR, p0, p1, ...</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">ax_pstar</span><span class="p">,</span> <span class="n">ax_p</span><span class="p">])</span>  <span class="c1"># same labels</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>  <span class="c1"># axes_p + (vR*, vR)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">])</span>  <span class="c1"># axes_p + (vR*, vL*)</span>
            <span class="n">C</span><span class="o">.</span><span class="n">ireplace_labels</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">])</span>  <span class="c1"># back to original theta labels</span>
            <span class="n">theta_bra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_theta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">theta_bra</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="n">th_labels</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">do_conj</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">norm</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">norm</span></div>

    <span class="k">def</span> <span class="nf">_contract_LP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">LP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Contract LP with the tensors on site `i` to form ``self._LP[i+1]``&quot;&quot;&quot;</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">LP</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">_p_label</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">])</span>
        <span class="c1"># for a ususal MPS, axes = ([&#39;p*&#39;, &#39;vL*&#39;], [&#39;p&#39;, &#39;vR*&#39;])</span>
        <span class="n">LP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">LP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LP</span>  <span class="c1"># labels &#39;vR*&#39;, &#39;vR&#39;</span>

    <span class="k">def</span> <span class="nf">_contract_RP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">RP</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Contract RP with the tensors on site `i` to form ``self._RP[i-1]``&quot;&quot;&quot;</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;vL&#39;</span><span class="p">))</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">_p_label</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vL*&#39;</span><span class="p">])</span>
        <span class="c1"># for a ususal MPS, axes = ([&#39;p*&#39;, &#39;vR*&#39;], [&#39;p&#39;, &#39;vL*&#39;])</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">RP</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">RP</span>  <span class="c1"># labels &#39;vL&#39;, &#39;vL*&#39;</span>

    <span class="k">def</span> <span class="nf">_to_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure `i` is a valid index (depending on `ket.bc`).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="o">.</span><span class="n">_to_valid_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>


<div class="viewcode-block" id="TransferMatrix"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.TransferMatrix.html#tenpy.networks.mpo.TransferMatrix">[docs]</a><span class="k">class</span> <span class="nc">TransferMatrix</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">NpcLinearOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transfer matrix of two MPS (bra &amp; ket).</span>

<span class="sd">    For an iMPS in the thermodynamic limit, we often need to find the &#39;dominant `RP`&#39; (and `LP`).</span>
<span class="sd">    This mean nothing else than to take the transfer matrix of the unit cell and find the</span>
<span class="sd">    (right/left) eigenvector with the largest (magnitude) eigenvalue, since it will dominate</span>
<span class="sd">    :math:`(TM)^n RP` (or :math:`LP (TM)^n`) in the limit :math:`n \rightarrow \infty` - whatever</span>
<span class="sd">    the initial `RP` is. This class provides exactly that functionality with :meth:`eigenvectors`.</span>

<span class="sd">    Given two MPS, we define the transfer matrix as::</span>

<span class="sd">        |    ---M[i]---M[i+1]- ... --M[i+L]---</span>
<span class="sd">        |       |      |             |</span>
<span class="sd">        |    ---N[j]*--N[j+1]* ... --N[j+L]*--</span>

<span class="sd">    Here the `M` denotes the matrices of the bra and `N` the ones of the ket, respectively.</span>
<span class="sd">    To view it as a `matrix`, we combine the left and right indices to pipes::</span>

<span class="sd">        |  (vL.vL*) -&gt;-TM-&gt;- (vR.vR*)   acting on  (vL.vL*) -&gt;-RP</span>

<span class="sd">    Note that we keep all M and N as copies.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bra : MPS</span>
<span class="sd">        The MPS which is to be (complex) conjugated.</span>
<span class="sd">    ket : MPS</span>
<span class="sd">        The MPS which is not (complex) conjugated.</span>
<span class="sd">    shift_bra : int</span>
<span class="sd">        We start the `N` of the bra at site `shift_bra` (i.e. the `j` in the above network).</span>
<span class="sd">    shift_ket : int | None</span>
<span class="sd">        We start the `M` of the ket at site `shift_ket` (i.e. the `i` in the above network).</span>
<span class="sd">        ``None`` defaults to `shift_bra`.</span>
<span class="sd">    transpose : bool</span>
<span class="sd">        Wheter `self.matvec` acts on `RP` (``False``) or `LP` (``True``).</span>
<span class="sd">    charge_sector : None | charges | ``0``</span>
<span class="sd">        Selects the charge sector of the vector onto which the Linear operator acts.</span>
<span class="sd">        ``None`` stands for *all* sectors, ``0`` stands for the zero-charge sector.</span>
<span class="sd">        Defaults to ``0``, i.e., *assumes* the dominant eigenvector is in charge sector 0.</span>
<span class="sd">    form : ``&#39;B&#39; | &#39;A&#39; | &#39;C&#39; | &#39;G&#39; | &#39;Th&#39; | None`` | tuple(float, float)</span>
<span class="sd">        In which canonical form we take the `M` and `N` matrices.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        Number of physical sites involved in the transfer matrix, i.e. the least common multiple</span>
<span class="sd">        of `bra.L` and `ket.L`.</span>
<span class="sd">    shift_bra : int</span>
<span class="sd">        We start the `N` of the bra at site `shift_bra`.</span>
<span class="sd">    shift_ket : int | None</span>
<span class="sd">        We start the `M` of the ket at site `shift_ket`. ``None`` defaults to `shift_bra`.</span>
<span class="sd">    transpose : bool</span>
<span class="sd">        Wheter `self.matvec` acts on `RP` (``True``) or `LP` (``False``).</span>
<span class="sd">    qtotal : charges</span>
<span class="sd">        Total charge of the transfer matrix (which is gauged away in matvec).</span>
<span class="sd">    form : tuple(float, float) | None</span>
<span class="sd">        In which canonical form (all of) the `M` and `N` matrices are.</span>
<span class="sd">    flat_linop : :class:`~tenpy.linalg.sparse.FlatLinearOperator`</span>
<span class="sd">        Class lifting :meth:`matvec` to ndarrays in order to use :func:`~tenpy.tools.math.speigs`.</span>
<span class="sd">    pipe : :class:`~tenpy.linalg.charges.LegPipe`</span>
<span class="sd">        Pipe corresponding to ``&#39;(vL.vL*)&#39;`` for ``transpose=False``</span>
<span class="sd">        or to ``&#39;(vR.vR*)&#39;`` for ``transpose=True``.</span>
<span class="sd">    label_split :</span>
<span class="sd">        ``[&#39;vL&#39;, &#39;vL*&#39;]`` if ``tranpose=False`` or ``[&#39;vR&#39;, &#39;vR*&#39;]`` if ``transpose=True``.</span>
<span class="sd">    _bra_N : list of npc.Array</span>
<span class="sd">        Complex conjugated matrices of the bra, transposed for fast `matvec`.</span>
<span class="sd">    _ket_M : list of npc.Array</span>
<span class="sd">        The matrices of the ket, transposed for fast `matvec`.</span>
<span class="sd">    _contract_legs : int</span>
<span class="sd">        Number of physical legs per site + 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">bra</span><span class="p">,</span>
                 <span class="n">ket</span><span class="p">,</span>
                 <span class="n">shift_bra</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">shift_ket</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">charge_sector</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">form</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">bra</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">ket</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shift_ket</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_ket</span> <span class="o">=</span> <span class="n">shift_bra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_bra</span> <span class="o">=</span> <span class="n">shift_bra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_ket</span> <span class="o">=</span> <span class="n">shift_ket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span> <span class="o">=</span> <span class="n">transpose</span>
        <span class="k">if</span> <span class="n">ket</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="n">bra</span><span class="o">.</span><span class="n">chinfo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible charges&quot;</span><span class="p">)</span>
        <span class="n">form</span> <span class="o">=</span> <span class="n">ket</span><span class="o">.</span><span class="n">_to_valid_form</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">ket</span><span class="o">.</span><span class="n">_p_label</span>  <span class="c1"># for ususal MPS just [&#39;p&#39;]</span>
        <span class="k">assert</span> <span class="n">p</span> <span class="o">==</span> <span class="n">bra</span><span class="o">.</span><span class="n">_p_label</span>
        <span class="n">pstar</span> <span class="o">=</span> <span class="n">ket</span><span class="o">.</span><span class="n">_get_p_label</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span> <span class="c1"># [&#39;p*&#39;]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transpose</span><span class="p">:</span>  <span class="c1"># right to left</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;(vL.vL*)&#39;</span>  <span class="c1"># what we act on</span>
            <span class="n">label_split</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vL&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">]</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ket_M</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ket</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">shift_ket</span><span class="p">,</span> <span class="n">shift_ket</span> <span class="o">+</span> <span class="n">L</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bra_N</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">bra</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="n">pstar</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">shift_bra</span><span class="p">,</span> <span class="n">shift_bra</span> <span class="o">+</span> <span class="n">L</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegPipe</span><span class="p">([</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR&#39;</span><span class="p">),</span> <span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vR*&#39;</span><span class="p">)],</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># left to right</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;(vR*.vR)&#39;</span>  <span class="c1"># mathematically more natural</span>
            <span class="n">label_split</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vR&#39;</span><span class="p">]</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ket_M</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ket</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;vL&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vR&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shift_ket</span><span class="p">,</span> <span class="n">shift_ket</span> <span class="o">+</span> <span class="n">L</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bra_N</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">bra</span><span class="o">.</span><span class="n">get_B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;vL*&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pstar</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shift_bra</span><span class="p">,</span> <span class="n">shift_bra</span> <span class="o">+</span> <span class="n">L</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">LegPipe</span><span class="p">([</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL*&#39;</span><span class="p">),</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_leg</span><span class="p">(</span><span class="s1">&#39;vL&#39;</span><span class="p">)],</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">bra</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ket</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_split</span> <span class="o">=</span> <span class="n">label_split</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flat_linop</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">FlatLinearOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matvec</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">charge_sector</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="n">bra</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">B</span><span class="o">.</span><span class="n">qtotal</span> <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">M</span> <span class="o">+</span> <span class="n">N</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contract_legs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ket</span><span class="o">.</span><span class="n">_p_label</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># for a ususal MPS: 2</span>

<div class="viewcode-block" id="TransferMatrix.matvec"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.TransferMatrix.html#tenpy.networks.mpo.TransferMatrix.matvec">[docs]</a>    <span class="k">def</span> <span class="nf">matvec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given `vec` as an npc.Array, apply the transfer matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Vector to act on with the transfermatrix.</span>
<span class="sd">            If not `transposed`, `vec` is the right part `RP` of an environment,</span>
<span class="sd">            with legs ``&#39;(vL.vL*)&#39;`` in a pipe or splitted.</span>
<span class="sd">            If `transposed`, the left part `LP` of an environment with legs ``&#39;(vR*.vR)&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mat_vec : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The tranfer matrix acted on `vec`, in the same form as given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pipe</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">vec</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">split_legs</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pipe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipe</span>
        <span class="n">vec</span><span class="o">.</span><span class="n">itranspose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_split</span><span class="p">)</span>  <span class="c1"># [&#39;vL&#39;, &#39;vL*&#39;] or [&#39;vR*&#39;, &#39;vR&#39;]</span>
        <span class="n">qtotal</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">qtotal</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">legs</span>
        <span class="n">contract</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_legs</span>  <span class="c1"># number of physical legs per site + 1</span>
        <span class="c1"># the actual work</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">:</span>  <span class="c1"># right to left</span>
            <span class="k">for</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bra_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ket_M</span><span class="p">):</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># axes=[&#39;vR&#39;, &#39;vL&#39;]</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">contract</span><span class="p">)</span>  <span class="c1"># [[&#39;p&#39;, &#39;vL*&#39;], [&#39;p*&#39;, &#39;vR*&#39;]]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># left to right</span>
            <span class="k">for</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bra_N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ket_M</span><span class="p">):</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># axes=[&#39;vR&#39;, &#39;vL&#39;]</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">contract</span><span class="p">)</span>  <span class="c1"># [[&#39;vL*&#39;, &#39;p*&#39;], [&#39;vR*&#39;, &#39;p&#39;]])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Hack: replace leg charges and qtotal -&gt; effectively gauge `self.qtotal` away.</span>
            <span class="n">vec</span><span class="o">.</span><span class="n">qtotal</span> <span class="o">=</span> <span class="n">qtotal</span>
            <span class="n">vec</span><span class="o">.</span><span class="n">legs</span> <span class="o">=</span> <span class="n">legs</span>
            <span class="n">vec</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>  <span class="c1"># Should be fine, but who knows...</span>
        <span class="k">if</span> <span class="n">pipe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pipes</span><span class="o">=</span><span class="n">pipe</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vec</span></div>

<div class="viewcode-block" id="TransferMatrix.initial_guess"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.TransferMatrix.html#tenpy.networks.mpo.TransferMatrix.initial_guess">[docs]</a>    <span class="k">def</span> <span class="nf">initial_guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a diagonal matrix as initial guess for the eigenvector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        diag : float | 1D ndarray</span>
<span class="sd">            Should be ``1.`` for the identity or some singular values squared.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mat : :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            A 2D array with `diag` on the diagonal such that :meth:`matvec` can act on it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">npc</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipe</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_split</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransferMatrix.eigenvectors"><a class="viewcode-back" href="../../../reference/tenpy.networks.mps.TransferMatrix.html#tenpy.networks.mpo.TransferMatrix.eigenvectors">[docs]</a>    <span class="k">def</span> <span class="nf">eigenvectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">num_ev</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">max_num_ev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">,</span>
                     <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span>
                     <span class="n">v0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find (dominant) eigenvector(s) of self using :mod:`scipy.sparse`.</span>

<span class="sd">        If no charge_sector was selected, we look in *all* charge sectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_ev : int</span>
<span class="sd">            Number of eigenvalues/vectors to look for.</span>
<span class="sd">        max_num_ev : int</span>
<span class="sd">            :func:`scipy.sparse.linalg.speigs` somtimes raises a NoConvergenceError for small</span>
<span class="sd">            `num_ev`, which might be avoided by increasing `num_ev`. As a work-around,</span>
<span class="sd">            we try it again in the case of an error, just with larger `num_ev` up to `max_num_ev`.</span>
<span class="sd">            ``None`` defaults to ``num_ev + 2``.</span>
<span class="sd">        max_tol : float</span>
<span class="sd">            After the first `NoConvergenceError` we increase the `tol` argument to that value.</span>
<span class="sd">        which : str</span>
<span class="sd">            Which eigenvalues to look for, see `scipy.sparse.linalg.speigs`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Further keyword arguments are given to :func:`~tenpy.tools.math.speigs`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eta : 1D ndarray</span>
<span class="sd">            The eigenvalues, sorted according to `which`.</span>
<span class="sd">        w : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            The eigenvectors corresponding to `eta`, as npc.Array with LegPipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_num_ev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_num_ev</span> <span class="o">=</span> <span class="n">num_ev</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">flat_linop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_linop</span>
        <span class="k">if</span> <span class="n">flat_linop</span><span class="o">.</span><span class="n">charge_sector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Try for all charge sectors</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">chsect</span> <span class="ow">in</span> <span class="n">flat_linop</span><span class="o">.</span><span class="n">possible_charge_sectors</span><span class="p">:</span>
                <span class="n">flat_linop</span><span class="o">.</span><span class="n">charge_sector</span> <span class="o">=</span> <span class="n">chsect</span>
                <span class="n">eta_cs</span><span class="p">,</span> <span class="n">A_cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvectors</span><span class="p">(</span><span class="n">num_ev</span><span class="p">,</span> <span class="n">max_num_ev</span><span class="p">,</span> <span class="n">max_tol</span><span class="p">,</span> <span class="n">which</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">eta_cs</span><span class="p">)</span>
                <span class="n">A</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">A_cs</span><span class="p">)</span>
            <span class="n">flat_linop</span><span class="o">.</span><span class="n">charge_sector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_linop</span><span class="o">.</span><span class="n">npc_to_flat</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
            <span class="c1"># for given charge sector</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_ev</span><span class="p">,</span> <span class="n">max_num_ev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">num_ev</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;TransferMatrix: increased `num_ev` to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">eta</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">speigs</span><span class="p">(</span><span class="n">flat_linop</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;LM&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real_if_close</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">flat_linop</span><span class="o">.</span><span class="n">flat_to_npc</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigen</span><span class="o">.</span><span class="n">arpack</span><span class="o">.</span><span class="n">ArpackNoConvergence</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">max_num_ev</span><span class="p">:</span>
                        <span class="k">raise</span>
                <span class="c1"># just retry with larger k and &#39;tol&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_tol</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tol&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># sort</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="n">which</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eta</span><span class="p">)[</span><span class="n">perm</span><span class="p">],</span> <span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Tenpy Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Apr 11, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.0.
    </div>
  </body>
</html>