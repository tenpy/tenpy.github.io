
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tenpy.models.model &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tenpy.models.model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module contains some base classes for models.</span>

<span class="sd">A &#39;model&#39; is supposed to represent a Hamiltonian in a generalized way.</span>
<span class="sd">The :class:`~tenpy.models.lattice.Lattice` specifies the geometry and</span>
<span class="sd">underlying Hilbert space, and is thus common to all models.</span>
<span class="sd">It is needed to intialize the common base class :class:`Model` of all models.</span>

<span class="sd">Different algorithms require different representations of the Hamiltonian.</span>
<span class="sd">For example for DMRG, the Hamiltonian needs to be given as an MPO,</span>
<span class="sd">while TEBD needs the Hamiltonian to be represented by &#39;nearest neighbor&#39; bond terms.</span>
<span class="sd">This module contains the base classes defining these possible representations,</span>
<span class="sd">namley the :class:`MPOModel` and :class:`NearestNeigborModel`.</span>

<span class="sd">A particular model like the :class:`~tenpy.models.models.xxz_chain.XXZ_chain` should then</span>
<span class="sd">yet another class derived from these classes. In it&#39;s __init__, it needs to explicitly call</span>
<span class="sd">the ``MPOModel.__init__(self, lattice, H_MPO)``, providing an MPO representation of H,</span>
<span class="sd">and also the ``NearestNeigborModel.__init__(self, lattice, H_bond)``,</span>
<span class="sd">providing a representation of H by bond terms `H_bond`.</span>

<span class="sd">The :class:`CouplingModel` is the attempt to generalize the representation of `H`</span>
<span class="sd">by explicitly specifying the couplings in a general way, and providing functionality</span>
<span class="sd">for converting them into `H_MPO` and `H_bond`.</span>
<span class="sd">This allows to quickly generate new model classes for a very broad class of Hamiltonians.</span>

<span class="sd">For simplicity, the :class:`CouplingModel` is limited to interactions involving only two sites.</span>
<span class="sd">Yet, we also provide the :class:`MultiCouplingModel` to generate Models for Hamiltonians</span>
<span class="sd">involving couplings between multiple sites.</span>

<span class="sd">The :class:`CouplingMPOModel` aims at structuring the initialization for most models and is used</span>
<span class="sd">as base class in (most of) the predefined models in TeNPy.</span>

<span class="sd">See also the introduction in :doc:`/intro_model`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.lattice</span> <span class="k">import</span> <span class="n">get_lattice</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">TrivialLattice</span>
<span class="kn">from</span> <span class="nn">..linalg</span> <span class="k">import</span> <span class="n">np_conserved</span> <span class="k">as</span> <span class="n">npc</span>
<span class="kn">from</span> <span class="nn">..linalg.charges</span> <span class="k">import</span> <span class="n">QTYPE</span><span class="p">,</span> <span class="n">LegCharge</span>
<span class="kn">from</span> <span class="nn">..tools.misc</span> <span class="k">import</span> <span class="n">to_array</span><span class="p">,</span> <span class="n">add_with_None_0</span>
<span class="kn">from</span> <span class="nn">..tools.params</span> <span class="k">import</span> <span class="n">get_parameter</span><span class="p">,</span> <span class="n">unused_parameters</span>
<span class="kn">from</span> <span class="nn">..networks</span> <span class="k">import</span> <span class="n">mpo</span>  <span class="c1"># used to construct the Hamiltonian as MPO</span>
<span class="kn">from</span> <span class="nn">..networks.mps</span> <span class="k">import</span> <span class="n">OnsiteTerms</span><span class="p">,</span> <span class="n">CouplingTerms</span><span class="p">,</span> <span class="n">MultiCouplingTerms</span>
<span class="kn">from</span> <span class="nn">..networks.site</span> <span class="k">import</span> <span class="n">group_sites</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Model&#39;</span><span class="p">,</span> <span class="s1">&#39;NearestNeighborModel&#39;</span><span class="p">,</span> <span class="s1">&#39;MPOModel&#39;</span><span class="p">,</span> <span class="s1">&#39;CouplingModel&#39;</span><span class="p">,</span> <span class="s1">&#39;MultiCouplingModel&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CouplingMPOModel&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Model"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.Model">[docs]</a><span class="k">class</span> <span class="nc">Model</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for all models.</span>

<span class="sd">    The common base to all models is the underlying Hilbert space and geometry, specified by a</span>
<span class="sd">    :class:`~tenpy.model.lattice.Lattice`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lattice : :class:`~tenpy.model.lattice.Lattice`</span>
<span class="sd">        The lattice defining the geometry and the local Hilbert space(s).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    lat : :class:`~tenpy.model.lattice.Lattice`</span>
<span class="sd">        The lattice defining the geometry and the local Hilbert space(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">):</span>
        <span class="c1"># NOTE: every subclass like CouplingModel, MPOModel, NearestNeigborModel calls this</span>
        <span class="c1"># __init__, so it get&#39;s called multiple times when a user implements e.g. a</span>
        <span class="c1"># class MyModel(CouplingModel, NearestNeigborModel, MPOModel).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">):</span>
            <span class="c1"># first call: initialize everything</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">lattice</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Model.__init__() got called before</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lattice</span><span class="p">:</span>  <span class="c1"># expect the *same instance*!</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model.__init__() called with different lattice instances.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Model.group_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.Model.group_sites">[docs]</a>    <span class="k">def</span> <span class="nf">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify `self` in place to group sites.</span>

<span class="sd">        Group each `n` sites together using the :class:`~tenpy.networks.site.GroupedSite`.</span>
<span class="sd">        This might allow to do TEBD with a Trotter decomposition,</span>
<span class="sd">        or help the convergence of DMRG (in case of too long range interactions).</span>

<span class="sd">        This has to be done after finishing initialization and can not be reverted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of sites to be grouped together.</span>
<span class="sd">        grouped_sites : None | list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grouped_sites : list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grouped_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grouped_sites</span> <span class="o">=</span> <span class="n">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">charges</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">grouped_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_sites</span> <span class="o">==</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">TrivialLattice</span><span class="p">(</span><span class="n">grouped_sites</span><span class="p">,</span> <span class="n">bc_MPS</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;periodic&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped_sites</span></div></div>


<div class="viewcode-block" id="NearestNeighborModel"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.NearestNeighborModel">[docs]</a><span class="k">class</span> <span class="nc">NearestNeighborModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for a model of nearest neigbor interactions w.r.t. the MPS index.</span>

<span class="sd">    In this class, the Hamiltonian :math:`H = \sum_{i} H_{i,i+1}` is represented by</span>
<span class="sd">    &quot;bond terms&quot; :math:`H_{i,i+1}` acting only on two neighboring sites `i` and `i+1`,</span>
<span class="sd">    where `i` is an integer.</span>
<span class="sd">    Instances of this class are suitable for :mod:`~tenpy.algorithms.tebd`.</span>

<span class="sd">    Note that the &quot;nearest-neighbor&quot; in the name referst to the MPS index, not the lattice.</span>
<span class="sd">    In short, this works only for 1-dimensional (1D) nearest-neighbor models:</span>
<span class="sd">    A 2D lattice is internally mapped to a 1D MPS &quot;snake&quot;, and even a nearest-neighbor coupling</span>
<span class="sd">    in 2D becomes long-range in the MPS chain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lattice : :class:`tenpy.model.lattice.Lattice`</span>
<span class="sd">        The lattice defining the geometry and the local Hilbert space(s).</span>
<span class="sd">    H_bond : list of {:class:`~tenpy.linalg.np_conserved.Array` | None}</span>
<span class="sd">        The Hamiltonian rewritten as ``sum_i H_bond[i]`` for MPS indices ``i``.</span>
<span class="sd">        ``H_bond[i]`` acts on sites ``(i-1, i)``; we require ``len(H_bond) == lat.N_sites``.</span>
<span class="sd">        Legs of each ``H_bond[i]`` are ``[&#39;p0&#39;, &#39;p0*&#39;, &#39;p1&#39;, &#39;p1*&#39;]``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    H_bond : list of {:class:`~tenpy.linalg.np_conserved.Array` | None}</span>
<span class="sd">        The Hamiltonian rewritten as ``sum_i H_bond[i]`` for MPS indices ``i``.</span>
<span class="sd">        ``H_bond[i]`` acts on sites ``(i-1, i)``, ``None`` represents 0.</span>
<span class="sd">        Legs of each ``H_bond[i]`` are ``[&#39;p0&#39;, &#39;p0*&#39;, &#39;p1&#39;, &#39;p1*&#39;]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">H_bond</span><span class="p">):</span>
        <span class="n">Model</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">H_bond</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">!=</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">NearestNeighborModel</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># like self.test_sanity(), but use the version defined below even for derived class</span>

<div class="viewcode-block" id="NearestNeighborModel.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.NearestNeighborModel.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of H_bond&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="NearestNeighborModel.trivial_like_NNModel"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.NearestNeighborModel.trivial_like_NNModel">[docs]</a>    <span class="k">def</span> <span class="nf">trivial_like_NNModel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a NearestNeighborModel with same lattice, but trivial (H=0) bonds.&quot;&quot;&quot;</span>
        <span class="n">triv_H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">()</span> <span class="k">if</span> <span class="n">H</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">NearestNeighborModel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">triv_H</span><span class="p">)</span></div>

<div class="viewcode-block" id="NearestNeighborModel.bond_energies"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.NearestNeighborModel.bond_energies">[docs]</a>    <span class="k">def</span> <span class="nf">bond_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate bond energies &lt;psi|H_bond|psi&gt;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        psi : :class:`~tenpy.networks.mps.MPS`</span>
<span class="sd">            The MPS for which the bond energies should be calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        E_bond : 1D ndarray</span>
<span class="sd">            List of bond energies: for finite bc, ``E_Bond[i]`` is the energy of bond ``i, i+1``.</span>
<span class="sd">            (i.e. we omit bond 0 between sites L-1 and 0);</span>
<span class="sd">            for infinite bc ``E_bond[i]`` is the energy of bond ``i-1, i``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">]))</span>
        <span class="c1"># else</span>
        <span class="k">return</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">]))</span></div>

<div class="viewcode-block" id="NearestNeighborModel.group_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.NearestNeighborModel.group_sites">[docs]</a>    <span class="k">def</span> <span class="nf">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify `self` in place to group sites.</span>

<span class="sd">        Group each `n` sites together using the :class:`~tenpy.networks.site.GroupedSite`.</span>
<span class="sd">        This might allow to do TEBD with a Trotter decomposition,</span>
<span class="sd">        or help the convergence of DMRG (in case of too long range interactions).</span>

<span class="sd">        This has to be done after finishing initialization and can not be reverted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of sites to be grouped together.</span>
<span class="sd">        grouped_sites : None | list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grouped_sites : list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grouped_sites</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">group_sites</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="p">)</span>
        <span class="n">old_L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">)</span>
        <span class="n">new_L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_sites</span><span class="p">)</span>
        <span class="n">finite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">H_bond</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">new_L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># old index</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">gs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grouped_sites</span><span class="p">):</span>
            <span class="c1"># calculate new_Hb on bond (k, k+1)</span>
            <span class="n">next_gs</span> <span class="o">=</span> <span class="n">grouped_sites</span><span class="p">[(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">new_L</span><span class="p">]</span>
            <span class="n">new_H_onsite</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># collect old H_bond terms inside `gs`</span>
            <span class="k">if</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span><span class="p">):</span>
                    <span class="n">old_Hb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="n">old_L</span><span class="p">]</span>
                    <span class="n">add_H_onsite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_sites_Hb_to_onsite</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">old_Hb</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_H_onsite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_H_onsite</span> <span class="o">=</span> <span class="n">add_H_onsite</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_H_onsite</span> <span class="o">=</span> <span class="n">new_H_onsite</span> <span class="o">+</span> <span class="n">add_H_onsite</span>
            <span class="n">old_Hb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span><span class="p">)</span> <span class="o">%</span> <span class="n">old_L</span><span class="p">]</span>
            <span class="n">new_Hb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_sites_Hb_to_bond</span><span class="p">(</span><span class="n">gs</span><span class="p">,</span> <span class="n">next_gs</span><span class="p">,</span> <span class="n">old_Hb</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_H_onsite</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">new_L</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">finite</span><span class="p">:</span>
                    <span class="c1"># infinite or in the bulk: add new_H_onsite to new_Hb</span>
                    <span class="n">add_Hb</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">new_H_onsite</span><span class="p">,</span> <span class="n">next_gs</span><span class="o">.</span><span class="n">Id</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">new_Hb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">new_Hb</span> <span class="o">=</span> <span class="n">add_Hb</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_Hb</span> <span class="o">=</span> <span class="n">new_Hb</span> <span class="o">+</span> <span class="n">add_Hb</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># finite and k = new_L - 1</span>
                    <span class="c1"># the new_H_onsite needs to be added to the right-most Hb</span>
                    <span class="n">add_Hb</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">prev_gs</span><span class="o">.</span><span class="n">Id</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">]),</span> <span class="n">new_H_onsite</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">H_bond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">H_bond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_Hb</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">H_bond</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_Hb</span> <span class="o">+</span> <span class="n">add_Hb</span>
            <span class="n">k2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">new_L</span>
            <span class="k">if</span> <span class="n">H_bond</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">H_bond</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_Hb</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H_bond</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_bond</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_Hb</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">gs</span><span class="o">.</span><span class="n">n_sites</span>
        <span class="k">for</span> <span class="n">Hb</span> <span class="ow">in</span> <span class="n">H_bond</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Hb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">Hb</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span> <span class="o">=</span> <span class="n">H_bond</span>
        <span class="k">return</span> <span class="n">grouped_sites</span></div>

    <span class="k">def</span> <span class="nf">_group_sites_Hb_to_onsite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr_site</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">old_Hb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;kroneckerproduct for H_bond term within a GroupedSite.</span>

<span class="sd">        `old_Hb` acts on sites (j-1, j) of `gr_sites`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">old_Hb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">old_Hb</span> <span class="o">=</span> <span class="n">old_Hb</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">Id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gr_site</span><span class="o">.</span><span class="n">sites</span><span class="p">[:</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">old_Hb</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">Id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gr_site</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">Hb</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Hb</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">gr_site</span><span class="o">.</span><span class="n">n_sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">gr_site</span><span class="o">.</span><span class="n">n_sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">))]</span>
        <span class="n">pipe</span> <span class="o">=</span> <span class="n">gr_site</span><span class="o">.</span><span class="n">leg</span>
        <span class="n">Hb</span> <span class="o">=</span> <span class="n">Hb</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">combine</span><span class="p">,</span> <span class="n">pipes</span><span class="o">=</span><span class="p">[</span><span class="n">pipe</span><span class="p">,</span> <span class="n">pipe</span><span class="o">.</span><span class="n">conj</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">Hb</span>  <span class="c1"># labels would be &#39;p&#39;, &#39;p*&#39; w.r.t. gr_site.</span>

    <span class="k">def</span> <span class="nf">_group_sites_Hb_to_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr_site_L</span><span class="p">,</span> <span class="n">gr_site_R</span><span class="p">,</span> <span class="n">old_Hb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kroneckerproduct for H_bond term acting on two GroupedSites.</span>

<span class="sd">        `old_Hb` acts on the right-most site of `gr_site_L` and left-most site of `gr_site_R`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">old_Hb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">old_Hb</span> <span class="o">=</span> <span class="n">old_Hb</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">Id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gr_site_L</span><span class="o">.</span><span class="n">sites</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">old_Hb</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">Id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gr_site_R</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">Hb</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Hb</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="n">NL</span><span class="p">,</span> <span class="n">NR</span> <span class="o">=</span> <span class="n">gr_site_L</span><span class="o">.</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">gr_site_R</span><span class="o">.</span><span class="n">n_sites</span>
        <span class="n">pipeL</span><span class="p">,</span> <span class="n">pipeR</span> <span class="o">=</span> <span class="n">gr_site_L</span><span class="o">.</span><span class="n">leg</span><span class="p">,</span> <span class="n">gr_site_R</span><span class="o">.</span><span class="n">leg</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">NL</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">NL</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                   <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">NL</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">NL</span><span class="o">+</span><span class="n">NR</span><span class="p">),</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">NL</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">NL</span><span class="o">+</span><span class="n">NR</span><span class="p">),</span> <span class="mi">2</span><span class="p">))]</span>
        <span class="n">Hb</span> <span class="o">=</span> <span class="n">Hb</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">(</span><span class="n">combine</span><span class="p">,</span> <span class="n">pipes</span><span class="o">=</span><span class="p">[</span><span class="n">pipeL</span><span class="p">,</span> <span class="n">pipeL</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">pipeR</span><span class="p">,</span> <span class="n">pipeR</span><span class="o">.</span><span class="n">conj</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">Hb</span>  <span class="c1"># labels would be &#39;p0&#39;, &#39;p0*&#39;, &#39;p1&#39;, &#39;p1*&#39; w.r.t. gr_site_{L,R}</span>

<div class="viewcode-block" id="NearestNeighborModel.calc_H_MPO_from_bond"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.NearestNeighborModel.calc_H_MPO_from_bond">[docs]</a>    <span class="k">def</span> <span class="nf">calc_H_MPO_from_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_zero</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the MPO Hamiltonian from the bond Hamiltonian.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol_zero : float</span>
<span class="sd">            Arrays with norm &lt; `tol_zero` are considered to be zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H_MPO : :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">            MPO representation of the Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H_bond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span>  <span class="c1"># entry i acts on sites (i-1,i)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">Hb</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">Hb</span> <span class="ow">in</span> <span class="n">H_bond</span> <span class="k">if</span> <span class="n">Hb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[])</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">()</span>
        <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">onsite_terms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">L</span>  <span class="c1"># onsite terms on each site `i`</span>
        <span class="n">bond_XYZ</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">L</span>  <span class="c1"># svd of couplings on each bond (i-1, i)</span>
        <span class="n">chis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_bond</span><span class="p">)</span> <span class="o">==</span> <span class="n">L</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Hb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">H_bond</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Hb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">L</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="n">Hb</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
            <span class="n">d_L</span><span class="p">,</span> <span class="n">d_R</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dim</span>  <span class="c1"># dimension of local hilbert space:</span>
            <span class="n">Id_L</span><span class="p">,</span> <span class="n">Id_R</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">sites</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Id</span>
            <span class="c1"># project on onsite-terms by contracting with identities; Tr(Id_{L/R}) = d_{L/R}</span>
            <span class="n">onsite_L</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Hb</span><span class="p">,</span> <span class="n">Id_R</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">]))</span> <span class="o">/</span> <span class="n">d_R</span>
            <span class="k">if</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">onsite_L</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_zero</span><span class="p">:</span>
                <span class="n">Hb</span> <span class="o">-=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">onsite_L</span><span class="p">,</span> <span class="n">Id_R</span><span class="p">)</span>
                <span class="n">onsite_terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_with_None_0</span><span class="p">(</span><span class="n">onsite_terms</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">onsite_L</span><span class="p">)</span>
            <span class="n">onsite_R</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Id_L</span><span class="p">,</span> <span class="n">Hb</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]))</span> <span class="o">/</span> <span class="n">d_L</span>
            <span class="k">if</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">onsite_R</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_zero</span><span class="p">:</span>
                <span class="n">Hb</span> <span class="o">-=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Id_L</span><span class="p">,</span> <span class="n">onsite_R</span><span class="p">)</span>
                <span class="n">onsite_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_with_None_0</span><span class="p">(</span><span class="n">onsite_terms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">onsite_R</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Hb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol_zero</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="n">Hb</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">]])</span>
            <span class="n">chinfo</span> <span class="o">=</span> <span class="n">Hb</span><span class="o">.</span><span class="n">chinfo</span>
            <span class="n">qtotal</span> <span class="o">=</span> <span class="p">[</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(),</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">()]</span>  <span class="c1"># zero charge</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">Hb</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">tol_zero</span><span class="p">,</span> <span class="n">inner_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">],</span> <span class="n">qtotal_LR</span><span class="o">=</span><span class="n">qtotal</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">chis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">split_legs</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">YZ</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">iscale_axis</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">split_legs</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">bond_XYZ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">YZ</span><span class="p">)</span>
            <span class="n">chinfo</span> <span class="o">=</span> <span class="n">Hb</span><span class="o">.</span><span class="n">chinfo</span>
        <span class="c1"># construct the legs</span>
        <span class="n">legs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># legs[i] is leg &#39;wL&#39; left of site i with qconj=+1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">L</span> <span class="ow">and</span> <span class="n">bc</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
                <span class="n">legs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="n">chi</span> <span class="o">=</span> <span class="n">chis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">qflat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">chi</span><span class="p">,</span> <span class="n">chinfo</span><span class="o">.</span><span class="n">qnumber</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">QTYPE</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chi</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">YZ</span> <span class="o">=</span> <span class="n">bond_XYZ</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">qflat</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_qflat</span><span class="p">()</span>
            <span class="n">leg</span> <span class="o">=</span> <span class="n">LegCharge</span><span class="o">.</span><span class="n">from_qflat</span><span class="p">(</span><span class="n">chinfo</span><span class="p">,</span> <span class="n">qflat</span><span class="p">,</span> <span class="n">qconj</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">legs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">leg</span>
        <span class="c1"># now construct the W tensors</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">wL</span><span class="p">,</span> <span class="n">wR</span> <span class="o">=</span> <span class="n">legs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">legs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">leg</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">wL</span><span class="p">,</span> <span class="n">wR</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">conj</span><span class="p">()],</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Id</span>
            <span class="n">W</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Id</span>
            <span class="n">onsite</span> <span class="o">=</span> <span class="n">onsite_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">onsite</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">onsite</span>
            <span class="k">if</span> <span class="n">bond_XYZ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">YZ</span> <span class="o">=</span> <span class="n">bond_XYZ</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">YZ</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">L</span>
            <span class="k">if</span> <span class="n">bond_XYZ</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bond_XYZ</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">])</span>
            <span class="n">W</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">])</span>
            <span class="n">Ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span>
        <span class="n">H_MPO</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">MPO</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">Ws</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_MPO</span></div></div>


<div class="viewcode-block" id="MPOModel"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MPOModel">[docs]</a><span class="k">class</span> <span class="nc">MPOModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for a model with an MPO representation of the Hamiltonian.</span>

<span class="sd">    In this class, the Hamiltonian gets represented by an :class:`~tenpy.networks.mpo.MPO`.</span>
<span class="sd">    Thus, instances of this class are suitable for MPO-based algorithms like DMRG</span>
<span class="sd">    :mod:`~tenpy.algorithms.dmrg` and MPO time evolution.</span>

<span class="sd">    .. todo ::</span>
<span class="sd">        implement MPO for time evolution...</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    H_MPO : :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">        The Hamiltonian rewritten as an MPO.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    H_MPO : :class:`tenpy.networks.mpo.MPO`</span>
<span class="sd">        MPO representation of the Hamiltonian.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">H_MPO</span><span class="p">):</span>
        <span class="n">Model</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_MPO</span> <span class="o">=</span> <span class="n">H_MPO</span>
        <span class="n">MPOModel</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># like self.test_sanity(), but use the version defined below even for derived class</span>

<div class="viewcode-block" id="MPOModel.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MPOModel.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_MPO</span><span class="o">.</span><span class="n">sites</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lattice incompatible with H_MPO.sites&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MPOModel.group_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MPOModel.group_sites">[docs]</a>    <span class="k">def</span> <span class="nf">group_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Modify `self` in place to group sites.</span>

<span class="sd">        Group each `n` sites together using the :class:`~tenpy.networks.site.GroupedSite`.</span>
<span class="sd">        This might allow to do TEBD with a Trotter decomposition,</span>
<span class="sd">        or help the convergence of DMRG (in case of too long range interactions).</span>

<span class="sd">        This has to be done after finishing initialization and can not be reverted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of sites to be grouped together.</span>
<span class="sd">        grouped_sites : None | list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grouped_sites : list of :class:`~tenpy.networks.site.GroupedSite`</span>
<span class="sd">            The sites grouped together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grouped_sites</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">group_sites</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_MPO</span><span class="o">.</span><span class="n">group_sites</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">grouped_sites</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped_sites</span></div>

<div class="viewcode-block" id="MPOModel.calc_H_bond_from_MPO"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MPOModel.calc_H_bond_from_MPO">[docs]</a>    <span class="k">def</span> <span class="nf">calc_H_bond_from_MPO</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_zero</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the bond Hamiltonian from the MPO Hamiltonian.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol_zero : float</span>
<span class="sd">            Arrays with norm &lt; `tol_zero` are considered to be zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H_bond : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Bond terms as required by the constructor of :class:`NearestNeighborModel`.</span>
<span class="sd">            Legs are ``[&#39;p0&#39;, &#39;p0*&#39;, &#39;p1&#39;, &#39;p1*&#39;]``</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if the Hamiltonian contains longer-range terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H_MPO</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_MPO</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">sites</span>
        <span class="n">finite</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">finite</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">L</span>
        <span class="n">Ws</span> <span class="o">=</span> <span class="p">[</span><span class="n">H_MPO</span><span class="o">.</span><span class="n">get_W</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>
        <span class="c1"># Copy of Ws: we set everything to zero, which we take out and add to H_bond, such that</span>
        <span class="c1"># we can check that Ws is zero in the end to ensure that H didn&#39;t have long range couplings</span>
        <span class="n">H_onsite</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="n">H_bond</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span>
        <span class="c1"># first take out onsite terms and identities</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">W</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ws</span><span class="p">):</span>
            <span class="c1"># bond `a` is left of site i, bond `b` is right</span>
            <span class="n">IdL_a</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">IdL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">IdR_a</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">IdR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">IdL_b</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">IdL</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">IdR_b</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">IdR</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">W</span><span class="o">.</span><span class="n">itranspose</span><span class="p">([</span><span class="s1">&#39;wL&#39;</span><span class="p">,</span> <span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">])</span>
            <span class="n">H_onsite</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">IdL_a</span><span class="p">,</span> <span class="n">IdR_b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">W</span><span class="p">[</span><span class="n">IdL_a</span><span class="p">,</span> <span class="n">IdR_b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="c1"># remove Identities</span>
            <span class="k">if</span> <span class="n">IdR_a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="n">IdR_a</span><span class="p">,</span> <span class="n">IdR_b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="n">IdL_b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">W</span><span class="p">[</span><span class="n">IdL_a</span><span class="p">,</span> <span class="n">IdL_b</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.</span>
        <span class="c1"># now multiply together the bonds</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Wj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ws</span><span class="p">):</span>
            <span class="c1"># for bond (i, j) == (j-1, j) == (i, i+1)</span>
            <span class="k">if</span> <span class="n">finite</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">L</span>
            <span class="n">Wi</span> <span class="o">=</span> <span class="n">Ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">IdL_a</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">IdL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">IdR_c</span> <span class="o">=</span> <span class="n">H_MPO</span><span class="o">.</span><span class="n">IdR</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">Wi</span><span class="p">[</span><span class="n">IdL_a</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">Wj</span><span class="p">[:,</span> <span class="n">IdR_c</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;wR&#39;</span><span class="p">,</span> <span class="s1">&#39;wL&#39;</span><span class="p">))</span>
            <span class="n">Wi</span><span class="p">[</span><span class="n">IdL_a</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.</span>
            <span class="n">Wj</span><span class="p">[:,</span> <span class="n">IdR_c</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="mf">0.</span>
            <span class="c1"># Hb has legs p0, p0*, p1, p1*</span>
            <span class="n">H_bond</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hb</span>
        <span class="c1"># check that nothing is left</span>
        <span class="k">for</span> <span class="n">W</span> <span class="ow">in</span> <span class="n">Ws</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">npc</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_zero</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bond couplings didn&#39;t capture everything. &quot;</span>
                                 <span class="s2">&quot;Either H is long range or IdL/IdR is wrong!&quot;</span><span class="p">)</span>
        <span class="c1"># now merge the onsite terms to H_bond</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">finite</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">L</span>
            <span class="n">strength_i</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="n">finite</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.5</span>
            <span class="n">strength_j</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="n">finite</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">0.5</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="p">(</span><span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">strength_j</span> <span class="o">*</span> <span class="n">H_onsite</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span>
                  <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">strength_i</span> <span class="o">*</span> <span class="n">H_onsite</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sites</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Id</span><span class="p">))</span>
            <span class="n">Hb</span> <span class="o">=</span> <span class="n">add_with_None_0</span><span class="p">(</span><span class="n">H_bond</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">Hb</span><span class="p">)</span>
            <span class="n">Hb</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">,</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;p1*&#39;</span><span class="p">])</span>
            <span class="n">H_bond</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hb</span>
        <span class="k">if</span> <span class="n">finite</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">H_bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">H_bond</span></div></div>


<div class="viewcode-block" id="CouplingModel"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel">[docs]</a><span class="k">class</span> <span class="nc">CouplingModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for a general model of a Hamiltonian consisting of two-site couplings.</span>

<span class="sd">    In this class, the terms of the Hamiltonian are specified explicitly as</span>
<span class="sd">    :class:`~tenpy.networks.mps.OnsiteTerms` or :class:`~tenpy.networks.mps.CouplingTerms`.</span>

<span class="sd">    .. deprecated:: 0.4.0</span>
<span class="sd">        `bc_coupling` will be removed in 1.0.0. To specify the full geometry in the lattice,</span>
<span class="sd">        use the `bc` parameter of the :class:`~tenpy.model.latttice.Lattice`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lattice : :class:`~tenpy.model.lattice.Lattice`</span>
<span class="sd">        The lattice defining the geometry and the local Hilbert space(s).</span>
<span class="sd">    bc_coupling : (iterable of) {``&#39;open&#39;`` | ``&#39;periodic&#39;`` | ``int``}</span>
<span class="sd">        Boundary conditions of the couplings in each direction of the lattice. Defines how the</span>
<span class="sd">        couplings are added in :meth:`add_coupling`. A single string holds for all directions.</span>
<span class="sd">        An integer `shift` means that we have periodic boundary conditions along this direction,</span>
<span class="sd">        but shift/tilt by ``-shift*lattice.basis[0]`` (~cylinder axis for ``bc_MPS=&#39;infinite&#39;``)</span>
<span class="sd">        when going around the boundary along this direction.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    onsite_terms : {&#39;category&#39;: :class:`~tenpy.networks.mps.OnsiteTerms`}</span>
<span class="sd">        The :class:`~tenpy.networks.mps.OnsiteTerms` ordered by category.</span>
<span class="sd">    coupling_terms : {&#39;category&#39;: :class:`~tenpy.networks.mps.CouplingTerms`}</span>
<span class="sd">        The :class:`~tenpy.networks.mps.CouplingTerms` ordered by category.</span>
<span class="sd">        In a :class:`MultiCouplingModel`, values may also be :class:`MultiCouplingTerms`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">bc_coupling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Model</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bc_coupling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`bc_coupling` in CouplingModel: use `bc` in Lattice instead&quot;</span><span class="p">,</span>
                          <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">lattice</span><span class="o">.</span><span class="n">_set_bc</span><span class="p">(</span><span class="n">bc_coupling</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">CouplingModel</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># like self.test_sanity(), but use the version defined below even for derived class</span>

<div class="viewcode-block" id="CouplingModel.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity check. Raises ValueErrors, if something is wrong.&quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ot</span><span class="o">.</span><span class="n">_test_terms</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ct</span><span class="o">.</span><span class="n">_test_terms</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span></div>

<div class="viewcode-block" id="CouplingModel.add_onsite"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.add_onsite">[docs]</a>    <span class="k">def</span> <span class="nf">add_onsite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add onsite terms to :attr:`onsite_terms`.</span>

<span class="sd">        Adds a term :math:`\sum_{x_0, ..., x_{dim-1}} strength[x_0, ..., x_{dim-1}] * OP``,</span>
<span class="sd">        where the operator ``OP=lat.unit_cell[u].get_op(opname)``</span>
<span class="sd">        acts on the site given by a lattice index ``(x_0, ..., x_{dim-1}, u)``,</span>
<span class="sd">        to the represented Hamiltonian.</span>

<span class="sd">        The necessary terms are just added to :attr:`onsite_terms`; doesn&#39;t rebuild the MPO.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : scalar | array</span>
<span class="sd">            Prefactor of the onsite term. May vary spatially. If an array of smaller size</span>
<span class="sd">            is provided, it gets tiled to the required shape.</span>
<span class="sd">        u : int</span>
<span class="sd">            Picks a :class:`~tenpy.model.lattice.Site` ``lat.unit_cell[u]`` out of the unit cell.</span>
<span class="sd">        opname : str</span>
<span class="sd">            valid operator name of an onsite operator in ``lat.unit_cell[u]``.</span>
<span class="sd">        category : str</span>
<span class="sd">            Descriptive name used as key for :attr:`onsite_terms`. Defaults to `opname`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>  <span class="c1"># tile to lattice shape</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">strength</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">return</span>  <span class="c1"># nothing to do: can even accept non-defined `opname`.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">opname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown onsite operator </span><span class="si">{0!r}</span><span class="s2"> for u=</span><span class="si">{1:d}</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;</span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opname</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">opname</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">ot</span> <span class="o">=</span> <span class="n">OnsiteTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_lat_idx_fix_u</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
            <span class="n">ot</span><span class="o">.</span><span class="n">add_onsite_term</span><span class="p">(</span><span class="n">strength</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i_lat</span><span class="p">)],</span> <span class="n">i</span><span class="p">,</span> <span class="n">opname</span><span class="p">)</span></div>

<div class="viewcode-block" id="CouplingModel.add_onsite_term"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.add_onsite_term">[docs]</a>    <span class="k">def</span> <span class="nf">add_onsite_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an onsite term on a given MPS site.</span>

<span class="sd">        Wrapper for ``self.onsite_terms[category].add_onsite_term(...)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : float</span>
<span class="sd">            The strength of the term.</span>
<span class="sd">        i : int</span>
<span class="sd">            The MPS index of the site on which the operator acts.</span>
<span class="sd">            We require ``0 &lt;= i &lt; L``.</span>
<span class="sd">        op : str</span>
<span class="sd">            Name of the involved operator.</span>
<span class="sd">        category : str</span>
<span class="sd">            Descriptive name used as key for :attr:`onsite_terms`. Defaults to `op`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">op</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">ot</span> <span class="o">=</span> <span class="n">OnsiteTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="n">ot</span><span class="o">.</span><span class="n">add_onsite_term</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span></div>

<div class="viewcode-block" id="CouplingModel.all_onsite_terms"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.all_onsite_terms">[docs]</a>    <span class="k">def</span> <span class="nf">all_onsite_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum of all :attr:`onsite_terms`.&quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">()</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="n">OnsiteTerms</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsite_terms</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ot</span> <span class="o">+=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">ot</span></div>

<div class="viewcode-block" id="CouplingModel.add_coupling"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.add_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">add_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">strength</span><span class="p">,</span>
                     <span class="n">u1</span><span class="p">,</span>
                     <span class="n">op1</span><span class="p">,</span>
                     <span class="n">u2</span><span class="p">,</span>
                     <span class="n">op2</span><span class="p">,</span>
                     <span class="n">dx</span><span class="p">,</span>
                     <span class="n">op_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">str_on_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">raise_op2_left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</span>

<span class="sd">        Represents couplings of the form</span>
<span class="sd">        :math:`\sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP1 * OP2`, where</span>
<span class="sd">        ``OP1 := lat.unit_cell[u1].get_op(op1)`` acts on the site ``(x_0, ..., x_{dim-1}, u1)``,</span>
<span class="sd">        and ``OP2 := lat.unit_cell[u2].get_op(op2)`` acts on the site</span>
<span class="sd">        ``(x_0+dx[0], ..., x_{dim-1}+dx[dim-1], u2)``.</span>
<span class="sd">        Possible combinations ``x_0, ..., x_{dim-1}`` are determined from the boundary conditions</span>
<span class="sd">        in :meth:`~tenpy.models.lattice.Lattice.possible_couplings`.</span>

<span class="sd">        The coupling `strength` may vary spatially, :math:`loc(\vec{x})` indicates the lower</span>
<span class="sd">        left corner of the hypercube containing the involved sites :math:`\vec{x}` and</span>
<span class="sd">        :math:`\vec{x}+\vec{dx}`.</span>

<span class="sd">        The necessary terms are just added to :attr:`coupling_terms`; doesn&#39;t rebuild the MPO.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : scalar | array</span>
<span class="sd">            Prefactor of the coupling. May vary spatially (see above). If an array of smaller size</span>
<span class="sd">            is provided, it gets tiled to the required shape.</span>
<span class="sd">        u1 : int</span>
<span class="sd">            Picks the site ``lat.unit_cell[u1]`` for OP1.</span>
<span class="sd">        op1 : str</span>
<span class="sd">            Valid operator name of an onsite operator in ``lat.unit_cell[u1]`` for OP1.</span>
<span class="sd">        u2 : int</span>
<span class="sd">            Picks the site ``lat.unit_cell[u2]`` for OP2.</span>
<span class="sd">        op2 : str</span>
<span class="sd">            Valid operator name of an onsite operator in ``lat.unit_cell[u2]`` for OP2.</span>
<span class="sd">        dx : iterable of int</span>
<span class="sd">            Translation vector (of the unit cell) between OP1 and OP2.</span>
<span class="sd">            For a 1D lattice, a single int is also fine.</span>
<span class="sd">        op_string : str | None</span>
<span class="sd">            Name of an operator to be used between the OP1 and OP2 sites.</span>
<span class="sd">            Typical use case is the phase for a Jordan-Wigner transformation.</span>
<span class="sd">            The operator should be defined on all sites in the unit cell.</span>
<span class="sd">            If ``None``, auto-determine whether a Jordan-Wigner string is needed, using</span>
<span class="sd">            :meth:`~tenpy.networks.site.Site.op_needs_JW`.</span>
<span class="sd">        str_on_first : bool</span>
<span class="sd">            Wheter the provided `op_string` should also act on the first site.</span>
<span class="sd">            This option should be chosen as ``True`` for Jordan-Wigner strings.</span>
<span class="sd">            When handling Jordan-Wigner strings we need to extend the `op_string` to also act on</span>
<span class="sd">            the &#39;left&#39;, first site (in the sense of the MPS ordering of the sites given by the</span>
<span class="sd">            lattice). In this case, there is a well-defined ordering of the operators in the</span>
<span class="sd">            physical sense (i.e. which of `op1` or `op2` acts first on a given state).</span>
<span class="sd">            We follow the convention that `op2` acts first (in the physical sense),</span>
<span class="sd">            independent of the MPS ordering.</span>
<span class="sd">        raise_op2_left : bool</span>
<span class="sd">            Raise an error when `op2` appears left of `op1`</span>
<span class="sd">            (in the sense of the MPS ordering given by the lattice).</span>
<span class="sd">        category : str</span>
<span class="sd">            Descriptive name used as key for :attr:`coupling_terms`.</span>
<span class="sd">            Defaults to a string of the form ``&quot;{op1}_i {op2}_j&quot;``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        When initializing a model, you can add a term :math:` J \sum_{&lt;i,j&gt;} S^z_i S^z_j`</span>
<span class="sd">        on all nearest-neighbor bonds of the lattice like this:</span>

<span class="sd">        &gt;&gt;&gt; J = 1.  # the strength</span>
<span class="sd">        &gt;&gt;&gt; for u1, u2, dx in self.lat.nearest_neighbors:</span>
<span class="sd">        ...     self.add_coupling(J, u1, &#39;Sz&#39;, u2, &#39;Sz&#39;, dx)</span>

<span class="sd">        The strength can be an array, which get&#39;s tiled to the correct shape.</span>
<span class="sd">        For example, in a 1D :class`~tenpy.models.lattice.Chain` with an even number of sites and</span>
<span class="sd">        periodic (or infinite) boundary conditions, you can add alternating strong and weak</span>
<span class="sd">        couplings with a line like::</span>

<span class="sd">        &gt;&gt;&gt; self.add_coupling([1.5, 1.], 0, &#39;Sz&#39;, 0, &#39;Sz&#39;, dx)</span>

<span class="sd">        To add the hermitian conjugate, e.g. for a hopping term, you should add it in the opposite</span>
<span class="sd">        direction ``-dx``, complex conjugate the strength, and take the hermitian conjugate</span>
<span class="sd">        of the operators in swapped order (including a swap of `u1` &lt;-&gt; `u2`).</span>
<span class="sd">        For spin-less fermions (:class:`~tenpy.networks.site.FermionSite`), this would be</span>

<span class="sd">        &gt;&gt;&gt; t = 1.  # hopping strength</span>
<span class="sd">        &gt;&gt;&gt; for u1, u2, dx in self.lat.nearest_neighbors:</span>
<span class="sd">        ...     self.add_coupling(t, u1, &#39;Cd&#39;, u2, &#39;C&#39;, dx)</span>
<span class="sd">        ...     self.add_coupling(np.conj(t), u2, &#39;Cd&#39;, u1, &#39;C&#39;, -dx)  # h.c.</span>

<span class="sd">        With spin-full fermions (:class:`~tenpy.networks.site.SpinHalfFermions`), it could be:</span>

<span class="sd">        &gt;&gt;&gt; for u1, u2, dx in self.lat.nearest_neighbors:</span>
<span class="sd">        ...     self.add_coupling(t, u1, &#39;Cdu&#39;, u2, &#39;Cd&#39;, dx)  # Cdagger_up C_down</span>
<span class="sd">        ...     self.add_coupling(np.conj(t), u2, &#39;Cdd&#39;, u1, &#39;Cu&#39;, -dx)  # h.c. Cdagger_down C_up</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">strength</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">return</span>  <span class="c1"># nothing to do: can even accept non-defined onsite operators</span>
        <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">op1</span><span class="p">,</span> <span class="n">u1</span><span class="p">),</span> <span class="p">(</span><span class="n">op2</span><span class="p">,</span> <span class="n">u2</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;unknown onsite operator </span><span class="si">{0!r}</span><span class="s2"> for u=</span><span class="si">{1:d}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="s2">&quot;</span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">op_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">need_JW1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span><span class="o">.</span><span class="n">op_needs_JW</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>
            <span class="n">need_JW2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span><span class="o">.</span><span class="n">op_needs_JW</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">need_JW1</span> <span class="ow">and</span> <span class="n">need_JW2</span><span class="p">:</span>
                <span class="n">op_string</span> <span class="o">=</span> <span class="s1">&#39;JW&#39;</span>
            <span class="k">elif</span> <span class="n">need_JW1</span> <span class="ow">or</span> <span class="n">need_JW2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of the operators needs a Jordan-Wigner string?!&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">op_string</span> <span class="o">=</span> <span class="s1">&#39;Id&#39;</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">op_string</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown onsite operator </span><span class="si">{0!r}</span><span class="s2"> for u=</span><span class="si">{1:d}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_string</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coupling shouldn&#39;t be onsite!&quot;</span><span class="p">)</span>

        <span class="n">mps_i</span><span class="p">,</span> <span class="n">mps_j</span><span class="p">,</span> <span class="n">lat_indices</span><span class="p">,</span> <span class="n">strength_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">possible_couplings</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">strength_shape</span><span class="p">)</span>  <span class="c1"># tile to correct shape</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{op1}</span><span class="s2">_i </span><span class="si">{op2}</span><span class="s2">_j&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op1</span><span class="o">=</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="o">=</span><span class="n">op2</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">CouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="c1"># loop to perform the sum over {x_0, x_1, ...}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">lat_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mps_i</span><span class="p">,</span> <span class="n">mps_j</span><span class="p">,</span> <span class="n">lat_indices</span><span class="p">):</span>
            <span class="n">current_strength</span> <span class="o">=</span> <span class="n">strength</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">lat_idx</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">current_strength</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span>
            <span class="n">swap</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># ensure i &lt;= j</span>
            <span class="k">if</span> <span class="n">swap</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_op2_left</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Op2 is left&quot;</span><span class="p">)</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">op1</span>  <span class="c1"># swap OP1 &lt;-&gt; OP2</span>
            <span class="c1"># now we have always i &lt; j and 0 &lt;= i &lt; N_sites</span>
            <span class="c1"># j &gt;= N_sites indicates couplings between unit_cells of the infinite MPS.</span>
            <span class="c1"># o1 is the &quot;left&quot; operator; o2 is the &quot;right&quot; operator</span>
            <span class="k">if</span> <span class="n">str_on_first</span> <span class="ow">and</span> <span class="n">op_string</span> <span class="o">!=</span> <span class="s1">&#39;Id&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">swap</span><span class="p">:</span>
                    <span class="n">o1</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">op_string</span><span class="p">,</span> <span class="n">o1</span><span class="p">])</span>  <span class="c1"># o1==op2 should act first</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">o1</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">o1</span><span class="p">,</span> <span class="n">op_string</span><span class="p">])</span>  <span class="c1"># o1==op2 should act first</span>
            <span class="n">ct</span><span class="o">.</span><span class="n">add_coupling_term</span><span class="p">(</span><span class="n">current_strength</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">op_string</span><span class="p">)</span></div>
        <span class="c1"># done</span>

<div class="viewcode-block" id="CouplingModel.add_coupling_term"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.add_coupling_term">[docs]</a>    <span class="k">def</span> <span class="nf">add_coupling_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">op_i</span><span class="p">,</span> <span class="n">op_j</span><span class="p">,</span> <span class="n">op_string</span><span class="o">=</span><span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a two-site coupling term on given MPS sites.</span>

<span class="sd">        Wrapper for ``self.coupling_terms[category].add_coupling_term(...)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : float</span>
<span class="sd">            The strength of the coupling term.</span>
<span class="sd">        i, j : int</span>
<span class="sd">            The MPS indices of the two sites on which the operator acts.</span>
<span class="sd">            We require ``0 &lt;= i &lt; N_sites``  and ``i &lt; j``, i.e., `op_i` acts &quot;left&quot; of `op_j`.</span>
<span class="sd">            If j &gt;= N_sites, it indicates couplings between unit cells of an infinite MPS.</span>
<span class="sd">        op1, op2 : str</span>
<span class="sd">            Names of the involved operators.</span>
<span class="sd">        op_string : str</span>
<span class="sd">            The operator to be inserted between `i` and `j`.</span>
<span class="sd">        category : str</span>
<span class="sd">            Descriptive name used as key for :attr:`coupling_terms`.</span>
<span class="sd">            Defaults to a string of the form ``&quot;{op1}_i {op2}_j&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{op_i}</span><span class="s2">_i </span><span class="si">{op_j}</span><span class="s2">_j&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_i</span><span class="o">=</span><span class="n">op_i</span><span class="p">,</span> <span class="n">op_j</span><span class="o">=</span><span class="n">op_j</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">CouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="n">ct</span><span class="o">.</span><span class="n">add_coupling_term</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">op_i</span><span class="p">,</span> <span class="n">op_j</span><span class="p">,</span> <span class="n">op_string</span><span class="p">)</span></div>

<div class="viewcode-block" id="CouplingModel.all_coupling_terms"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.all_coupling_terms">[docs]</a>    <span class="k">def</span> <span class="nf">all_coupling_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum of all :attr:`coupling_terms`.&quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">MultiCouplingTerms</span><span class="p">)</span> <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">MultiCouplingTerms</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">CouplingTerms</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ct</span> <span class="o">+=</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">ct</span></div>

<div class="viewcode-block" id="CouplingModel.calc_H_onsite"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.calc_H_onsite">[docs]</a>    <span class="k">def</span> <span class="nf">calc_H_onsite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_zero</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate `H_onsite` from `self.onsite_terms`.</span>

<span class="sd">        .. deprecated:: 0.4.0</span>
<span class="sd">            Will be removed in 1.0.0.</span>
<span class="sd">            Replace calls to this function by</span>
<span class="sd">            ``self.all_onsite_terms().remove_zeros(tol_zero).to_Arrays(self.lat.mps_sites())``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol_zero : float</span>
<span class="sd">            prefactors with ``abs(strength) &lt; tol_zero`` are considered to be zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H_onsite : list of npc.Array</span>
<span class="sd">            onsite terms of the Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Deprecated `calc_H_onsite` in CouplingModel&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_onsite_terms</span><span class="p">()</span>
        <span class="n">ot</span><span class="o">.</span><span class="n">remove_zeros</span><span class="p">(</span><span class="n">tol_zero</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ot</span><span class="o">.</span><span class="n">to_Arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">())</span></div>

<div class="viewcode-block" id="CouplingModel.calc_H_bond"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.calc_H_bond">[docs]</a>    <span class="k">def</span> <span class="nf">calc_H_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_zero</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calculate `H_bond` from :attr:`coupling_terms` and :attr:`onsite_terms`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol_zero : float</span>
<span class="sd">            prefactors with ``abs(strength) &lt; tol_zero`` are considered to be zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H_bond : list of :class:`~tenpy.linalg.np_conserved.Array`</span>
<span class="sd">            Bond terms as required by the constructor of :class:`NearestNeighborModel`.</span>
<span class="sd">            Legs are ``[&#39;p0&#39;, &#39;p0*&#39;, &#39;p1&#39;, &#39;p1*&#39;]``</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if the Hamiltonian contains longer-range terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">()</span>
        <span class="n">finite</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">!=</span> <span class="s1">&#39;infinite&#39;</span><span class="p">)</span>

        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_coupling_terms</span><span class="p">()</span>
        <span class="n">ct</span><span class="o">.</span><span class="n">remove_zeros</span><span class="p">(</span><span class="n">tol_zero</span><span class="p">)</span>
        <span class="n">H_bond</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">to_nn_bond_Arrays</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>

        <span class="n">ot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_onsite_terms</span><span class="p">()</span>
        <span class="n">ot</span><span class="o">.</span><span class="n">remove_zeros</span><span class="p">(</span><span class="n">tol_zero</span><span class="p">)</span>
        <span class="n">ot</span><span class="o">.</span><span class="n">add_to_nn_bond_Arrays</span><span class="p">(</span><span class="n">H_bond</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">finite</span><span class="p">,</span> <span class="n">distribute</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">finite</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">H_bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">H_bond</span></div>

<div class="viewcode-block" id="CouplingModel.calc_H_MPO"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.calc_H_MPO">[docs]</a>    <span class="k">def</span> <span class="nf">calc_H_MPO</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_zero</span><span class="o">=</span><span class="mf">1.e-15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate MPO representation of the Hamiltonian.</span>

<span class="sd">        Uses :attr:`onsite_terms` and :attr:`coupling_terms` to build an MPO graph</span>
<span class="sd">        (and then an MPO).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tol_zero : float</span>
<span class="sd">            Prefactors with ``abs(strength) &lt; tol_zero`` are considered to be zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H_MPO : :class:`~tenpy.networks.mpo.MPO`</span>
<span class="sd">            MPO representation of the Hamiltonian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_onsite_terms</span><span class="p">()</span>
        <span class="n">ot</span><span class="o">.</span><span class="n">remove_zeros</span><span class="p">(</span><span class="n">tol_zero</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_coupling_terms</span><span class="p">()</span>
        <span class="n">ct</span><span class="o">.</span><span class="n">remove_zeros</span><span class="p">(</span><span class="n">tol_zero</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">H_MPO_graph</span> <span class="o">=</span> <span class="n">mpo</span><span class="o">.</span><span class="n">MPOGraph</span><span class="o">.</span><span class="n">from_terms</span><span class="p">(</span><span class="n">ot</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span><span class="p">)</span>
        <span class="n">H_MPO</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_MPO_graph</span><span class="o">.</span><span class="n">build_MPO</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">H_MPO</span></div>

<div class="viewcode-block" id="CouplingModel.coupling_strength_add_ext_flux"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingModel.coupling_strength_add_ext_flux">[docs]</a>    <span class="k">def</span> <span class="nf">coupling_strength_add_ext_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an external flux to the coupling strength.</span>

<span class="sd">        When performing DMRG on a &quot;cylinder&quot; geometry, it might be useful to put an &quot;external flux&quot;</span>
<span class="sd">        through the cylinder. This means that a particle hopping around the cylinder should</span>
<span class="sd">        pick up a phase given by the external flux [Resta1997]_.</span>
<span class="sd">        This is also called &quot;twisted boundary conditions&quot; in literature.</span>
<span class="sd">        This function adds a complex phase to the `strength` array on some bonds, such that</span>
<span class="sd">        particles hopping in positive direction around the cylinder pick up `exp(+i phase)`.</span>

<span class="sd">        .. warning ::</span>
<span class="sd">            For the sign of `phase` it is important that you consistently use the creation</span>
<span class="sd">            operator as `op1` and the annihilation operator as `op2` in :meth:`add_coupling&quot;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : scalar | array</span>
<span class="sd">            The strength to be used in :meth:`add_coupling`, when no external flux would be</span>
<span class="sd">            present.</span>
<span class="sd">        dx : iterable of int</span>
<span class="sd">            Translation vector (of the unit cell) between `op1` and `op2` in :meth:`add_coupling`.</span>
<span class="sd">        phase : iterable of float</span>
<span class="sd">            The phase of the external flux for hopping in each direction of the lattice.</span>
<span class="sd">            E.g., if you want flux through the cylinder on which you have an infinite MPS,</span>
<span class="sd">            you should give ``phase=[0, phi]`` souch that particles pick up a phase `phi` when</span>
<span class="sd">            hopping around the cylinder.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strength : complex array</span>
<span class="sd">            The strength array to be used as `strength` in :meth:`add_coupling`</span>
<span class="sd">            with the given `dx`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Let&#39;s say you have an infinite MPS on a cylinder, and want to add nearest-neighbor</span>
<span class="sd">        hopping of fermions with the :class:`~tenpy.networks.site.FermionSite`.</span>
<span class="sd">        The cylinder axis is the `x`-direction of the lattice, so to put a flux through the</span>
<span class="sd">        cylinder, you want particles hopping *around* the cylinder to pick up a phase `phi`</span>
<span class="sd">        given by the external flux.</span>

<span class="sd">        &gt;&gt;&gt; strength = 1. # hopping strength without external flux</span>
<span class="sd">        &gt;&gt;&gt; phi = np.pi/4 # determines the external flux strength</span>
<span class="sd">        &gt;&gt;&gt; strength_with_flux = self.coupling_strength_add_ext_flux(strength, dx, [0, phi])</span>
<span class="sd">        &gt;&gt;&gt; for u1, u2, dx in self.lat.nearest_neighbors:</span>
<span class="sd">        ...     self.add_coupling(strength_with_flux, u1, &#39;Cd&#39;, u2, &#39;C&#39;, dx)</span>
<span class="sd">        ...     self.add_coupling(np.conj(strength_with_flux), u2, &#39;Cd&#39;, u1, &#39;C&#39;, -dx)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">c_shape</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">_coupling_shape</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">c_shape</span><span class="p">)</span>
        <span class="c1"># make strenght complex</span>
        <span class="n">complex_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">strength</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)])</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">complex_dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span>  <span class="c1"># open boundary conditions</span>
                <span class="k">if</span> <span class="n">phase</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nonzero phase for external flux along non-periodic b.c.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c1"># nothing to do</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">ax</span><span class="p">]),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># the last ``abs(dx[ax])`` entries in the axis `ax` correspond to hopping</span>
            <span class="c1"># accross the periodic b.c.</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dx</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">strength</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span>  <span class="c1"># hopping in *negative* y-direction</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">strength</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span>  <span class="c1"># hopping in *positive* y-direction</span>
        <span class="k">return</span> <span class="n">strength</span></div></div>


<div class="viewcode-block" id="MultiCouplingModel"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MultiCouplingModel">[docs]</a><span class="k">class</span> <span class="nc">MultiCouplingModel</span><span class="p">(</span><span class="n">CouplingModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generalizes :class:`CouplingModel` to allow couplings involving more than two sites.</span>

<span class="sd">    The corresponding couplings can be added with :meth:`add_multi_coupling` and</span>
<span class="sd">    :meth:`add_multi_coupling_term` and are saved in :attr:`coupling_terms`, which can now contain</span>
<span class="sd">    instances of :class:`~tenpy.networks.mps.MultiCouplingTerms`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MultiCouplingModel.add_multi_coupling"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MultiCouplingModel.add_multi_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">add_multi_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">op0</span><span class="p">,</span> <span class="n">other_ops</span><span class="p">,</span> <span class="n">op_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</span>

<span class="sd">        Represents couplings of the form</span>
<span class="sd">        :math:`sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP0 * OP1 * ... * OPM`,</span>
<span class="sd">        where ``OP_0 := lat.unit_cell[u0].get_op(op0)`` acts on the site</span>
<span class="sd">        ``(x_0, ..., x_{dim-1}, u0)``,</span>
<span class="sd">        and ``OP_m := lat.unit_cell[other_u[m]].get_op(other_op[m])``, m=1...M, acts on the site</span>
<span class="sd">        ``(x_0+other_dx[m][0], ..., x_{dim-1}+other_dx[m][dim-1], other_u[m])``.</span>
<span class="sd">        For periodic boundary conditions along direction `a` (``lat.bc[a] == False``)</span>
<span class="sd">        the index ``x_a`` is taken modulo ``lat.Ls[a]`` and runs through ``range(lat.Ls[a])``.</span>
<span class="sd">        For open boundary conditions, ``x_a`` is limited to ``0 &lt;= x_a &lt; Ls[a]`` and</span>
<span class="sd">        ``0 &lt;= x_a+other_dx[m,a] &lt; lat.Ls[a]``.</span>
<span class="sd">        The coupling `strength` may vary spatially, :math:`loc(\vec{x})` indicates the lower left</span>
<span class="sd">        corner of the hypercube containing all the involved sites</span>
<span class="sd">        :math:`\vec{x}, \vec{x}+\vec{other_dx[m, :]}`.</span>

<span class="sd">        The necessary terms are just added to :attr:`coupling_terms`; doesn&#39;t rebuild the MPO.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : scalar | array</span>
<span class="sd">            Prefactor of the coupling. May vary spatially and is tiled to the required shape.</span>
<span class="sd">        u0 : int</span>
<span class="sd">            Picks the site ``lat.unit_cell[u0]`` for OP0.</span>
<span class="sd">        op0 : str</span>
<span class="sd">            Valid operator name of an onsite operator in ``lat.unit_cell[u0]`` for OP0.</span>
<span class="sd">        other_ops : list of ``(u, op_m, dx)``</span>
<span class="sd">            One tuple for each of the other operators ``OP1, OP2, ... OPM`` involved.</span>
<span class="sd">            `u` picks the site ``lat.unit_cell[u]``, `op_name` is a valid operator acting on that</span>
<span class="sd">            site, and `dx` gives the translation vector between ``OP0`` and the specified operator.</span>
<span class="sd">        op_string : str | None</span>
<span class="sd">            Name of an operator to be used inbetween the operators, excluding the sites on which</span>
<span class="sd">            the operators act. This operator should be defined on all sites in the unit cell.</span>

<span class="sd">            Special case: If ``None``, auto-determine whether a Jordan-Wigner string is needed</span>
<span class="sd">            (using :meth:`~tenpy.networks.site.Site.op_needs_JW`), for each of the segments</span>
<span class="sd">            inbetween the operators and also on the sites of the left operators.</span>
<span class="sd">            Note that in this case the ordering of the operators *is* important and handled in the</span>
<span class="sd">            usual convention that ``OPM`` acts first and ``OP0`` last on a physical state.</span>

<span class="sd">            .. warning :</span>
<span class="sd">                ``None`` figures out for each segment between the operators, whether a</span>
<span class="sd">                Jordan-Wigner string is needed.</span>
<span class="sd">                This is different from a plain ``&#39;JW&#39;``, which just applies a string on</span>
<span class="sd">                each segment!</span>

<span class="sd">        category : str</span>
<span class="sd">            Descriptive name used as key for :attr:`coupling_terms`.</span>
<span class="sd">            Defaults to a string of the form ``&quot;{op0}_i {other_ops[0]}_j {other_ops[1]}_k ...&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_ops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_ops</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_ops</span><span class="p">)</span>
        <span class="n">all_us</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">oop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">oop</span> <span class="ow">in</span> <span class="n">other_ops</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">all_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">oop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">oop</span> <span class="ow">in</span> <span class="n">other_ops</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">oop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">oop</span> <span class="ow">in</span> <span class="n">other_ops</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">dim</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">strength</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">return</span>  <span class="c1"># nothing to do: can even accept non-defined onsite operators</span>
        <span class="n">need_JW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">op_needs_JW</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_us</span><span class="p">,</span> <span class="n">all_ops</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op_string</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">need_JW</span><span class="p">):</span>
            <span class="n">op_string</span> <span class="o">=</span> <span class="s1">&#39;Id&#39;</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">u0</span><span class="p">,</span> <span class="n">op0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="n">other_ops</span> <span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown onsite operator </span><span class="si">{0!r}</span><span class="s2"> for u=</span><span class="si">{1:d}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">op_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">need_JW</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid coupling: would need &#39;JW&#39; string on the very left&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">valid_opname</span><span class="p">(</span><span class="n">op_string</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown onsite operator </span><span class="si">{0!r}</span><span class="s2"> for u=</span><span class="si">{1:d}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                     <span class="s2">&quot;</span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_string</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">u0</span> <span class="o">==</span> <span class="n">all_us</span><span class="p">):</span>
            <span class="c1"># note: we DO allow couplings with some onsite terms, but not all of them</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coupling shouldn&#39;t be purely onsite!&quot;</span><span class="p">)</span>

        <span class="c1"># prepare: figure out the necessary mps indices</span>
        <span class="n">mps_ijkl</span><span class="p">,</span> <span class="n">lat_indices</span><span class="p">,</span> <span class="n">strength_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">possible_multi_couplings</span><span class="p">(</span>
            <span class="n">u0</span><span class="p">,</span> <span class="n">all_us</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dx</span><span class="p">)</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">to_array</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">strength_shape</span><span class="p">)</span>  <span class="c1"># tile to correct shape</span>

        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{op}</span><span class="s2">_</span><span class="si">{i}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span>
                                 <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_ops</span><span class="p">)])</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">MultiCouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">MultiCouplingTerms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ct</span> <span class="o">=</span> <span class="n">MultiCouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
            <span class="n">new_ct</span> <span class="o">+=</span> <span class="n">ct</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">new_ct</span>
        <span class="n">N_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span>
        <span class="c1"># loop to perform the sum over {x_0, x_1, ...}</span>
        <span class="k">for</span> <span class="n">ijkl</span><span class="p">,</span> <span class="n">i_lat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mps_ijkl</span><span class="p">,</span> <span class="n">lat_indices</span><span class="p">):</span>
            <span class="n">current_strength</span> <span class="o">=</span> <span class="n">strength</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i_lat</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">current_strength</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ijkl</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">op_str</span> <span class="o">=</span> <span class="n">_multi_coupling_group_handle_JW</span><span class="p">(</span>
                <span class="n">ijkl</span><span class="p">,</span> <span class="n">all_ops</span><span class="p">,</span> <span class="n">need_JW</span><span class="p">,</span> <span class="n">op_string</span><span class="p">,</span> <span class="n">N_sites</span><span class="p">)</span>
            <span class="n">ct</span><span class="o">.</span><span class="n">add_multi_coupling_term</span><span class="p">(</span><span class="n">current_strength</span><span class="p">,</span> <span class="n">ijkl</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">op_str</span><span class="p">)</span></div>
        <span class="c1"># done</span>

<div class="viewcode-block" id="MultiCouplingModel.add_multi_coupling_term"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.MultiCouplingModel.add_multi_coupling_term">[docs]</a>    <span class="k">def</span> <span class="nf">add_multi_coupling_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">ijkl</span><span class="p">,</span> <span class="n">ops_ijkl</span><span class="p">,</span> <span class="n">op_string</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a general M-site coupling term on given MPS sites.</span>

<span class="sd">        Wrapper for ``self.coupling_terms[category].add_multi_coupling_term(...)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strength : float</span>
<span class="sd">            The strength of the coupling term.</span>
<span class="sd">        ijkl : list of int</span>
<span class="sd">            The MPS indices of the sites on which the operators acts. With `i, j, k, ... = ijkl`,</span>
<span class="sd">            we require that they are ordered ascending, ``i &lt; j &lt; k &lt; ...`` and</span>
<span class="sd">            that ``0 &lt;= i &lt; N_sites``.</span>
<span class="sd">            Inidces &gt;= N_sites indicate couplings between different unit cells of an infinite MPS.</span>
<span class="sd">        ops_ijkl : list of str</span>
<span class="sd">            Names of the involved operators on sites `i, j, k, ...`.</span>
<span class="sd">        op_string : list of str</span>
<span class="sd">            Names of the operator to be inserted between the operators,</span>
<span class="sd">            e.g., op_string[0] is inserted between `i` and `j`.</span>
<span class="sd">        category : str</span>
<span class="sd">            Descriptive name used as key for :attr:`coupling_terms`.</span>
<span class="sd">            Defaults to a string of the form ``&quot;{op0}_i {other_ops[0]}_j {other_ops[1]}_k ...&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{op}</span><span class="s2">_</span><span class="si">{i}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span>
                                 <span class="nb">enumerate</span><span class="p">(</span><span class="n">ops_ijkl</span><span class="p">)])</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">MultiCouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">MultiCouplingTerms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coupling_terms</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ct</span> <span class="o">=</span> <span class="n">MultiCouplingTerms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
            <span class="n">new_ct</span> <span class="o">+=</span> <span class="n">ct</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">new_ct</span>
        <span class="n">ct</span><span class="o">.</span><span class="n">add_multi_coupling_term</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">ijkl</span><span class="p">,</span> <span class="n">ops_ijkl</span><span class="p">,</span> <span class="n">op_string</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CouplingMPOModel"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingMPOModel">[docs]</a><span class="k">class</span> <span class="nc">CouplingMPOModel</span><span class="p">(</span><span class="n">CouplingModel</span><span class="p">,</span><span class="n">MPOModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combination of the :class:`CouplingModel` and :class:`MPOModel`.</span>

<span class="sd">    This class provides the interface for most of the model classes in `tenpy`.</span>
<span class="sd">    Examples based on this class are given in :mod:`~tenpy.models.xxz_chain`</span>
<span class="sd">    and :mod:`~tenpy.models.tf_ising`.</span>

<span class="sd">    The ``__init__`` of this function performs the standard initialization explained</span>
<span class="sd">    in :doc:`/intro_model`, by calling the methods :meth:`init_lattice` (step 1-4)</span>
<span class="sd">    to initialize a lattice (which in turn calls :meth:`init_sites`) and</span>
<span class="sd">    :meth:`init_terms`. The latter should be overwritten by subclasses to add the</span>
<span class="sd">    desired terms.</span>

<span class="sd">    As shown in :mod:`~tenpy.models.tf_ising`, you can get a 1D version suitable</span>
<span class="sd">    for TEBD from a general-lattice model by subclassing it once more, only</span>
<span class="sd">    redefining the ``__init__`` as follows::</span>

<span class="sd">        def __init__(self, model_params):</span>
<span class="sd">            CouplingMPOModel.__init__(self, model_params)</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model_params : dict</span>
<span class="sd">        A dictionary with all the model parameters.</span>
<span class="sd">        These parameters are given to the different ``init_...()`` methods, and</span>
<span class="sd">        should be read out using :func:`~tenpy.tools.params.get_parameter`.</span>
<span class="sd">        This may happen in any of the ``init_...()`` methods.</span>
<span class="sd">        The parameter ``&#39;verbose&#39;`` is read out in the `__init__` of this function</span>
<span class="sd">        and specifies how much status information should be printed during initialization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the model, e.g. ``&quot;XXZChain&quot; or ``&quot;SpinModel&quot;``.</span>
<span class="sd">    verbose : int</span>
<span class="sd">        Level of verbosity (i.e. how much status information to print); higher=more output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_called_CouplingMPOModel_init&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># If we ignore this, the same terms get added to self multiple times.</span>
            <span class="c1"># In the best case, this would just rescale the energy;</span>
            <span class="c1"># in the worst case we get the wrong Hamiltonian.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Called CouplingMPOModel.__init__(...) multiple times.&quot;</span><span class="p">)</span>
            <span class="c1"># To fix this problem, follow the instructions for subclassing in :doc:`/intro_model`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_called_CouplingMPOModel_init</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># 1-4) iniitalize lattice</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_lattice</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="c1"># 5) initialize CouplingModel</span>
        <span class="n">CouplingModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># 6) add terms of the Hamiltonian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_terms</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="c1"># 7) initialize H_MPO</span>
        <span class="n">MPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_H_MPO</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">NearestNeighborModel</span><span class="p">):</span>
            <span class="c1"># 8) initialize H_bonds</span>
            <span class="n">NearestNeighborModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_H_bond</span><span class="p">())</span>
        <span class="c1"># checks for misspelled parameters</span>
        <span class="n">unused_parameters</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="CouplingMPOModel.init_lattice"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingMPOModel.init_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">init_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a lattice for the given model parameters.</span>

<span class="sd">        This function reads out the model parameter `lattice`.</span>
<span class="sd">        This can be a full :class:`~tenpy.models.lattice.Lattice` instance,</span>
<span class="sd">        in which case it is just returned without further action.</span>
<span class="sd">        Alternatively, the `lattice` parameter can be a string giving the name</span>
<span class="sd">        of one of the predefined lattices, which then gets initialized.</span>
<span class="sd">        Depending on the dimensionality of the lattice, this requires different model parameters.</span>

<span class="sd">        The following model parameters get read out.</span>

<span class="sd">        ============== ========= ===============================================================</span>
<span class="sd">        key            type      description</span>
<span class="sd">        ============== ========= ===============================================================</span>
<span class="sd">        lattice        str |     The name of a lattice pre-defined in TeNPy to be initialized.</span>
<span class="sd">                       Lattice   Alternatively, a (possibly self-defined) Lattice instance.</span>
<span class="sd">                                 In the latter case, no further parameters are read out.</span>
<span class="sd">        -------------- --------- ---------------------------------------------------------------</span>
<span class="sd">        bc_MPS         str       Boundary conditions for the MPS</span>
<span class="sd">        -------------- --------- ---------------------------------------------------------------</span>
<span class="sd">        order          str       The order of sites within the lattice for non-trivial lattices.</span>
<span class="sd">        -------------- --------- ---------------------------------------------------------------</span>
<span class="sd">        L              int       The length in x-direction (or lenght of the unit cell for</span>
<span class="sd">                                 infinite systems).</span>
<span class="sd">                                 Only read out for 1D lattices.</span>
<span class="sd">        -------------- --------- ---------------------------------------------------------------</span>
<span class="sd">        Lx, Ly         int       The length in x- and y-direction.</span>
<span class="sd">                                 For ``&quot;infinite&quot;`` `bc_MPS`, the system is infinite in</span>
<span class="sd">                                 x-direction and `Lx` is the number of &quot;rings&quot; in the infinite</span>
<span class="sd">                                 MPS unit cell, while `Ly` gives the circumference around the</span>
<span class="sd">                                 cylinder or width of th the rung for a ladder (depending on</span>
<span class="sd">                                 `bc_y`.</span>
<span class="sd">                                 Only read out for 2D lattices.</span>
<span class="sd">        -------------- --------- ---------------------------------------------------------------</span>
<span class="sd">        bc_y           str       ``&quot;cylinder&quot; | &quot;ladder&quot;``.</span>
<span class="sd">                                 The boundary conditions in y-direction.</span>
<span class="sd">                                 Only read out for 2D lattices.</span>
<span class="sd">        -------------- --------- ---------------------------------------------------------------</span>
<span class="sd">        bc_x           str       ``&quot;open&quot; | &quot;periodic&quot;``.</span>
<span class="sd">                                 Can be used to force &quot;periodic&quot; boundaries for the lattice,</span>
<span class="sd">                                 i.e., for the couplings in the Hamiltonian,</span>
<span class="sd">                                 even if the MPS is finite.</span>
<span class="sd">                                 Defaults to ``&quot;open&quot;`` for ``bc_MPS=&quot;finite&quot;`` and</span>
<span class="sd">                                 ``&quot;periodic&quot;`` for ``bc_MPS=&quot;infinite``.</span>
<span class="sd">                                 If you are not aware of the consequences, you should probably</span>
<span class="sd">                                 *not* use &quot;periodic&quot; boundary conditions.</span>
<span class="sd">                                 (The MPS is still &quot;open&quot;, so this will introduce long-range</span>
<span class="sd">                                 couplings between the first and last sites of the MPS!)</span>
<span class="sd">        ============== ========= ===============================================================</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_params : dict</span>
<span class="sd">            The model parameters given to ``__init__``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lat : :class:`~tenpy.models.lattice.Lattice`</span>
<span class="sd">            An initialized lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;lattice&#39;</span><span class="p">,</span> <span class="s2">&quot;Chain&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">LatticeClass</span> <span class="o">=</span> <span class="n">get_lattice</span><span class="p">(</span><span class="n">lattice_name</span><span class="o">=</span><span class="n">lat</span><span class="p">)</span>
            <span class="n">bc_MPS</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;bc_MPS&#39;</span><span class="p">,</span> <span class="s1">&#39;finite&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_sites</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
            <span class="n">bc_x</span> <span class="o">=</span> <span class="s1">&#39;periodic&#39;</span> <span class="k">if</span> <span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span> <span class="k">else</span> <span class="s1">&#39;open&#39;</span>
            <span class="n">bc_x</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;bc_x&#39;</span><span class="p">,</span> <span class="n">bc_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span> <span class="ow">and</span> <span class="n">bc_x</span> <span class="o">==</span> <span class="s1">&#39;open&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to use &#39;periodic&#39; `bc_x` for infinite systems!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">LatticeClass</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 1D lattice</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="c1"># 4) lattice</span>
                <span class="n">lat</span> <span class="o">=</span> <span class="n">LatticeClass</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">bc_x</span><span class="p">,</span> <span class="n">bc_MPS</span><span class="o">=</span><span class="n">bc_MPS</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">LatticeClass</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>   <span class="c1"># 2D lattice</span>
                <span class="n">Lx</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;Lx&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">Ly</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;Ly&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">bc_y</span> <span class="o">=</span> <span class="n">get_parameter</span><span class="p">(</span><span class="n">model_params</span><span class="p">,</span> <span class="s1">&#39;bc_y&#39;</span><span class="p">,</span> <span class="s1">&#39;cylinder&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">bc_y</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cylinder&#39;</span><span class="p">,</span> <span class="s1">&#39;ladder&#39;</span><span class="p">]</span>
                <span class="n">bc_y</span> <span class="o">=</span> <span class="s1">&#39;periodic&#39;</span> <span class="k">if</span> <span class="n">bc_y</span> <span class="o">==</span> <span class="s1">&#39;cylinder&#39;</span> <span class="k">else</span> <span class="s1">&#39;open&#39;</span>
                <span class="n">lat</span> <span class="o">=</span> <span class="n">LatticeClass</span><span class="p">(</span><span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="p">[</span><span class="n">bc_x</span><span class="p">,</span> <span class="n">bc_y</span><span class="p">],</span> <span class="n">bc_MPS</span><span class="o">=</span><span class="n">bc_MPS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t auto-determine parameters for the lattice. &quot;</span>
                                 <span class="s2">&quot;Overwrite the `init_lattice` in your model!&quot;</span><span class="p">)</span>
            <span class="c1"># now, `lat` is an instance of the LatticeClass called `lattice_name`.</span>
        <span class="c1"># else: a lattice was already provided</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lat</span></div>

<div class="viewcode-block" id="CouplingMPOModel.init_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingMPOModel.init_sites">[docs]</a>    <span class="k">def</span> <span class="nf">init_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the local Hilbert space and operators; needs to be implemented in subclasses.</span>

<span class="sd">        This function gets called by :meth:`init_lattice` to get the</span>
<span class="sd">        :class:`~tenpy.networks.site.Site` for the lattice unit cell.</span>

<span class="sd">        .. note ::</span>
<span class="sd">            Initializing the sites requires to define the conserved quantum numbers.</span>
<span class="sd">            All pre-defined sites accept ``conserve=None`` to disable using quantum numbers.</span>
<span class="sd">            Many models in TeNPy read out the `conserve` model parameter, which can be set</span>
<span class="sd">            to ``&quot;best&quot;`` to indicate the optimal parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_params : dict</span>
<span class="sd">            The model parameters given to ``__init__``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sites : (tuple of) :class:`~tenpy.networks.site.Site`</span>
<span class="sd">            The local sites of the lattice, defining the local basis states and operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses should implement `init_sites`&quot;</span><span class="p">)</span></div>
        <span class="c1"># or at least redefine the lattice</span>

<div class="viewcode-block" id="CouplingMPOModel.init_terms"><a class="viewcode-back" href="../../../reference/tenpy.models.model.html#tenpy.models.bose_hubbard.CouplingMPOModel.init_terms">[docs]</a>    <span class="k">def</span> <span class="nf">init_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the onsite and coupling terms to the model; subclasses should implement this.&quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># Do nothing. This allows to super().init_terms(model_params) in subclasses.</span></div></div>


<span class="k">def</span> <span class="nf">_multi_coupling_group_handle_JW</span><span class="p">(</span><span class="n">ijkl</span><span class="p">,</span> <span class="n">ops</span><span class="p">,</span> <span class="n">ops_need_JW</span><span class="p">,</span> <span class="n">op_string</span><span class="p">,</span> <span class="n">N_sites</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helping function for MultiCouplingModel.add_multi_coupling.</span>

<span class="sd">    Sort and groups the operators by sites `ijkl` they act on, such that the returned `new_ijkl`</span>
<span class="sd">    is strictly ascending, i.e. has entries `i &lt; j &lt; k &lt; l`.</span>
<span class="sd">    Also, handle/figure out Jordan-Wigner strings if needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">number_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ijkl</span><span class="p">)</span>
    <span class="n">reorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ijkl</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>  <span class="c1"># need stable kind!!!</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ijkl</span><span class="p">[</span><span class="n">reorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">N_sites</span><span class="p">:</span>  <span class="c1"># ensure this condition with a shift</span>
        <span class="n">ijkl</span> <span class="o">+=</span> <span class="n">ijkl</span><span class="p">[</span><span class="n">reorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">%</span> <span class="n">N_sites</span> <span class="o">-</span> <span class="n">ijkl</span><span class="p">[</span><span class="n">reorder</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="c1"># what we want to calculate:</span>
    <span class="n">new_ijkl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_op_str</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># new_op_string[x] is right of new_ops[x]</span>
    <span class="c1"># first make groups with strictly ``i &lt; j &lt; k &lt; ... ``</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># != the first i since -1 &lt;  0 &lt;= ijkl[:]</span>
    <span class="n">grouped_reorder</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reorder</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ijkl</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">i0</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">new_ijkl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">grouped_reorder</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grouped_reorder</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">op_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># simpler case</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouped_reorder</span><span class="p">:</span>
            <span class="n">new_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">ops</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]))</span>
            <span class="n">new_op_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_string</span><span class="p">)</span>
        <span class="n">new_op_str</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># remove last entry (created one too much)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># more complicated: handle Jordan-Wigner</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grouped_reorder</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span> <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">grouped_reorder</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">]</span>
            <span class="n">onsite_ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">need_JW_right</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">JW_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group</span> <span class="o">+</span> <span class="p">[</span><span class="n">number_ops</span><span class="p">]:</span>
                <span class="n">JW_min</span><span class="p">,</span> <span class="n">JW_max</span> <span class="o">=</span> <span class="n">JW_max</span><span class="p">,</span> <span class="n">x</span>
                <span class="n">need_JW</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">ops_need_JW</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">right</span> <span class="k">if</span> <span class="n">JW_min</span> <span class="o">&lt;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">JW_max</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">need_JW</span><span class="p">:</span>
                    <span class="n">onsite_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;JW&#39;</span><span class="p">)</span>
                    <span class="n">need_JW_right</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">need_JW_right</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">number_ops</span><span class="p">:</span>
                    <span class="n">onsite_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">new_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">onsite_ops</span><span class="p">))</span>
            <span class="n">op_str_right</span> <span class="o">=</span> <span class="s1">&#39;JW&#39;</span> <span class="k">if</span> <span class="n">need_JW_right</span> <span class="k">else</span> <span class="s1">&#39;Id&#39;</span>
            <span class="n">new_op_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_str_right</span><span class="p">)</span>
        <span class="n">new_op_str</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># remove last entry (created one too much)</span>
    <span class="k">return</span> <span class="n">new_ijkl</span><span class="p">,</span> <span class="n">new_ops</span><span class="p">,</span> <span class="n">new_op_str</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/tenpy.html">Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 27, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>