
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>tenpy.models.lattice &#8212; TeNPy 0.4.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../../../_static/logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for tenpy.models.lattice</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Classes to define the lattice structure of a model.</span>

<span class="sd">The base class :class:`Lattice` defines the general structure of a lattice,</span>
<span class="sd">you can subclass this to define you own lattice.</span>
<span class="sd">The :class:`SimpleLattice` is a slight simplification for lattices with a single-site unit cell.</span>
<span class="sd">Further, we have some predefined lattices, namely</span>
<span class="sd">:class:`Chain`, :class:`Ladder` in 1D and</span>
<span class="sd">:class:`Square`, :class:`Triangular`, :class:`Honeycomb`, and :class:`Kagome` in 2D.</span>

<span class="sd">See also the :doc:`/intro_model`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Copyright 2018 TeNPy Developers</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">..networks.site</span> <span class="k">import</span> <span class="n">Site</span>
<span class="kn">from</span> <span class="nn">..tools.misc</span> <span class="k">import</span> <span class="n">to_iterable</span><span class="p">,</span> <span class="n">inverse_permutation</span>
<span class="kn">from</span> <span class="nn">..networks.mps</span> <span class="k">import</span> <span class="n">MPS</span>  <span class="c1"># only to check boundary conditions</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Lattice&#39;</span><span class="p">,</span> <span class="s1">&#39;SimpleLattice&#39;</span><span class="p">,</span> <span class="s1">&#39;Chain&#39;</span><span class="p">,</span> <span class="s1">&#39;Ladder&#39;</span><span class="p">,</span> <span class="s1">&#39;Square&#39;</span><span class="p">,</span> <span class="s1">&#39;Triangular&#39;</span><span class="p">,</span> <span class="s1">&#39;Honeycomb&#39;</span><span class="p">,</span> <span class="s1">&#39;Kagome&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_lattice&#39;</span><span class="p">,</span> <span class="s1">&#39;get_order&#39;</span><span class="p">,</span> <span class="s1">&#39;get_order_grouped&#39;</span><span class="p">,</span> <span class="s1">&#39;bc_choices&#39;</span>
<span class="p">]</span>

<span class="c1"># (update module doc string if you add further lattices)</span>

<span class="n">bc_choices</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;open&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
<span class="sd">&quot;&quot;&quot;dict: maps possible choices of boundary conditions in a lattice to bool/int.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Lattice"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice">[docs]</a><span class="k">class</span> <span class="nc">Lattice</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A general, regular lattice.</span>

<span class="sd">    The lattice consists of a **unit cell** which is repeated in `dim` different directions.</span>
<span class="sd">    A site of the lattice is thus identified by **lattice indices** ``(x_0, ..., x_{dim-1}, u)``,</span>
<span class="sd">    where ``0 &lt;= x_l &lt; Ls[l]`` pick the position of the unit cell in the lattice and</span>
<span class="sd">    ``0 &lt;= u &lt; len(unit_cell)`` picks the site within the unit cell. The site is located</span>
<span class="sd">    in &#39;space&#39; at ``sum_l x_l*basis[l] + unit_cell_positions[u]`` (see :meth:`position`).</span>
<span class="sd">    (Note that the position in space is only used for plotting, not for defining the couplings.)</span>

<span class="sd">    In addition to the pure geometry, this class also defines an `order` of all sites.</span>
<span class="sd">    This order maps the lattice to a finite 1D chain and defines the geometry of MPSs and MPOs.</span>
<span class="sd">    The **MPS index** `i` corresponds thus to the lattice sites given by</span>
<span class="sd">    ``(x_0, ..., x_{dim-1}, u) = tuple(self.order[i])``.</span>
<span class="sd">    Infinite boundary conditions of the MPS repeat in the first spatial direction of the lattice,</span>
<span class="sd">    i.e., if the site at (x_0, x_1, ..., x_{dim-1},u)`` has MPS index `i`, the site at</span>
<span class="sd">    at ``(x_0 + a*Ls[0], x_1 ..., x_{dim-1}, u)`` corresponds to MPS index ``i + N_sites``.</span>
<span class="sd">    Use :meth:`mps2lat_idx` and :meth:`lat2mps_idx` for conversion of indices.</span>
<span class="sd">    The function :meth:`mps2lat_values` performs the necessary reshaping and re-ordering from</span>
<span class="sd">    arrays indexed in MPS form to arrays indexed in lattice form.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ls : list of int</span>
<span class="sd">        the length in each direction</span>
<span class="sd">    unit_cell : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The sites making up a unit cell of the lattice.</span>
<span class="sd">        If you want to specify it only after initialization, use ``None`` entries in the list.</span>
<span class="sd">    order : str | ``(&#39;standard&#39;, snake_winding, priority)`` | ``(&#39;grouped&#39;, groups)``</span>
<span class="sd">        A string or tuple specifying the order, given to :meth:`ordering`.</span>
<span class="sd">    bc : (iterable of) {&#39;open&#39; | &#39;periodic&#39; | int}</span>
<span class="sd">        Boundary conditions in each direction of the lattice.</span>
<span class="sd">        A single string holds for all directions.</span>
<span class="sd">        An integer `shift` means that we have periodic boundary conditions along this direction,</span>
<span class="sd">        but shift/tilt by ``-shift*lattice.basis[0]`` (~cylinder axis for ``bc_MPS=&#39;infinite&#39;``)</span>
<span class="sd">        when going around the boundary along this direction.</span>
<span class="sd">    bc_MPS : &#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;</span>
<span class="sd">        Boundary conditions for an MPS/MPO living on the ordered lattice.</span>
<span class="sd">        If the system is ``&#39;infinite&#39;``, the infinite direction is always along the first basis</span>
<span class="sd">        vector (justifying the definition of `N_rings` and `N_sites_per_ring`).</span>
<span class="sd">    basis : iterable of 1D arrays</span>
<span class="sd">        For each direction one translation vectors shifting the unit cell.</span>
<span class="sd">        Defaults to the standard ONB ``np.eye(dim)``.</span>
<span class="sd">    positions : iterable of 1D arrays</span>
<span class="sd">        For each site of the unit cell the position within the unit cell.</span>
<span class="sd">        Defaults to ``np.zeros((len(unit_cell), dim))``.</span>
<span class="sd">    nearest_neighbors : ``None`` | list of ``(u1, u2, dx)``</span>
<span class="sd">        May be unspecified (``None``), otherwise it gives a list of parameters `u1`, `u2`, `dx`</span>
<span class="sd">        as needed for the :meth:`~tenpy.models.model.CouplingModel` to generate nearest-neighbor</span>
<span class="sd">        couplings.</span>
<span class="sd">        Note that we include each coupling only in one direction; to get both directions, use</span>
<span class="sd">        ``nearest_neighbors + [(u2, u1, -dx) for (u1, u2, dx) in nearest_neighbors]``.</span>
<span class="sd">    next_nearest_neighbors : ``None`` | list of ``(u1, u2, dx)``</span>
<span class="sd">        Same as `nearest_neighbors`, but for the next-nearest neigbhors.</span>
<span class="sd">    next_next_nearest_neighbors : ``None`` | list of ``(u1, u2, dx)``</span>
<span class="sd">        Same as `nearest_neighbors`, but for the next-next-nearest neigbhors.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dim : int</span>
<span class="sd">    order : ndarray (N_sites, dim+1)</span>
<span class="sd">    N_cells : int</span>
<span class="sd">        the number of unit cells in the lattice, ``np.prod(self.Ls)``.</span>
<span class="sd">    N_sites : int</span>
<span class="sd">        the number of sites in the lattice, ``np.prod(self.shape)``.</span>
<span class="sd">    N_sites_per_ring : int</span>
<span class="sd">        Defined as ``N_sites / Ls[0]``, for an infinite system the number of cites per &quot;ring&quot;.</span>
<span class="sd">    N_rings : int</span>
<span class="sd">        Alias for ``Ls[0]``, for an infinite system the number of &quot;rings&quot; in the unit cell.</span>
<span class="sd">    Ls : tuple of int</span>
<span class="sd">        the length in each direction.</span>
<span class="sd">    shape : tuple of int</span>
<span class="sd">        the &#39;shape&#39; of the lattice, same as ``Ls + (len(unit_cell), )``</span>
<span class="sd">    unit_cell : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        the lattice sites making up a unit cell of the lattice.</span>
<span class="sd">    bc : bool ndarray</span>
<span class="sd">        Boundary conditions of the couplings in each direction of the lattice,</span>
<span class="sd">        translated into a bool array with the global `bc_choices`.</span>
<span class="sd">    bc_shift : None | ndarray(int)</span>
<span class="sd">        The shift in x-direction when going around periodic boundaries in other directions.</span>
<span class="sd">    bc_MPS : &#39;finite&#39; | &#39;segment&#39; | &#39;infinite&#39;</span>
<span class="sd">        Boundary conditions for an MPS/MPO living on the ordered lattice.</span>
<span class="sd">        If the system is ``&#39;infinite&#39;``, the infinite direction is always along the first basis</span>
<span class="sd">        vector (justifying the definition of `N_rings` and `N_sites_per_ring`).</span>
<span class="sd">    basis : ndarray (dim, Dim)</span>
<span class="sd">        translation vectors shifting the unit cell. The row `i` gives the vector shifting in</span>
<span class="sd">        direction `i`.</span>
<span class="sd">    unit_cell_positions : ndarray, shape (len(unit_cell), Dim)</span>
<span class="sd">        for each site in the unit cell a vector giving its position within the unit cell.</span>
<span class="sd">    nearest_neighbors : ``None`` | list of ``(u1, u2, dx)``</span>
<span class="sd">        May be unspecified (``None``), otherwise it gives a list of parameters `u1`, `u2`, `dx`</span>
<span class="sd">        as needed for the :meth:`~tenpy.models.model.CouplingModel` to generate nearest-neighbor</span>
<span class="sd">        couplings.</span>
<span class="sd">        Note that we include each coupling only in one direction; to get both directions, use</span>
<span class="sd">        ``nearest_neighbors + [(u2, u1, -dx) for (u1, u2, dx) in nearest_neighbors]``.</span>
<span class="sd">    next_nearest_neighbors : ``None`` | list of ``(u1, u2, dx)``</span>
<span class="sd">        Same as :attr:`nearest_neighbors`, but for the next-nearest neigbhors.</span>
<span class="sd">    next_next_nearest_neighbors : ``None`` | list of ``(u1, u2, dx)``</span>
<span class="sd">        Same as :attr:`nearest_neighbors`, but for the next-next-nearest neigbhors.</span>
<span class="sd">    _order : ndarray (N_sites, dim+1)</span>
<span class="sd">        The place where :attr:`order` is stored.</span>
<span class="sd">    _strides : ndarray (dim, )</span>
<span class="sd">        necessary for :meth:`mps2lat_idx`</span>
<span class="sd">    _perm : ndarray (N, )</span>
<span class="sd">        permutation needed to make `order` lexsorted.</span>
<span class="sd">    _mps2lat_vals_idx : ndarray `shape`</span>
<span class="sd">        index array for reshape/reordering in :meth:`mps2lat_vals`</span>
<span class="sd">    _mps_fix_u : tuple of ndarray (N_cells, ) np.intp</span>
<span class="sd">        for each site of the unit cell an index array selecting the mps indices of that site.</span>
<span class="sd">    _mps2lat_vals_idx_fix_u : tuple of ndarray of shape `Ls`</span>
<span class="sd">        similar as `_mps2lat_vals_idx`, but for a fixed `u` picking a site from the unit cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">Ls</span><span class="p">,</span>
                 <span class="n">unit_cell</span><span class="p">,</span>
                 <span class="n">order</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
                 <span class="n">bc</span><span class="o">=</span><span class="s1">&#39;open&#39;</span><span class="p">,</span>
                 <span class="n">bc_MPS</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span><span class="p">,</span>
                 <span class="n">basis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">nearest_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">next_nearest_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">next_next_nearest_neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">Ls</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unit_cell</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_cells</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unit_cell</span><span class="p">),</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_rings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_sites_per_ring</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_rings</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">basis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_bc</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">=</span> <span class="n">bc_MPS</span>
        <span class="c1"># calculate order for MPS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordering</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="c1"># uses attribute setter to calculte _mps2lat_vals_idx_fix_u etc and lat2mps</span>
        <span class="c1"># calculate _strides</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">strides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">L</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span> <span class="o">=</span> <span class="n">nearest_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_nearest_neighbors</span> <span class="o">=</span> <span class="n">next_nearest_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_next_nearest_neighbors</span> <span class="o">=</span> <span class="n">next_next_nearest_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_sanity</span><span class="p">()</span>  <span class="c1"># check consistency</span>

<div class="viewcode-block" id="Lattice.test_sanity"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.test_sanity">[docs]</a>    <span class="k">def</span> <span class="nf">test_sanity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity check. Raises ValueErrors, if something is wrong.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">),</span> <span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_cells</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong len of bc&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span>
        <span class="n">chinfo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">site</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">chinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chinfo</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">Site</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;element of Unit cell is not Site.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">leg</span><span class="o">.</span><span class="n">chinfo</span> <span class="o">!=</span> <span class="n">chinfo</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All sites must have the same ChargeInfo!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need one basis vector for each direction!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need one position for each site in the unit cell.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Different space dimensions of `basis` and `unit_cell_positions`&quot;</span><span class="p">)</span>
        <span class="c1"># if one of the following assert fails, the `ordering` function returned an invalid array</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># entries of `order`</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strides</span><span class="p">,</span>
                   <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_perm</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span><span class="p">))</span>  <span class="c1"># rows of `order` unique?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MPS</span><span class="o">.</span><span class="n">_valid_bc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid MPS boundary conditions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need periodic boundary conditions along the x-direction &quot;</span>
                             <span class="s2">&quot;for &#39;infinite&#39; `bc_MPS`&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dimension of the lattice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defines an ordering of the lattice sites, thus mapping the lattice to a 1D chain.</span>

<span class="sd">        This order defines how an MPS/MPO winds through the lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>

    <span class="nd">@order</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order_</span><span class="p">):</span>
        <span class="c1"># update the value itself</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">order_</span>
        <span class="c1"># and the other stuff which is cached</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">order_</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># use advanced numpy indexing...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mps2lat_vals_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mps2lat_vals_idx</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">order_</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
        <span class="c1"># versions for fixed u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mps_fix_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mps2lat_vals_idx_fix_u</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="n">mps_fix_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">order_</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mps_fix_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps_fix_u</span><span class="p">)</span>
            <span class="n">mps2lat_vals_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="n">mps2lat_vals_idx</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">order_</span><span class="p">[</span><span class="n">mps_fix_u</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_cells</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mps2lat_vals_idx_fix_u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mps2lat_vals_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mps_fix_u</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mps_fix_u</span><span class="p">)</span>

<div class="viewcode-block" id="Lattice.ordering"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.ordering">[docs]</a>    <span class="k">def</span> <span class="nf">ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide possible orderings of the `N` lattice sites.</span>

<span class="sd">        This function can be overwritten by derived lattices to define additional orderings.</span>
<span class="sd">        The following orders are defined in this method:</span>

<span class="sd">        ================== =========================== =============================</span>
<span class="sd">        `order`            equivalent `priority`       equivalent ``snake_winding``</span>
<span class="sd">        ================== =========================== =============================</span>
<span class="sd">        ``&#39;Cstyle&#39;``       (0, 1, ..., dim-1, dim)     (False, ..., False, False)</span>
<span class="sd">        ``&#39;default&#39;``</span>
<span class="sd">        ``&#39;snake&#39;``        (0, 1, ..., dim-1, dim)     (True, ..., True, True)</span>
<span class="sd">        ``&#39;snakeCstyle&#39;``</span>
<span class="sd">        ``&#39;Fstyle&#39;``       (dim-1, ..., 1, 0, dim)     (False, ..., False, False)</span>
<span class="sd">        ``&#39;snakeFstyle&#39;``  (dim-1, ..., 1, 0, dim)     (False, ..., False, False)</span>
<span class="sd">        ================== =========================== =============================</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : str | ``(&#39;standard&#39;, snake_winding, priority)`` | ``(&#39;grouped&#39;, groups)``</span>
<span class="sd">            Specifies the desired ordering using one of the strings of the above tables.</span>
<span class="sd">            Alternatively, an ordering is specified by a tuple with first entry specifying a</span>
<span class="sd">            function, ``&#39;standard&#39;`` for :func:`get_order` and ``&#39;grouped&#39;`` for</span>
<span class="sd">            :func:`get_order_grouped`, and other arguments in the tuple as specified in the</span>
<span class="sd">            documentation of these functions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        order : array, shape (N, D+1), dtype np.intp</span>
<span class="sd">            the order to be used for :attr:`order`.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        get_order : generates the `order` from equivalent `priority` and `snake_winding`.</span>
<span class="sd">        get_order_grouped : variant of `get_order`.</span>
<span class="sd">        plot_order : visualizes the resulting `order`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="s2">&quot;Cstyle&quot;</span><span class="p">]:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">snake_winding</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;Fstyle&quot;</span><span class="p">:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">snake_winding</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;snake&quot;</span><span class="p">,</span> <span class="s2">&quot;snakeCstyle&quot;</span><span class="p">]:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">snake_winding</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;snakeFstyle&quot;</span><span class="p">:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">snake_winding</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># in a derived lattice use ``return super().ordering(order)`` as last option</span>
                <span class="c1"># such that the derived lattice also has the orderings defined in this function.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown ordering &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">descr</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
                <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">descr</span> <span class="o">==</span> <span class="s1">&#39;grouped&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">get_order_grouped</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unknown ordering &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">get_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.position"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.position">[docs]</a>    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return &#39;space&#39; position of one or multiple sites.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lat_idx : ndarray, ``(... , dim+1)``</span>
<span class="sd">            Lattice indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos : ndarray, ``(..., dim)``</span>
<span class="sd">            The position of the lattice sites specified by `lat_idx` in real-space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asvalid_latidx</span><span class="p">(</span><span class="n">lat_idx</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell_positions</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">idx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Lattice.site"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.site">[docs]</a>    <span class="k">def</span> <span class="nf">site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return :class:`~tenpy.networks.site.Site` instance corresponding to an MPS index `i`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="Lattice.mps_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps_sites">[docs]</a>    <span class="k">def</span> <span class="nf">mps_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of sites for all MPS indices.</span>

<span class="sd">        Equivalent to ``[self.site(i) for i in range(self.N_sites)]``.</span>

<span class="sd">        This should be used for `sites` of 1D tensor networks (MPS, MPO,...).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="Lattice.mps2lat_idx"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps2lat_idx">[docs]</a>    <span class="k">def</span> <span class="nf">mps2lat_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translate MPS index `i` to lattice indices ``(x_0, ..., x_{dim-1}, u)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int | array_like of int</span>
<span class="sd">            MPS index/indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lat_idx : array</span>
<span class="sd">            First dimensions like `i`, last dimension has len `dim`+1 and contains the lattice</span>
<span class="sd">            indices ``(x_0, ..., x_{dim-1}, u)`` corresponding to `i`.</span>
<span class="sd">            For `i` accross the MPS unit cell and &quot;infinite&quot; `bc_MPS`, we shift `x_0` accordingly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="c1"># allow `i` outsit of MPS unit cell for bc_MPS infinite</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">i0</span> <span class="o">!=</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">lat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i0</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_rings</span>
                <span class="k">return</span> <span class="n">lat</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Lattice.lat2mps_idx"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.lat2mps_idx">[docs]</a>    <span class="k">def</span> <span class="nf">lat2mps_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translate lattice indices ``(x_0, ..., x_{D-1}, u)`` to MPS index `i`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lat_idx : array_like [..., dim+1]</span>
<span class="sd">            The last dimension corresponds to lattice indices ``(x_0, ..., x_{D-1}, u)``.</span>
<span class="sd">            All lattice indices should be positive and smaller than the corresponding entry in</span>
<span class="sd">            ``self.shape``. Exception: for &quot;infinite&quot; `bc_MPS`, an `x_0` outside indicates shifts</span>
<span class="sd">            accross the boundary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        i : array_like</span>
<span class="sd">            MPS index/indices corresponding to `lat_idx`.</span>
<span class="sd">            Has the same shape as `lat_idx` without the last dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asvalid_latidx</span><span class="p">(</span><span class="n">lat_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="n">i_shift</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_rings</span><span class="p">)</span>
            <span class="n">idx</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">i_shift</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strides</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># before permutation</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_perm</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># after permutation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">i_shift</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_rings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span></div>

<div class="viewcode-block" id="Lattice.mps_idx_fix_u"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps_idx_fix_u">[docs]</a>    <span class="k">def</span> <span class="nf">mps_idx_fix_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return an index array of MPS indices for which the site within the unit cell is `u`.</span>

<span class="sd">        If you have multiple sites in your unit-cell, an onsite operator is in general not defined</span>
<span class="sd">        for all sites. This functions returns an index array of the mps indices which belong to</span>
<span class="sd">        sites given by ``self.unit_cell[u]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : None | int</span>
<span class="sd">            Selects a site of the unit cell. ``None`` (default) means all sites.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mps_idx : array</span>
<span class="sd">            MPS indices for which ``self.site(i) is self.unit_cell[u]``. Ordered ascending.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mps_fix_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perm</span></div>

<div class="viewcode-block" id="Lattice.mps_lat_idx_fix_u"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps_lat_idx_fix_u">[docs]</a>    <span class="k">def</span> <span class="nf">mps_lat_idx_fix_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Similar as :meth:`mps_idx_fix_u`, but return also the corresponding lattice indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : None | int</span>
<span class="sd">            Selects a site of the unit cell. ``None`` (default) means all sites.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mps_idx : array</span>
<span class="sd">            MPS indices `i` for which ``self.site(i) is self.unit_cell[u]``.</span>
<span class="sd">        lat_idx : 2D array</span>
<span class="sd">            The row `j` contains the lattice index (without `u`) corresponding to ``mps_idx[j]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mps_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mps_idx_fix_u</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mps_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">mps_idx</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Lattice.mps2lat_values"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.mps2lat_values">[docs]</a>    <span class="k">def</span> <span class="nf">mps2lat_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;reshape/reorder A to replace an MPS index by lattice indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : ndarray</span>
<span class="sd">            some values. Must have ``A.shape[axes] = self.N_sites`` if `u` is ``None``, or</span>
<span class="sd">            ``A.shape[axes] = self.N_cells`` if `u` is an int.</span>
<span class="sd">        axes : (iterable of) int</span>
<span class="sd">            chooses the axis which should be replaced.</span>
<span class="sd">        u : ``None`` | int</span>
<span class="sd">            Optionally choose a subset of MPS indices present in the axes of `A`, namely the</span>
<span class="sd">            indices corresponding to ``self.unit_cell[u]``, as returned by :meth:`mps_idx_fix_u`.</span>
<span class="sd">            The resulting array will not have the additional dimension(s) of `u`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res_A : ndarray</span>
<span class="sd">            reshaped and reordered verions of A. Such that an MPS index `j` is replaced by</span>
<span class="sd">            ``res_A[..., self.order, ...] = A[..., np.arange(self.N_sites), ...]``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Say you measure expection values of an onsite term for an MPS, which gives you an 1D array</span>
<span class="sd">        `A`, where `A[i]` is the expectation value of the site given by ``self.mps2lat_idx(i)``.</span>
<span class="sd">        Then this function gives you the expectation values ordered by the lattice:</span>

<span class="sd">        &gt;&gt;&gt; print(lat.shape, A.shape)</span>
<span class="sd">        (10, 3, 2) (60,)</span>
<span class="sd">        &gt;&gt;&gt; A_res = lat.mps2lat_values(A)</span>
<span class="sd">        &gt;&gt;&gt; A_res.shape</span>
<span class="sd">        (10, 3, 2)</span>
<span class="sd">        &gt;&gt;&gt; A_res[lat.mps2lat_idx(5)] == A[5]</span>
<span class="sd">        True</span>

<span class="sd">        If you have a correlation function ``C[i, j]``, it gets just slightly more complicated:</span>

<span class="sd">        &gt;&gt;&gt; print(lat.shape, C.shape)</span>
<span class="sd">        (10, 3, 2) (60, 60)</span>
<span class="sd">        &gt;&gt;&gt; lat.mps2lat_values(C, axes=[0, 1]).shape</span>
<span class="sd">        (10, 3, 2, 10, 3, 2)</span>

<span class="sd">        If the unit cell consists of different physical sites, an onsite operator might be defined</span>
<span class="sd">        only on one of the sites in the unit cell. Then you can use :meth:`mps_idx_fix_u` to get</span>
<span class="sd">        the indices of sites it is defined on, measure the operator on these sites, and use</span>
<span class="sd">        the argument `u` of this function. say y</span>

<span class="sd">        &gt;&gt;&gt; u = 0</span>
<span class="sd">        &gt;&gt;&gt; idx_subset = lat.mps_idx_fix_u(u)</span>
<span class="sd">        &gt;&gt;&gt; A_u = A[idx_subset]</span>
<span class="sd">        &gt;&gt;&gt; A_u_res = lat.mps2lat_values(A_u, u=u)</span>
<span class="sd">        &gt;&gt;&gt; A_u_res.shape</span>
<span class="sd">        (10, 3)</span>
<span class="sd">        &gt;&gt;&gt; np.all(A_res[:, :, u] == A_u_res[:, :])</span>
<span class="sd">        True</span>

<span class="sd">        .. todo ::</span>
<span class="sd">            make sure this function is used for expectation values...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">to_iterable</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ax</span> <span class="o">+</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>  <span class="c1"># need to start with largest axis!</span>
                <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mps2lat_values</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>  <span class="c1"># recursion with single axis</span>
            <span class="k">return</span> <span class="n">A</span>
        <span class="c1"># choose the appropriate index arrays</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mps2lat_vals_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mps2lat_vals_idx_fix_u</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Lattice.number_nearest_neighbors"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.number_nearest_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">number_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count the number of nearest neighbors for a site in the bulk.</span>

<span class="sd">        Requires :attr:`nearest_neighbors` to be set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : int</span>
<span class="sd">            Specifies the site in the unit cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        number_NN : int</span>
<span class="sd">            Number of nearest neighbors of the `u`-th site in the unit cell in the bulk of the</span>
<span class="sd">            lattice. Note that it might be different at the edges of the lattice for open boundary</span>
<span class="sd">            conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self.nearest_neighbors were not specified&quot;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u1</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">u2</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="Lattice.number_next_nearest_neighbors"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.number_next_nearest_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">number_next_nearest_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count the number of next nearest neighbors for a site in the bulk.</span>

<span class="sd">        Requires :attr:`next_nearest_neighbors` to be set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : int</span>
<span class="sd">            Specifies the site in the unit cell.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        number_NNN : int</span>
<span class="sd">            Number of next nearest neighbors of the `u`-th site in the unit cell in the bulk of the</span>
<span class="sd">            lattice. Note that it might be different at the edges of the lattice for open boundary</span>
<span class="sd">            conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_nearest_neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self.next_nearest_neighbors were not specified&quot;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_nearest_neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">u1</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">u2</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>

<div class="viewcode-block" id="Lattice.possible_couplings"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.possible_couplings">[docs]</a>    <span class="k">def</span> <span class="nf">possible_couplings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find possible MPS indices for two-site couplings.</span>

<span class="sd">        For periodic boundary conditions (``bc[a] == False``)</span>
<span class="sd">        the index ``x_a`` is taken modulo ``Ls[a]`` and runs through ``range(Ls[a])``.</span>
<span class="sd">        For open boundary conditions, ``x_a`` is limited to ``0 &lt;= x_a &lt; Ls[a]`` and</span>
<span class="sd">        ``0 &lt;= x_a+dx[a] &lt; lat.Ls[a]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u1, u2 : int</span>
<span class="sd">            Indices within the unit cell; the `u1` and `u2` of</span>
<span class="sd">            :meth:`~tenpy.models.model.CouplingModel.add_coupling`</span>
<span class="sd">        dx : array</span>
<span class="sd">            Length :attr:`dim`. The translation in terms of basis vectors for the coupling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mps1, mps2 : array</span>
<span class="sd">            For each possible two-site coupling the MPS indices for the `u1` and `u2`.</span>
<span class="sd">        lat_indices : 2D int array</span>
<span class="sd">            Rows of `lat_indices` correspond to rows of `mps_ijkl` and contain the lattice indices</span>
<span class="sd">            of the &quot;lower left corner&quot; of the box containing the coupling.</span>
<span class="sd">        coupling_shape : tuple of int</span>
<span class="sd">            Len :attr:`dim`. The correct shape for an array specifying the coupling strength.</span>
<span class="sd">            `lat_indices` has only rows within this shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coupling_shape</span><span class="p">,</span> <span class="n">shift_lat_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_shape</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">coupling_shape</span><span class="p">]):</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">]),</span> <span class="n">coupling_shape</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>
        <span class="n">N_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span>
        <span class="n">mps_i</span><span class="p">,</span> <span class="n">lat_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mps_lat_idx_fix_u</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
        <span class="n">lat_j_shifted</span> <span class="o">=</span> <span class="n">lat_i</span> <span class="o">+</span> <span class="n">dx</span>
        <span class="n">lat_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_j_shifted</span><span class="p">,</span> <span class="n">Ls</span><span class="p">)</span>  <span class="c1"># assuming PBC</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">lat_j_shifted</span> <span class="o">-</span> <span class="n">lat_j</span><span class="p">)</span> <span class="o">//</span> <span class="n">Ls</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lat_j_shifted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">shift</span>
            <span class="n">lat_j</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_j_shifted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="n">lat_j_shifted</span> <span class="o">==</span> <span class="n">lat_j</span><span class="p">,</span>  <span class="c1"># not accross the boundary</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">)),</span>  <span class="c1"># direction has PBC</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mps_i</span> <span class="o">=</span> <span class="n">mps_i</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">lat_indices</span> <span class="o">=</span> <span class="n">lat_i</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_lat_indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">lat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_indices</span><span class="p">,</span> <span class="n">coupling_shape</span><span class="p">)</span>
        <span class="n">lat_j</span> <span class="o">=</span> <span class="n">lat_j</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">lat_j_shifted</span> <span class="o">=</span> <span class="n">lat_j_shifted</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">mps_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat2mps_idx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">lat_j</span><span class="p">,</span> <span class="p">[[</span><span class="n">u2</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_j</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="c1"># shift j by whole MPS unit cells for couplings along the infinite direction</span>
            <span class="n">mps_j_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat_j_shifted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lat_j</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_sites</span> <span class="o">//</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">mps_j</span> <span class="o">+=</span> <span class="n">mps_j_shift</span>
            <span class="c1"># finally, ensure 0 &lt;= min(i, j) &lt; N_sites.</span>
            <span class="n">mps_ij_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mps_j_shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">mps_j_shift</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">mps_i</span> <span class="o">+=</span> <span class="n">mps_ij_shift</span>
            <span class="n">mps_j</span> <span class="o">+=</span> <span class="n">mps_ij_shift</span>
        <span class="k">return</span> <span class="n">mps_i</span><span class="p">,</span> <span class="n">mps_j</span><span class="p">,</span> <span class="n">lat_indices</span><span class="p">,</span> <span class="n">coupling_shape</span></div>

<div class="viewcode-block" id="Lattice.possible_multi_couplings"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.possible_multi_couplings">[docs]</a>    <span class="k">def</span> <span class="nf">possible_multi_couplings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">other_us</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generalization of :meth:`possible_couplings` to couplings with more than 2 sites.</span>

<span class="sd">        Given the arguments of :meth:`~tenpy.models.model.MultiCouplingModel.add_coupling`</span>
<span class="sd">        determine the necessary shape of `strength`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        u0 : int</span>
<span class="sd">            Argument `u0` of :meth:`~tenpy.models.model.MultiCouplingModel.add_multi_coupling`.</span>
<span class="sd">        other_us : list of int</span>
<span class="sd">            The `u` of the `other_ops` in</span>
<span class="sd">            :meth:`~tenpy.models.model.MultiCouplingModel.add_multi_coupling`.</span>
<span class="sd">        dx : array, shape (len(other_us), lat.dim+1)</span>
<span class="sd">            The `dx` specifying relative operator positions of the `other_ops` in</span>
<span class="sd">            :meth:`~tenpy.models.model.MultiCouplingModel.add_multi_coupling`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mps_ijkl : 2D int array</span>
<span class="sd">            Each row contains MPS indices `i,j,k,l,...`` for each of the operators positions.</span>
<span class="sd">            The positions are defined by `dx` (j,k,l,... relative to `i`) and boundary coundary</span>
<span class="sd">            conditions of `self` (how much the `box` for given `dx` can be shifted around without</span>
<span class="sd">            hitting a boundary - these are the different rows).</span>
<span class="sd">        lat_indices : 2D int array</span>
<span class="sd">            Rows of `lat_indices` correspond to rows of `mps_ijkl` and contain the lattice indices</span>
<span class="sd">            of the &quot;lower left corner&quot; of the box containing the coupling.</span>
<span class="sd">        coupling_shape : tuple of int</span>
<span class="sd">            Len :attr:`dim`. The correct shape for an array specifying the coupling strength.</span>
<span class="sd">            `lat_indices` has only rows within this shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coupling_shape</span><span class="p">,</span> <span class="n">shift_lat_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_coupling_shape</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">coupling_shape</span><span class="p">]):</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">coupling_shape</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>
        <span class="n">N_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span>
        <span class="n">mps_i</span><span class="p">,</span> <span class="n">lat_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mps_lat_idx_fix_u</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
        <span class="n">lat_jkl_shifted</span> <span class="o">=</span> <span class="n">lat_i</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># lat_jkl* has 3 axes &quot;initial site&quot;, &quot;other_op&quot;, &quot;spatial directions&quot;</span>
        <span class="n">lat_jkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_jkl_shifted</span><span class="p">,</span> <span class="n">Ls</span><span class="p">)</span>  <span class="c1"># assuming PBC</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">lat_jkl_shifted</span> <span class="o">-</span> <span class="n">lat_jkl</span><span class="p">)</span> <span class="o">//</span> <span class="n">Ls</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">lat_jkl_shifted</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">shift</span>
            <span class="n">lat_jkl</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_jkl_shifted</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="n">lat_jkl_shifted</span> <span class="o">==</span> <span class="n">lat_jkl</span><span class="p">,</span>  <span class="c1"># not accross the boundary</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">)),</span>  <span class="c1"># direction has PBC</span>
            <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">mps_i</span> <span class="o">=</span> <span class="n">mps_i</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">lat_indices</span> <span class="o">=</span> <span class="n">lat_i</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">shift_lat_indices</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">lat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_indices</span><span class="p">,</span> <span class="n">coupling_shape</span><span class="p">)</span>
        <span class="n">lat_jkl</span> <span class="o">=</span> <span class="n">lat_jkl</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">lat_jkl_shifted</span> <span class="o">=</span> <span class="n">lat_jkl_shifted</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">latu_jkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lat_jkl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other_us</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_jkl</span><span class="p">))[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span>
                                  <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mps_jkl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat2mps_idx</span><span class="p">(</span><span class="n">latu_jkl</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_MPS</span> <span class="o">==</span> <span class="s1">&#39;infinite&#39;</span><span class="p">:</span>
            <span class="c1"># shift by whole MPS unit cells for couplings along the infinite direction</span>
            <span class="n">mps_jkl</span> <span class="o">+=</span> <span class="p">(</span><span class="n">lat_jkl_shifted</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lat_jkl</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_sites</span> <span class="o">//</span> <span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mps_ijkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mps_i</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">mps_jkl</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mps_ijkl</span><span class="p">,</span> <span class="n">lat_indices</span><span class="p">,</span> <span class="n">coupling_shape</span></div>

<div class="viewcode-block" id="Lattice.coupling_shape"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.coupling_shape">[docs]</a>    <span class="k">def</span> <span class="nf">coupling_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate correct shape of the `strengths` for a coupling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dx : tuple of int</span>
<span class="sd">            Translation vector in the lattice for a coupling of two operators.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coupling_shape : tuple of int</span>
<span class="sd">            Len :attr:`dim`. The correct shape for an array specifying the coupling strength.</span>
<span class="sd">            `lat_indices` has only rows within this shape.</span>
<span class="sd">        shift_lat_indices : array</span>
<span class="sd">            Translation vector from lower left corner of box spanned by `dx` to the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">La</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dxa</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">bca</span><span class="p">)</span> <span class="k">for</span> <span class="n">La</span><span class="p">,</span> <span class="n">dxa</span><span class="p">,</span> <span class="n">bca</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">)]</span>
        <span class="n">shift_strength</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dxa</span><span class="p">)</span> <span class="k">for</span> <span class="n">dxa</span> <span class="ow">in</span> <span class="n">dx</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shift_strength</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.multi_coupling_shape"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.multi_coupling_shape">[docs]</a>    <span class="k">def</span> <span class="nf">multi_coupling_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate correct shape of the `strengths` for a multi_coupling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dx : tuple of int</span>
<span class="sd">            Translation vector in the lattice for a coupling of two operators.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coupling_shape : tuple of int</span>
<span class="sd">            Len :attr:`dim`. The correct shape for an array specifying the coupling strength.</span>
<span class="sd">            `lat_indices` has only rows within this shape.</span>
<span class="sd">        shift_lat_indices : array</span>
<span class="sd">            Translation vector from lower left corner of box spanned by `dx` to the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span>
        <span class="n">shift_strength</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)):</span>
            <span class="n">max_dx</span><span class="p">,</span> <span class="n">min_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dx</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dx</span><span class="p">[:,</span> <span class="n">a</span><span class="p">])</span>
            <span class="n">box_dx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ls</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-</span> <span class="n">box_dx</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">shift_strength</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_dx</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shift_strength</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.plot_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.plot_sites">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the sites of the lattice with markers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : :class:`matplotlib.axes.Axes`</span>
<span class="sd">            The axes on which we should plot.</span>
<span class="sd">        markers : list</span>
<span class="sd">            List of values for the keywork `marker` of ``ax.plot()`` to distinguish the different</span>
<span class="sd">            sites in the unit cell, a site `u` in the unit cell is plotted with a marker</span>
<span class="sd">            ``markers[u % len(markers)]``.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Further keyword arguments given to ``ax.plot()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;linestyle&quot;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>
        <span class="n">use_marker</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;marker&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mps_idx_fix_u</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># use broadcasting to add a column with zeros</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only plot in 2 dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_marker</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;marker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">markers</span><span class="p">[</span><span class="n">u</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">markers</span><span class="p">)]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.plot_order"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.plot_order">[docs]</a>    <span class="k">def</span> <span class="nf">plot_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">textkwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot a line connecting sites in the specified &quot;order&quot; and text labels enumerating them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : :class:`matplotlib.axes.Axes`</span>
<span class="sd">            The axes on which we should plot.</span>
<span class="sd">        order : None | 2D array (self.N_sites, self.dim+1)</span>
<span class="sd">            The order as returned by :meth:`ordering`; by default (``None``) use :attr:`order`.</span>
<span class="sd">        textkwargs: ``None`` | dict</span>
<span class="sd">            If not ``None``, we add text labels enumerating the sites in the plot. The dictionary</span>
<span class="sd">            can contain keyword arguments for ``ax.text()``.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Further keyword arguments given to ``ax.plot()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># use broadcasting to add a column with zeros</span>
        <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only plot in 2 dimensions.&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">textkwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">textkwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="o">**</span><span class="n">textkwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.plot_coupling"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.plot_coupling">[docs]</a>    <span class="k">def</span> <span class="nf">plot_coupling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">coupling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot lines connecting nearest neighbors of the lattice.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : :class:`matplotlib.axes.Axes`</span>
<span class="sd">            The axes on which we should plot.</span>
<span class="sd">        coupling : list of (u1, u2, dx)</span>
<span class="sd">            By default (``None``), use :attr:``nearest_neighbors``.</span>
<span class="sd">            Specifies the connections to be plotted; iteating over lattice indices `(i0, i1, ...)`,</span>
<span class="sd">            we plot a connection from the site ``(i0, i1, ..., u1)`` to the site</span>
<span class="sd">            ``(i0+dx[0], i1+dx[1], ..., u2)``, taking into account the boundary conditions.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Further keyword arguments given to ``ax.plot()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coupling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coupling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nearest_neighbors</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">Ls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">coupling</span><span class="p">:</span>
            <span class="c1"># TODO: should use `possible_couplings` somehow,</span>
            <span class="c1"># but then beriodic boundary conditions screew up the image</span>
            <span class="c1"># should plot couplings of periodic boundary conditions</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dx</span><span class="p">),</span> <span class="n">u2</span> <span class="o">-</span> <span class="n">u1</span><span class="p">]</span>  <span class="c1"># append the difference in u to dx</span>
            <span class="n">lat_idx_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mps_fix_u</span><span class="p">[</span><span class="n">u1</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">lat_idx_2</span> <span class="o">=</span> <span class="n">lat_idx_1</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">lat_idx_2_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_idx_2</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Ls</span><span class="p">)</span>
            <span class="c1"># handle boundary conditions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">lat_idx_2</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lat_idx_2_mod</span><span class="p">)</span> <span class="o">//</span> <span class="n">Ls</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span><span class="p">,</span>
                               <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">lat_idx_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">shift</span>
                <span class="n">lat_idx_2_mod</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">lat_idx_2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                    <span class="n">lat_idx_2_mod</span> <span class="o">==</span> <span class="n">lat_idx_2</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>  <span class="c1"># not accross the boundary</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">)),</span>  <span class="c1"># direction has PBC</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># get positions</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">lat_idx_1</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">(</span><span class="n">lat_idx_2</span><span class="p">[</span><span class="n">keep</span><span class="p">,</span> <span class="p">:])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># ax.plot connects columns of 2D array by lines</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]])</span>  <span class="c1"># use broadcasting to add a column with zeros</span>
            <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only plot in 2 dimensions.&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.plot_basis"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.plot_basis">[docs]</a>    <span class="k">def</span> <span class="nf">plot_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot arrows indicating the basis vectors of the lattice</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : :class:`matplotlib.axes.Axes`</span>
<span class="sd">            The axes on which we should plot.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments specifying the &quot;arrowprops&quot; of ``ax.annotate``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrowstyle&quot;</span><span class="p">,</span> <span class="s2">&quot;-&gt;&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">vec</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only plot in 2 dimensions.&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">arrowprops</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lattice.plot_bc_identified"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.plot_bc_identified">[docs]</a>    <span class="k">def</span> <span class="nf">plot_bc_identified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">direction</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark two sites indified by periodic boundary conditions</span>

<span class="sd">        Works only for lattice with a 2-dimensional basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : :class:`matplotlib.axes.Axes`</span>
<span class="sd">            The axes on which we should plot.</span>
<span class="sd">        direction : int</span>
<span class="sd">            The direction of the lattice along which we should mark the idenitified sites.</span>
<span class="sd">            If ``None``, mark it along all directions with periodic boundary conditions.</span>
<span class="sd">        shift : None | np.ndarray</span>
<span class="sd">            The origin starting from where we mark the identified sites.</span>
<span class="sd">            Defaults to the first entry of :attr:`unit_cell_positions`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments for the used ``ax.plot``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">direction</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
            <span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">direction</span><span class="p">]</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_cell_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;marker&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;markersize&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;orange&quot;</span><span class="p">)</span>
        <span class="n">x_y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Boundary conditons are not periodic for given direction&quot;</span><span class="p">)</span>
            <span class="n">x_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
            <span class="n">x_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x_y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x_y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_y</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">x_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only plot in 2D&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_y</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_asvalid_latidx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;convert lat_idx to an ndarray with correct last dimension.&quot;&quot;&quot;</span>
        <span class="n">lat_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lat_idx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lat_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wrong len of last dimension of lat_idx: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lat_idx</span>

    <span class="k">def</span> <span class="nf">_set_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">bc_choices</span>
        <span class="k">if</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">bc_choices</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc_choices</span><span class="p">[</span><span class="n">bc</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>  <span class="c1"># we modify entries...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bc</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc_i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid bc: first entry can&#39;t be a shift&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_i</span>
                    <span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_choices</span><span class="p">[</span><span class="s1">&#39;periodic&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_choices</span><span class="p">[</span><span class="n">bc_i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bc_shift</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span></div>


<div class="viewcode-block" id="TrivialLattice"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.TrivialLattice.html#tenpy.models.lattice.TrivialLattice">[docs]</a><span class="k">class</span> <span class="nc">TrivialLattice</span><span class="p">(</span><span class="n">Lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Trivial lattice consisting of a single (possibly large) unit cell in 1D.</span>

<span class="sd">    This is usefull if you need a valid :class:`Lattice` given just the :meth:`mps_sites`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mps_sites : list of :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The sites making up a unit cell of the lattice.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Further keyword arguments given to :class:`Lattice`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mps_sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Lattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mps_sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="IrregularLattice"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.IrregularLattice.html#tenpy.models.lattice.IrregularLattice">[docs]</a><span class="k">class</span> <span class="nc">IrregularLattice</span><span class="p">(</span><span class="n">Lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A variant of a regular lattice, where we might have extra sites or sites missing.</span>

<span class="sd">    .. todo ::</span>
<span class="sd">        this doesn&#39;t fully work yet...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mps_sites</span><span class="p">,</span> <span class="n">based_on</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">based_on</span> <span class="o">=</span> <span class="n">based_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mps_sites</span> <span class="o">=</span> <span class="n">mps_sites</span>
        <span class="n">Lattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">based_on</span><span class="o">.</span><span class="n">Ls</span><span class="p">,</span>
                         <span class="n">based_on</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">,</span>
                         <span class="n">order</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
                         <span class="n">bc</span><span class="o">=</span><span class="n">based_on</span><span class="o">.</span><span class="n">bc</span><span class="p">,</span>
                         <span class="n">bc_MPS</span><span class="o">=</span><span class="n">based_on</span><span class="o">.</span><span class="n">bc_MPS</span><span class="p">)</span>
        <span class="c1"># don&#39;t copy nearest_neighbors, basis, positions etc: no longer valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mps_sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">order</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_mps_sites</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mps_sites</span><span class="p">,</span> <span class="n">based_on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">based_on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">based_on</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mps_sites</span><span class="p">,</span> <span class="n">based_on</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_add_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="IrregularLattice.mps_sites"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.IrregularLattice.html#tenpy.models.lattice.IrregularLattice.mps_sites">[docs]</a>    <span class="k">def</span> <span class="nf">mps_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mps_sites</span></div></div>


<div class="viewcode-block" id="SimpleLattice"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.SimpleLattice.html#tenpy.models.lattice.SimpleLattice">[docs]</a><span class="k">class</span> <span class="nc">SimpleLattice</span><span class="p">(</span><span class="n">Lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A lattice with a unit cell consiting of just a single site.</span>

<span class="sd">    In many cases, the unit cell consists just of a single site, such that the the last entry of</span>
<span class="sd">    `u` of an &#39;lattice index&#39; can only be ``0``.</span>
<span class="sd">    From the point of internal algorithms, we handle this class like a :class:`Lattice` --</span>
<span class="sd">    in that way we don&#39;t need to distinguish special cases in the algorithms.</span>

<span class="sd">    Yet, from the point of a tenpy user, for example if you measure an expectation value</span>
<span class="sd">    on each site in a `SimpleLattice`, you expect to get an ndarray of dimensions ``self.Ls``,</span>
<span class="sd">    not ``self.shape``. To avoid that problem, `SimpleLattice` overwrites just the meaning of</span>
<span class="sd">    ``u=None`` in :meth:`mps2lat_values` to be the same as ``u=0``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ls : list of int</span>
<span class="sd">        the length in each direction</span>
<span class="sd">    site : :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        the lattice site. The `unit_cell` of the :class:`Lattice` is just ``[site]``.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        If `order` is specified in the form ``(&#39;standard&#39;, snake_windingi, priority)``,</span>
<span class="sd">        the `snake_winding` and `priority` should only be specified for the spatial directions.</span>
<span class="sd">        Similarly, `positions` can be specified as a single vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ls</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;positions&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">Dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;basis&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;basis&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ls</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;positions&#39;</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;order&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">descr</span><span class="p">,</span> <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">descr</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span>
            <span class="n">snake_winding</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">snake_winding</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">priority</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">priority</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">priority</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descr</span><span class="p">,</span> <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span>
        <span class="n">Lattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ls</span><span class="p">,</span> <span class="p">[</span><span class="n">site</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="SimpleLattice.mps2lat_values"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.SimpleLattice.html#tenpy.models.lattice.SimpleLattice.mps2lat_values">[docs]</a>    <span class="k">def</span> <span class="nf">mps2lat_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;same as :meth:`Lattice.mps2lat_values`, but ignore ``u``, setting it to ``0``.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mps2lat_values</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Chain"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Chain.html#tenpy.models.lattice.Chain">[docs]</a><span class="k">class</span> <span class="nc">Chain</span><span class="p">(</span><span class="n">SimpleLattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A chain of L equal sites.</span>

<span class="sd">    .. image :: /images/lattices/Chain.*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        The lenght of the chain.</span>
<span class="sd">    site : :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The local lattice site. The `unit_cell` of the :class:`Lattice` is just ``[site]``.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        `[[next_]next_]nearest_neighbors` are set accordingly.</span>
<span class="sd">        If `order` is specified in the form ``(&#39;standard&#39;, snake_winding, priority)``,</span>
<span class="sd">        the `snake_winding` and `priority` should only be specified for the spatial directions.</span>
<span class="sd">        Similarly, `positions` can be specified as a single vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;nearest_neighbors&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">]))])</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="mi">2</span><span class="p">,</span>
        <span class="p">]))])</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="mi">3</span><span class="p">,</span>
        <span class="p">]))])</span>
        <span class="c1"># and otherwise default values.</span>
        <span class="n">SimpleLattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ladder"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Ladder.html#tenpy.models.lattice.Ladder">[docs]</a><span class="k">class</span> <span class="nc">Ladder</span><span class="p">(</span><span class="n">Lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A ladder coupling two chains.</span>

<span class="sd">    .. image :: /images/lattices/Ladder.*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    L : int</span>
<span class="sd">        The length of each chain, we have 2*L sites in total.</span>
<span class="sd">    sites : (list of) :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The two local lattice sites making the `unit_cell` of the :class:`Lattice`.</span>
<span class="sd">        If only a single :class:`~tenpy.networks.site.Site` is given, it is used for both chains.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        `basis`, `pos` and `[[next_]next_]nearest_neighbors` are set accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="n">_parse_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">NN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]))]</span>
        <span class="n">nNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nnNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">]))]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nNN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nnNN</span><span class="p">)</span>
        <span class="n">Lattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Square"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Square.html#tenpy.models.lattice.Square">[docs]</a><span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">SimpleLattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A square lattice.</span>

<span class="sd">    .. image :: /images/lattices/Square.*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Lx, Ly : int</span>
<span class="sd">        The length in each direction.</span>
<span class="sd">    site : :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The local lattice site. The `unit_cell` of the :class:`Lattice` is just ``[site]``.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        `[[next_]next_]nearest_neighbors` are set accordingly.</span>
<span class="sd">        If `order` is specified in the form ``(&#39;standard&#39;, snake_windingi, priority)``,</span>
<span class="sd">        the `snake_winding` and `priority` should only be specified for the spatial directions.</span>
<span class="sd">        Similarly, `positions` can be specified as a single vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">NN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nnNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nNN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nnNN</span><span class="p">)</span>
        <span class="n">SimpleLattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">],</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Triangular</span><span class="p">(</span><span class="n">SimpleLattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A triangular lattice.</span>

<span class="sd">    .. image :: /images/lattices/Triangular.*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Lx, Ly : int</span>
<span class="sd">        The length in each direction.</span>
<span class="sd">    site : :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The local lattice site. The `unit_cell` of the :class:`Lattice` is just ``[site]``.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        `[[next_]next_]nearest_neighbors` are set accordingly.</span>
<span class="sd">        If `order` is specified in the form ``(&#39;standard&#39;, snake_windingi, priority)``,</span>
<span class="sd">        the `snake_winding` and `priority` should only be specified for the spatial directions.</span>
<span class="sd">        Similarly, `positions` can be specified as a single vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sqrt3_half</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># = cos(pi/6)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">sqrt3_half</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

        <span class="n">NN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))]</span>
        <span class="n">nnNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nNN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nnNN</span><span class="p">)</span>
        <span class="n">SimpleLattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">],</span> <span class="n">site</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="Honeycomb"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Honeycomb.html#tenpy.models.lattice.Honeycomb">[docs]</a><span class="k">class</span> <span class="nc">Honeycomb</span><span class="p">(</span><span class="n">Lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A honeycomb lattice.</span>

<span class="sd">    .. image :: /images/lattices/Honeycomb.*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Lx, Ly : int</span>
<span class="sd">        The length in each direction.</span>
<span class="sd">    sites : (list of) :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The two local lattice sites making the `unit_cell` of the :class:`Lattice`.</span>
<span class="sd">        If only a single :class:`~tenpy.networks.site.Site` is given, it is used for both sites.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        `basis`, `pos` and `[[next_]next_]nearest_neighbors` are set accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="n">_parse_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)),</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">delta</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">delta</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">NN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
               <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nnNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nNN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nnNN</span><span class="p">)</span>
        <span class="n">Lattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">],</span> <span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="Honeycomb.ordering"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Honeycomb.html#tenpy.models.lattice.Honeycomb.ordering">[docs]</a>    <span class="k">def</span> <span class="nf">ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide possible orderings of the `N` lattice sites.</span>

<span class="sd">        The following orders are defined in this method compared to :meth:`Lattice.ordering`:</span>

<span class="sd">        ================== =========================== =============================</span>
<span class="sd">        `order`            equivalent `priority`       equivalent ``snake_winding``</span>
<span class="sd">        ================== =========================== =============================</span>
<span class="sd">        ``&#39;default&#39;``      (0, 2, 1)                   (False, False, False)</span>
<span class="sd">        ``&#39;snake&#39;``        (0, 2, 1)                   (False, True, False)</span>
<span class="sd">        ================== =========================== =============================</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">snake_winding</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">get_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;snake&quot;</span><span class="p">:</span>
                <span class="n">priority</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">snake_winding</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">get_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ordering</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Kagome"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.Kagome.html#tenpy.models.lattice.Kagome">[docs]</a><span class="k">class</span> <span class="nc">Kagome</span><span class="p">(</span><span class="n">Lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A Kagome lattice.</span>

<span class="sd">    .. image :: /images/lattices/Kagome.*</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Lx, Ly : int</span>
<span class="sd">        The length in each direction.</span>
<span class="sd">    sites : (list of) :class:`~tenpy.networks.site.Site`</span>
<span class="sd">        The two local lattice sites making the `unit_cell` of the :class:`Lattice`.</span>
<span class="sd">        If only a single :class:`~tenpy.networks.site.Site` is given, it is used for both sites.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments given to the :class:`Lattice`.</span>
<span class="sd">        `basis`, `pos` and `[[next_]next_]nearest_neighbors` are set accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="n">_parse_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1">#     2</span>
        <span class="c1">#    / \</span>
        <span class="c1">#   /   \</span>
        <span class="c1">#  0-----1</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">3</span><span class="o">**</span><span class="mf">0.5</span><span class="p">]])</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;basis&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;positions&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">NN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span>
              <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
               <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))]</span>
        <span class="n">nnNN</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))]</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">NN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nNN</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;next_next_nearest_neighbors&#39;</span><span class="p">,</span> <span class="n">nnNN</span><span class="p">)</span>
        <span class="n">Lattice</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">],</span> <span class="n">sites</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_lattice"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.get_lattice.html#tenpy.models.lattice.get_lattice">[docs]</a><span class="k">def</span> <span class="nf">get_lattice</span><span class="p">(</span><span class="n">lattice_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given the name of a :class:`Lattice` class, create an instance of it with gi.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lattice_name : str</span>
<span class="sd">        Name of a :class:`Lattice` class defined in the module :mod:`~tenpy.models.lattice`,</span>
<span class="sd">        for example ``&quot;Chain&quot;, &quot;Square&quot;, &quot;Honeycomb&quot;, ...``.</span>
<span class="sd">    *args, **kwargs</span>
<span class="sd">        Arguments and keyword-arguments for the initialization of the specified lattice class.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    LatticeClass : (subclass of) :class:`Lattice`</span>
<span class="sd">        An instance of the lattice class specified by `lattice_name`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LatticeClass</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">lattice_name</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">LatticeClass</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LatticeClass</span></div>


<div class="viewcode-block" id="get_order"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.get_order.html#tenpy.models.lattice.get_order">[docs]</a><span class="k">def</span> <span class="nf">get_order</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">snake_winding</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Built the :attr:`Lattice.order` in (Snake-) C-Style for a given lattice shape.</span>

<span class="sd">    In this function, the word &#39;direction&#39; referst to a physical direction of the lattice or the</span>
<span class="sd">    index `u` of the unit cell as an &quot;artificial direction&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple of int</span>
<span class="sd">        The shape of the lattice, i.e., the length in each direction.</span>
<span class="sd">    snake_winding : tuple of bool</span>
<span class="sd">        For each direction one bool, whether we should wind as a &quot;snake&quot; (True) in that direction</span>
<span class="sd">        (i.e., going forth and back) or simply repeat ascending (False)</span>
<span class="sd">    priority : ``None`` | tuple of float</span>
<span class="sd">        If ``None`` (default), use C-Style ordering.</span>
<span class="sd">        Otherwise, this defines the priority along which direction to wind first;</span>
<span class="sd">        the direction with the highest priority increases fastest.</span>
<span class="sd">        For example, &quot;C-Style&quot; order is enforced by ``priority=(0, 1, 2, ...)``,</span>
<span class="sd">        and Fortrans F-style order is enforced by ``priority=(dim, dim-1, ..., 1, 0)``</span>
<span class="sd">    group : ``None`` | tuple of tuple</span>
<span class="sd">        If ``None`` (default), ignore it.</span>
<span class="sd">        Otherwise, it specifies that we group the fastests changing dimension</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    order : ndarray (np.prod(shape), len(shape))</span>
<span class="sd">        An order of the sites for :attr:`Lattice.order` in the specified `ordering`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    Lattice.ordering : method in :class:`Lattice` to obtain the order from parameters.</span>
<span class="sd">    Lattice.plot_order : visualizes the resulting order in a :class:`Lattice`.</span>
<span class="sd">    get_order_grouped : a variant grouping sites of the unit cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># reduce this case to C-style order and a few permutations</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">priority</span><span class="p">)</span>
        <span class="n">inv_perm</span> <span class="o">=</span> <span class="n">inverse_permutation</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">transp_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="n">perm</span><span class="p">]</span>
        <span class="n">transp_snake</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">snake_winding</span><span class="p">)[</span><span class="n">perm</span><span class="p">]</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">transp_shape</span><span class="p">,</span> <span class="n">transp_snake</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># in plain C-style</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[:,</span> <span class="n">inv_perm</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">order</span>
    <span class="c1"># simpler case: generate C-style order</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">snake_winding</span><span class="p">):</span>
        <span class="c1"># optimize: can use np.mgrid</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># some snake: generate direction by direction, each time adding a new column to `order`</span>
    <span class="n">snake_winding</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">snake_winding</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">snake</span> <span class="o">=</span> <span class="n">snake_winding</span><span class="p">[</span><span class="n">dim</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span>  <span class="c1"># previous direction snake?</span>
        <span class="n">L0</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># insert a new first column into order</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">L</span> <span class="o">*</span> <span class="n">L0</span><span class="p">,</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">new_order</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="n">L0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">snake</span><span class="p">:</span>
            <span class="n">new_order</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># snake</span>
            <span class="n">new_order</span><span class="p">[:</span><span class="n">L0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">order</span>
            <span class="n">L0_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">L0</span>
            <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># reverse order to go back for second index</span>
                <span class="n">new_order</span><span class="p">[</span><span class="n">L0</span><span class="p">:</span><span class="n">L0_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># repeat (ascending, descending) up to length L</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">L</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">rep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_order</span><span class="p">[</span><span class="n">L0_2</span><span class="p">:(</span><span class="n">rep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L0_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">new_order</span><span class="p">[:</span><span class="n">L0_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="p">(</span><span class="n">rep</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">L</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_order</span><span class="p">[</span><span class="o">-</span><span class="n">L0</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">order</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">new_order</span>
    <span class="k">return</span> <span class="n">order</span></div>


<div class="viewcode-block" id="get_order_grouped"><a class="viewcode-back" href="../../../reference/tenpy.models.lattice.get_order_grouped.html#tenpy.models.lattice.get_order_grouped">[docs]</a><span class="k">def</span> <span class="nf">get_order_grouped</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">groups</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Variant of :func:`get_order`, grouping some sites of the unit cell.</span>

<span class="sd">    In this function, the word &#39;direction&#39; referst to a physical direction of the lattice or the</span>
<span class="sd">    index `u` of the unit cell as an &quot;artificial direction&quot;.</span>
<span class="sd">    This function is usefull for lattices with a unit cell of more than 2 sites (e.g. Kagome).</span>
<span class="sd">    The argument `group` is a</span>
<span class="sd">    To explain the order, assume we have a 3-site unit cell in a 2D lattice with shape</span>
<span class="sd">    (Lx, Ly, Lu).</span>
<span class="sd">    Calling this function with groups=((1,), (2, 0)) returns an order of the following form::</span>

<span class="sd">        # columns: [x, y, u]</span>
<span class="sd">        [0, 0, 1]  # first for u = 1 along y</span>
<span class="sd">        [0, 1, 1]</span>
<span class="sd">            :</span>
<span class="sd">        [0, Ly-1, 1]</span>
<span class="sd">        [0, 0, 2]  # then for u = 2 and 0</span>
<span class="sd">        [0, 0, 0]</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        [0, 1, 0]</span>
<span class="sd">            :</span>
<span class="sd">        [0, Ly-1, 2]</span>
<span class="sd">        [0, Ly-1, 0]</span>
<span class="sd">        # and then repeat the above for increasing `x`.</span>



<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple of int</span>
<span class="sd">        The shape of the lattice, i.e., the length in each direction.</span>
<span class="sd">    groups : tuple of tuple of int</span>
<span class="sd">        A partition and reordering of range(shape[-1]) into smaller groups.</span>
<span class="sd">        The ordering goes first within a group, then along the last spatial dimensions, then</span>
<span class="sd">        changing between different groups and finally in Cstyle order along the remaining spatial</span>
<span class="sd">        dimensions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    order : ndarray (np.prod(shape), len(shape))</span>
<span class="sd">        An order of the sites for :attr:`Lattice.order` in the specified `ordering`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :meth:`Lattice.ordering` : method in :class:`Lattice` to obtain the order from parameters.</span>
<span class="sd">    :meth:`Lattice.plot_order` : visualizes the resulting order in a :class:`Lattice`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Lu</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">N_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># sanity check for argument group</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
    <span class="nb">all</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">groups</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">]</span>
    <span class="n">all_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">all_set</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Lu</span><span class="p">))</span>  <span class="c1"># does every number appear?</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_set</span><span class="p">)</span> <span class="o">==</span> <span class="n">Lu</span>  <span class="c1"># exactly once?</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="n">rLy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ly</span><span class="p">)</span>
    <span class="n">pre_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">Ly</span> <span class="o">*</span> <span class="n">Lu</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">gr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
        <span class="n">Lgr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">Lgr</span> <span class="o">*</span> <span class="n">Ly</span>
        <span class="n">pre_order</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">rLy</span><span class="p">,</span> <span class="n">Lgr</span><span class="p">)</span>
        <span class="n">pre_order</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">gr</span><span class="p">,</span> <span class="n">Ly</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>
    <span class="n">other_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">])</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N_sites</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">order</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">other_order</span><span class="p">,</span> <span class="n">Ly</span> <span class="o">*</span> <span class="n">Lu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">order</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">pre_order</span><span class="p">,</span> <span class="p">(</span><span class="n">N_sites</span> <span class="o">//</span> <span class="p">(</span><span class="n">Ly</span> <span class="o">*</span> <span class="n">Lu</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">order</span></div>


<span class="k">def</span> <span class="nf">_parse_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">expected_number</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>  <span class="c1"># allow to specify a single site</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">sites</span><span class="p">]</span> <span class="o">*</span> <span class="n">expected_number</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_number</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;need to specify a single site or exactly </span><span class="si">{0:d}</span><span class="s2">, got </span><span class="si">{1:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">expected_number</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">sites</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Tenpy Reference</a></li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">TeNPy 0.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on May 28, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.0.
    </div>
  </body>
</html>