
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tenpy.networks.mps module &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="tenpy.networks.purification_mps module" href="tenpy.networks.purification_mps.html" />
    <link rel="prev" title="tenpy.networks.mpo module" href="tenpy.networks.mpo.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.purification_mps.html" title="tenpy.networks.purification_mps module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mpo.html" title="tenpy.networks.mpo module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.networks.html" accesskey="U">tenpy.networks package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tenpy.networks.mps">
<span id="tenpy-networks-mps-module"></span><h1>tenpy.networks.mps module<a class="headerlink" href="#module-tenpy.networks.mps" title="Permalink to this headline">¶</a></h1>
<p>This module contains a base class for a Matrix Product State (MPS).</p>
<p>An MPS looks roughly like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">--</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">--</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">--</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">--</span> <span class="o">...</span>
<span class="o">|</span>       <span class="o">|</span>       <span class="o">|</span>      <span class="o">|</span>
</pre></div>
</div>
<p>We use the following label convention for the <cite>B</cite> (where arrows indicate <cite>qconj</cite>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>  <span class="n">vL</span> <span class="o">-&gt;-</span> <span class="n">B</span> <span class="o">-&gt;-</span> <span class="n">vR</span>
<span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">^</span>
<span class="o">|</span>         <span class="n">p</span>
</pre></div>
</div>
<p>We store one 3-leg tensor <cite>_B[i]</cite> with labels <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR',</span> <span class="pre">'p'</span></code> for each of the <cite>L</cite> sites
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">L</span></code>.
Additionally, we store <code class="docutils literal notranslate"><span class="pre">L+1</span></code> singular value arrays <cite>_S[ib]</cite> on each bond <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">ib</span> <span class="pre">&lt;=</span> <span class="pre">L</span></code>,
independent of the boundary conditions.
<code class="docutils literal notranslate"><span class="pre">_S[ib]</span></code> gives the singlur values on the bond <code class="docutils literal notranslate"><span class="pre">i-1,</span> <span class="pre">i</span></code>.
However, be aware that e.g. <a class="reference internal" href="#tenpy.networks.mps.MPS.chi" title="tenpy.networks.mps.MPS.chi"><code class="xref py py-attr docutils literal notranslate"><span class="pre">chi</span></code></a> returns only the dimensions of the
<a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a> depending on the boundary conditions.</p>
<p>The matrices and singular values always represent a normalized state
(i.e. <code class="docutils literal notranslate"><span class="pre">np.linalg.norm(psi._S[ib])</span> <span class="pre">==</span> <span class="pre">1</span></code> up to roundoff errors),
but (for finite MPS) we keep track of the norm in <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>
(which is respected by <a class="reference internal" href="#tenpy.networks.mps.MPS.overlap" title="tenpy.networks.mps.MPS.overlap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">overlap()</span></code></a>, …).</p>
<p>Valid MPS boundary conditions (not to confuse with <cite>bc_coupling</cite> of
<a class="reference internal" href="tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.CouplingModel</span></code></a>)  are the following:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>bc</cite></th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>‘finite’</td>
<td>Finite MPS, <code class="docutils literal notranslate"><span class="pre">G0</span> <span class="pre">s1</span> <span class="pre">G1</span> <span class="pre">...</span> <span class="pre">s{L-1}</span> <span class="pre">G{l-1}</span></code>. This is acchieved
by using a trivial left and right bond <code class="docutils literal notranslate"><span class="pre">s[0]</span> <span class="pre">=</span> <span class="pre">s[-1]</span> <span class="pre">=</span> <span class="pre">np.array([1.])</span></code>.</td>
</tr>
<tr class="row-odd"><td>‘segment’</td>
<td>Generalization of ‘finite’, describes an MPS embedded in left and right
environments. The left environment is described by <code class="docutils literal notranslate"><span class="pre">chi[0]</span></code> <em>orthonormal</em> states
which are weighted by the singular values <code class="docutils literal notranslate"><span class="pre">s[0]</span></code>. Similar, <code class="docutils literal notranslate"><span class="pre">s[L]</span></code> weight some
right orthonormal states. You can think of the left and right states to be
generated by additional MPS, such that the overall structure is something like
<code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">s</span> <span class="pre">L</span> <span class="pre">s</span> <span class="pre">L</span> <span class="pre">[s0</span> <span class="pre">G0</span> <span class="pre">s1</span> <span class="pre">G1</span> <span class="pre">...</span> <span class="pre">s{L-1}</span> <span class="pre">G{L-1}</span> <span class="pre">s{L}]</span> <span class="pre">R</span> <span class="pre">s</span> <span class="pre">R</span> <span class="pre">s</span> <span class="pre">R</span> <span class="pre">...</span></code>
(where we save the part in the brackets <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">...</span> <span class="pre">]</span></code> ).</td>
</tr>
<tr class="row-even"><td>‘infinite’</td>
<td>infinite MPS (iMPS): we save a ‘MPS unit cell’ <code class="docutils literal notranslate"><span class="pre">[s0</span> <span class="pre">G0</span> <span class="pre">s1</span> <span class="pre">G1</span> <span class="pre">...</span> <span class="pre">s{L-1}</span> <span class="pre">G{L-1}]</span></code>
which is repeated periodically, identifying all indices modulo <code class="docutils literal notranslate"><span class="pre">self.L</span></code>.
In particular, the last bond <code class="docutils literal notranslate"><span class="pre">L</span></code> is identified with <code class="docutils literal notranslate"><span class="pre">0</span></code>.
(The MPS unit cell can differ from a lattice unit cell).
bond is identified with the first one.</td>
</tr>
</tbody>
</table>
<p>An MPS can be in different ‘canonical forms’ (see <a class="reference internal" href="../literature.html#vidal2004" id="id1">[Vidal2004]</a>, <a class="reference internal" href="../literature.html#schollwoeck2011" id="id2">[Schollwoeck2011]</a>).
To take care of the different canonical forms, algorithms should use functions like
<a class="reference internal" href="#tenpy.networks.mps.MPS.get_theta" title="tenpy.networks.mps.MPS.get_theta"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_theta()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.get_B" title="tenpy.networks.mps.MPS.get_B"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_B()</span></code></a>
and <a class="reference internal" href="#tenpy.networks.mps.MPS.set_B" title="tenpy.networks.mps.MPS.set_B"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_B()</span></code></a> instead of accessing them directly,
as they return the <cite>B</cite> in the desired form (which can be chosen as an argument).</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="11%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>form</cite></th>
<th class="head">tuple</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'B'</span></code></td>
<td>(0, 1)</td>
<td>right canonical: <code class="docutils literal notranslate"><span class="pre">_B[i]</span> <span class="pre">=</span> <span class="pre">--</span> <span class="pre">Gamma[i]</span> <span class="pre">--</span> <span class="pre">s[i+1]--</span></code>
The default form, which algorithms asssume.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'C'</span></code></td>
<td>(0.5, 0.5)</td>
<td>symmetric form: <code class="docutils literal notranslate"><span class="pre">_B[i]</span> <span class="pre">=</span> <span class="pre">--</span> <span class="pre">s[i]**0.5</span> <span class="pre">--</span> <span class="pre">Gamma[i]</span> <span class="pre">--</span> <span class="pre">s[i+1]**0.5--</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'A'</span></code></td>
<td>(1, 0)</td>
<td>left canonical: <code class="docutils literal notranslate"><span class="pre">_B[i]</span> <span class="pre">=</span> <span class="pre">--</span> <span class="pre">s[i]</span> <span class="pre">--</span> <span class="pre">Gamma[i]</span> <span class="pre">--</span></code>.
For stability reasons, we recommend to <em>not</em> use this form.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'G'</span></code></td>
<td>(0, 0)</td>
<td>Save only <code class="docutils literal notranslate"><span class="pre">_B[i]</span> <span class="pre">=</span> <span class="pre">--</span> <span class="pre">Gamma[i]</span> <span class="pre">--</span></code>.
For stability reasons, we recommend to <em>not</em> use this form.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">None</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">None</span></code></td>
<td>General non-canoncial form.
Valid form for initialization, but you need to call
<a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> (or similar)
before using algorithms.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="tenpy.networks.mps.MPS">
<em class="property">class </em><code class="descclassname">tenpy.networks.mps.</code><code class="descname">MPS</code><span class="sig-paren">(</span><em>sites</em>, <em>Bs</em>, <em>SVs</em>, <em>bc='finite'</em>, <em>form='B'</em>, <em>norm=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A Matrix Product State, finite (MPS) or infinite (iMPS).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">Defines the local Hilbert space for each site.</p>
</dd>
<dt><strong>Bs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The ‘matrices’ of the MPS. Labels are <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p</span></code> (in any order).</p>
</dd>
<dt><strong>SVs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D array</span></dt>
<dd><p class="first last">The singular values on <em>each</em> bond. Should always have length <cite>L+1</cite>.
Entries out of <a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a> are ignored.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'finite'</span> <span class="pre">|</span> <span class="pre">'segment'</span> <span class="pre">|</span> <span class="pre">'infinite'</span></code></span></dt>
<dd><p class="first last">Boundary conditions as described in the tabel of the module doc-string.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">The form of the stored ‘matrices’, see table in module doc-string.
A single choice holds for all of the entries.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.L" title="tenpy.networks.mps.MPS.L"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L</span></code></a></dt>
<dd><p class="first last">Number of physical sites.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.chi" title="tenpy.networks.mps.MPS.chi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi</span></code></a></dt>
<dd><p class="first last">Dimensions of the (nontrivial) virtual bonds.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.finite" title="tenpy.networks.mps.MPS.finite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finite</span></code></a></dt>
<dd><p class="first last">Distinguish MPS (<code class="docutils literal notranslate"><span class="pre">True;</span> <span class="pre">bc='finite',</span> <span class="pre">'segment'</span></code> ) vs.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a></dt>
<dd><p class="first last">Slice of the non-trivial bond indices, depending on <code class="docutils literal notranslate"><span class="pre">self.bc</span></code>.</p>
</dd>
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">Defines the local Hilbert space for each site.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘finite’, ‘segment’, ‘infinite’}</span></dt>
<dd><p class="first last">Boundary conditions as described in above table.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of {<code class="docutils literal notranslate"><span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">Describes the canonical form on each site.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means non-canonical form.
For <code class="docutils literal notranslate"><span class="pre">form</span> <span class="pre">=</span> <span class="pre">(nuL,</span> <span class="pre">nuR)</span></code>, the stored <code class="docutils literal notranslate"><span class="pre">_B[i]</span></code> are
<code class="docutils literal notranslate"><span class="pre">s**form[0]</span> <span class="pre">--</span> <span class="pre">Gamma</span> <span class="pre">--</span> <span class="pre">s**form[1]</span></code> (in Vidal’s notation).</p>
</dd>
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type</span></dt>
<dd><p class="first last">The data type of the <code class="docutils literal notranslate"><span class="pre">_B</span></code>.</p>
</dd>
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The norm of the state, i.e. <code class="docutils literal notranslate"><span class="pre">sqrt(&lt;psi|psi&gt;)</span></code>.
Ignored for (normalized) <a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value" title="tenpy.networks.mps.MPS.expectation_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expectation_value()</span></code></a>, but important for <a class="reference internal" href="#tenpy.networks.mps.MPS.overlap" title="tenpy.networks.mps.MPS.overlap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">overlap()</span></code></a>.</p>
</dd>
<dt><strong>grouped</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites grouped together, see <a class="reference internal" href="#tenpy.networks.mps.MPS.group_sites" title="tenpy.networks.mps.MPS.group_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group_sites()</span></code></a>.</p>
</dd>
<dt><strong>_B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">npc.Array</span></code></span></dt>
<dd><p class="first last">The ‘matrices’ of the MPS. Labels are <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p</span></code> (in any order).
We recommend using <a class="reference internal" href="#tenpy.networks.mps.MPS.get_B" title="tenpy.networks.mps.MPS.get_B"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_B()</span></code></a> and <a class="reference internal" href="#tenpy.networks.mps.MPS.set_B" title="tenpy.networks.mps.MPS.set_B"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_B()</span></code></a>, which will take care of the different
canonical forms.</p>
</dd>
<dt><strong>_S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (<code class="docutils literal notranslate"><span class="pre">None</span></code> | 1D array)</span></dt>
<dd><p class="first last">The singular values on each virtual bond, length <code class="docutils literal notranslate"><span class="pre">L+1</span></code>.
May be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the MPS is not in canonical form.
Otherwise, <code class="docutils literal notranslate"><span class="pre">_S[i]</span></code> is to the left of <code class="docutils literal notranslate"><span class="pre">_B[i]</span></code>.
We recommend using <a class="reference internal" href="#tenpy.networks.mps.MPS.get_SL" title="tenpy.networks.mps.MPS.get_SL"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_SL()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.get_SR" title="tenpy.networks.mps.MPS.get_SR"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_SR()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.set_SL" title="tenpy.networks.mps.MPS.set_SL"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_SL()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.set_SR" title="tenpy.networks.mps.MPS.set_SR"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_SR()</span></code></a>, which
takes proper care of the boundary conditions.</p>
</dd>
<dt><strong>_valid_forms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Mapping for canonical forms to a tuple <code class="docutils literal notranslate"><span class="pre">(nuL,</span> <span class="pre">nuR)</span></code> indicating that
<code class="docutils literal notranslate"><span class="pre">self._Bs[i]</span> <span class="pre">=</span> <span class="pre">s[i]**nuL</span> <span class="pre">--</span> <span class="pre">Gamma[i]</span> <span class="pre">--</span> <span class="pre">s[i]**nuR</span></code> is saved.</p>
</dd>
<dt><strong>_valid_bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of str</span></dt>
<dd><p class="first last">Valid boundary conditions.</p>
</dd>
<dt><strong>_transfermatrix_keep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many states to keep at least when diagonalizing a <a class="reference internal" href="#tenpy.networks.mps.TransferMatrix" title="tenpy.networks.mps.TransferMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferMatrix</span></code></a>.
Important if the state develops a near-degeneracy.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.add" title="tenpy.networks.mps.MPS.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(other,&nbsp;alpha,&nbsp;beta)</td>
<td>Return an MPS which represents <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.apply_local_op" title="tenpy.networks.mps.MPS.apply_local_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_local_op</span></code></a>(i,&nbsp;op[,&nbsp;unitary,&nbsp;renormalize])</td>
<td>Apply a local operator to <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.average_charge" title="tenpy.networks.mps.MPS.average_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_charge</span></code></a>([bond])</td>
<td>Return the average charge for the block on the left of a given bond.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form</span></code></a>([renormalize])</td>
<td>Bring self into canonical ‘B’ form, (re-)calculate singular values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_finite" title="tenpy.networks.mps.MPS.canonical_form_finite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form_finite</span></code></a>([renormalize])</td>
<td>Bring a finite (or segment) MPS into canonical form (in place).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_infinite" title="tenpy.networks.mps.MPS.canonical_form_infinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form_infinite</span></code></a>([renormalize,&nbsp;tol_xi])</td>
<td>Bring an infinite MPS into canonical form (in place).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.charge_variance" title="tenpy.networks.mps.MPS.charge_variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">charge_variance</span></code></a>([bond])</td>
<td>Return the charge variance on the left of a given bond.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.compute_K" title="tenpy.networks.mps.MPS.compute_K"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_K</span></code></a>(perm[,&nbsp;swap_op,&nbsp;trunc_par,&nbsp;…])</td>
<td>Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.convert_form" title="tenpy.networks.mps.MPS.convert_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_form</span></code></a>([new_form])</td>
<td>Tranform self into different canonical form (by scaling the legs with singular values).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.copy" title="tenpy.networks.mps.MPS.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Returns a copy of <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.correlation_function" title="tenpy.networks.mps.MPS.correlation_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_function</span></code></a>(ops1,&nbsp;ops2[,&nbsp;sites1,&nbsp;…])</td>
<td>Correlation function  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op1_i</span> <span class="pre">op2_j|psi&gt;/&lt;psi|psi&gt;</span></code> of single site operators.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.correlation_length" title="tenpy.networks.mps.MPS.correlation_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_length</span></code></a>([target,&nbsp;tol_ev0])</td>
<td>Calculate the correlation length by diagonalizing the transfer matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_entropy" title="tenpy.networks.mps.MPS.entanglement_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_entropy</span></code></a>([n,&nbsp;bonds,&nbsp;for_matrix_S])</td>
<td>Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_entropy_segment" title="tenpy.networks.mps.MPS.entanglement_entropy_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_entropy_segment</span></code></a>([segment,&nbsp;…])</td>
<td>Calculate entanglement entropy for general geometry of the bipartition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_spectrum" title="tenpy.networks.mps.MPS.entanglement_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_spectrum</span></code></a>([by_charge])</td>
<td>return entanglement energy spectrum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value" title="tenpy.networks.mps.MPS.expectation_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value</span></code></a>(ops[,&nbsp;sites,&nbsp;axes])</td>
<td>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;</span></code> of (n-site) operator(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_multi_sites" title="tenpy.networks.mps.MPS.expectation_value_multi_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_multi_sites</span></code></a>(operators,&nbsp;i0)</td>
<td>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_term" title="tenpy.networks.mps.MPS.expectation_value_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_term</span></code></a>(term[,&nbsp;autoJW])</td>
<td>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_terms_sum" title="tenpy.networks.mps.MPS.expectation_value_terms_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_terms_sum</span></code></a>(term_list,&nbsp;…)</td>
<td>Calculate expectation values for a bunch of terms and sum them up.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.from_Bflat" title="tenpy.networks.mps.MPS.from_Bflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_Bflat</span></code></a>(sites,&nbsp;Bflat[,&nbsp;SVs,&nbsp;bc,&nbsp;dtype,&nbsp;…])</td>
<td>Construct a matrix product state from a set of numpy arrays <cite>Bflat</cite> and singular vals.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.from_full" title="tenpy.networks.mps.MPS.from_full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_full</span></code></a>(sites,&nbsp;psi[,&nbsp;form,&nbsp;cutoff,&nbsp;normalize])</td>
<td>Construct an MPS from a single tensor <cite>psi</cite> with one leg per physical site.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.from_product_state" title="tenpy.networks.mps.MPS.from_product_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_product_state</span></code></a>(sites,&nbsp;p_state[,&nbsp;bc,&nbsp;…])</td>
<td>Construct a matrix product state from a given product state.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.from_singlets" title="tenpy.networks.mps.MPS.from_singlets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_singlets</span></code></a>(site,&nbsp;L,&nbsp;pairs[,&nbsp;up,&nbsp;down,&nbsp;…])</td>
<td>Create an MPS of entangled singlets.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.gauge_total_charge" title="tenpy.networks.mps.MPS.gauge_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_total_charge</span></code></a>([qtotal])</td>
<td>Gauge the legcharges of the virtual bonds such that the MPS has a total <cite>qtotal</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_B" title="tenpy.networks.mps.MPS.get_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_B</span></code></a>(i[,&nbsp;form,&nbsp;copy,&nbsp;cutoff])</td>
<td>Return (view of) <cite>B</cite> at site <cite>i</cite> in canonical form.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_SL" title="tenpy.networks.mps.MPS.get_SL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_SL</span></code></a>(i)</td>
<td>Return singular values on the left of site <cite>i</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_SR" title="tenpy.networks.mps.MPS.get_SR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_SR</span></code></a>(i)</td>
<td>Return singular values on the right of site <cite>i</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_grouped_mps" title="tenpy.networks.mps.MPS.get_grouped_mps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_grouped_mps</span></code></a>(blocklen)</td>
<td>contract blocklen subsequent tensors into a single one and return result as a new MPS.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_op" title="tenpy.networks.mps.MPS.get_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_op</span></code></a>(op_list,&nbsp;i)</td>
<td>Given a list of operators, select the one corresponding to site <cite>i</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_rho_segment" title="tenpy.networks.mps.MPS.get_rho_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_rho_segment</span></code></a>(segment)</td>
<td>Return reduced density matrix for a segment.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_theta" title="tenpy.networks.mps.MPS.get_theta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_theta</span></code></a>(i[,&nbsp;n,&nbsp;cutoff,&nbsp;formL,&nbsp;formR])</td>
<td>Calculates the <cite>n</cite>-site wavefunction on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.get_total_charge" title="tenpy.networks.mps.MPS.get_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_total_charge</span></code></a>()</td>
<td>Calculate and return the <cite>qtotal</cite> of the whole MPS (when contracted).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.group_sites" title="tenpy.networks.mps.MPS.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> inplace to group sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.group_split" title="tenpy.networks.mps.MPS.group_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_split</span></code></a>([trunc_par])</td>
<td>Modify <cite>self</cite> inplace to split previously grouped sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.mutinf_two_site" title="tenpy.networks.mps.MPS.mutinf_two_site"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutinf_two_site</span></code></a>([max_range,&nbsp;n])</td>
<td>Calculate the two-site mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.norm_test" title="tenpy.networks.mps.MPS.norm_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_test</span></code></a>()</td>
<td>Check that self is in canonical form.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.overlap" title="tenpy.networks.mps.MPS.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code></a>(other[,&nbsp;charge_sector,&nbsp;ignore_form])</td>
<td>Compute overlap <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.permute_sites" title="tenpy.networks.mps.MPS.permute_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute_sites</span></code></a>(perm[,&nbsp;swap_op,&nbsp;trunc_par,&nbsp;…])</td>
<td>Applies the permutation perm to the state (inplace).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.probability_per_charge" title="tenpy.networks.mps.MPS.probability_per_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">probability_per_charge</span></code></a>([bond])</td>
<td>Return probabilites of charge value on the left of a given bond.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.set_B" title="tenpy.networks.mps.MPS.set_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_B</span></code></a>(i,&nbsp;B[,&nbsp;form])</td>
<td>Set <cite>B</cite> at site <cite>i</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.set_SL" title="tenpy.networks.mps.MPS.set_SL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_SL</span></code></a>(i,&nbsp;S)</td>
<td>Set singular values on the left of site <cite>i</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.set_SR" title="tenpy.networks.mps.MPS.set_SR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_SR</span></code></a>(i,&nbsp;S)</td>
<td>Set singular values on the right of site <cite>i</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.swap_sites" title="tenpy.networks.mps.MPS.swap_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_sites</span></code></a>(i[,&nbsp;swap_op,&nbsp;trunc_par])</td>
<td>Swap the two neighboring sites <cite>i</cite> and <cite>i+1</cite> (inplace).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPS.test_sanity" title="tenpy.networks.mps.MPS.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.L">
<code class="descname">L</code><a class="headerlink" href="#tenpy.networks.mps.MPS.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of physical sites. For an iMPS the len of the MPS unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>other</em>, <em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an MPS which represents <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</p>
<p>Works only for ‘finite’ boundary conditions.
Takes into account <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">Another MPS of the same length to be added with self.</p>
</dd>
<dt><strong>alpha, beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex float</span></dt>
<dd><p class="first last">Prefactors for self and other. We calculate
<code class="docutils literal notranslate"><span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">|other&gt;</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sum</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">An MPS representing <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.apply_local_op">
<code class="descname">apply_local_op</code><span class="sig-paren">(</span><em>i</em>, <em>op</em>, <em>unitary=None</em>, <em>renormalize=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.apply_local_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.apply_local_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a local operator to <cite>self</cite>.</p>
<p>Note that this destroys the canonical form if the local operator is non-unitary.
Therefore, this function calls <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index of the site on which the operator should act.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | npc.Array</span></dt>
<dd><p class="first last">A physical operator acting on site <cite>i</cite>, with legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'p*'</span></code>.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>unitary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | bool</span></dt>
<dd><p class="first last">Whether <cite>op</cite> is unitary, i.e., whether the canonical form is preserved (<code class="docutils literal notranslate"><span class="pre">True</span></code>)
or whether we should call <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">False</span></code>).
<code class="docutils literal notranslate"><span class="pre">None</span></code> checks whether <code class="docutils literal notranslate"><span class="pre">norm(op</span> <span class="pre">dagger(op)</span> <span class="pre">-</span> <span class="pre">identity)</span></code> is small.</p>
</dd>
<dt><strong>renormalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the final state should keep track of the norm (False, default) or be
renormalized to have norm 1 (True).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.average_charge">
<code class="descname">average_charge</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.average_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.average_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average charge for the block on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
Then this function returns <span class="math notranslate nohighlight">\(&lt;\psi| N_b |\psi&gt;\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The bond to be considered.
The returned charges are summed over the sites left of <cite>bond</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>average_charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">For each type of charge in <code class="xref py py-attr docutils literal notranslate"><span class="pre">chinfo</span></code>
the average value when summing the charge values over sites left of the given bond.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.canonical_form">
<code class="descname">canonical_form</code><span class="sig-paren">(</span><em>renormalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.canonical_form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.canonical_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring self into canonical ‘B’ form, (re-)calculate singular values.</p>
<p>Simply calls <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_finite" title="tenpy.networks.mps.MPS.canonical_form_finite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form_finite()</span></code></a> or <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_infinite" title="tenpy.networks.mps.MPS.canonical_form_infinite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form_infinite()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.canonical_form_finite">
<code class="descname">canonical_form_finite</code><span class="sig-paren">(</span><em>renormalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.canonical_form_finite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.canonical_form_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring a finite (or segment) MPS into canonical form (in place).</p>
<p>If any site is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>, it does <em>not</em> use any of the singular values <cite>S</cite>
(for ‘finite’ boundary conditions, or only the very left <cite>S</cite> for ‘segment’ b.c.).
If all sites have a <cite>form</cite>, it respects the <cite>form</cite> to ensure
that one <cite>S</cite> is included per bond.
The final state is always in right-canonical ‘B’ form.</p>
<p>Performs one sweep left to right doing QR decompositions, and one sweep right to left
doing SVDs calculating the singular values.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Should we try to avoid carrying around the total charge of the B matrices?</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>renormalize: bool</strong></dt>
<dd><p class="first last">Whether a change in the norm should be discarded or used to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_L, V_R</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Only returned for <code class="docutils literal notranslate"><span class="pre">'segment'</span></code> boundary conditions.
The unitaries defining the new left and right Schmidt states in terms of the old ones,
with legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.canonical_form_infinite">
<code class="descname">canonical_form_infinite</code><span class="sig-paren">(</span><em>renormalize=True</em>, <em>tol_xi=1000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.canonical_form_infinite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.canonical_form_infinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring an infinite MPS into canonical form (in place).</p>
<p>If any site is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>, it does <em>not</em> use any of the singular values <cite>S</cite>.
If all sites have a <cite>form</cite>, it respects the <cite>form</cite> to ensure
that one <cite>S</cite> is included per bond.
The final state is always in right-canonical ‘B’ form.</p>
<p>Proceeds in three steps, namely 1) diagonalize right and left transfermatrix on a given
bond to bring that bond into canonical form, and then
2) sweep right to left, and 3) left to right to bringing other bonds into canonical form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>renormalize: bool</strong></dt>
<dd><p class="first last">Whether a change in the norm should be discarded or used to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd>
<dt><strong>tol_xi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Raise an error if the correlation length is larger than that
(which indicates a degenerate “cat” state, e.g., for spontaneous symmetry breaking).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.charge_variance">
<code class="descname">charge_variance</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.charge_variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.charge_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the charge variance on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
Then this function returns <span class="math notranslate nohighlight">\(&lt;\psi| N_b^2 |\psi&gt; - (&lt;\psi| N_b |\psi&gt;)^2\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The bond to be considered.
The returned charges are summed over the sites left of <cite>bond</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>average_charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">For each type of charge in <code class="xref py py-attr docutils literal notranslate"><span class="pre">chinfo</span></code>
the variance of of the charge values left of the given bond.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.chi">
<code class="descname">chi</code><a class="headerlink" href="#tenpy.networks.mps.MPS.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimensions of the (nontrivial) virtual bonds.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.compute_K">
<code class="descname">compute_K</code><span class="sig-paren">(</span><em>perm</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em>, <em>canonicalize=1e-06</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.compute_K"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.compute_K" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</p>
<p>Works for an infinite MPS living on a cylinder, infinitely long in <cite>x</cite> direction and with
periodic boundary conditions in <cite>y</cite> directions.
If the state is invariant under ‘rotations’ around the cylinder axis, one can find the
momentum quantum numbers of it. (The rotation is nothing more than a translation in <cite>y</cite>.)
This function permutes some sites (on a copy of <cite>self</cite>) to enact the rotation, and then
finds the dominant eigenvector of the mixed transfer matrix to get the quantum numbers,
along the lines of <a class="reference internal" href="../literature.html#pollmannturner2012" id="id3">[PollmannTurner2012]</a>, see also (the appendix and Fig. 11 in the arXiv
version of) <a class="reference internal" href="../literature.html#cinciovidal2013" id="id4">[CincioVidal2013]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray | <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a></span></dt>
<dd><p class="first last">Permuation to be applied to the physical indices, see <a class="reference internal" href="#tenpy.networks.mps.MPS.permute_sites" title="tenpy.networks.mps.MPS.permute_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permute_sites()</span></code></a>.
If a lattice is given, we use it to read out the lattice structure and shift
each site by one lattice-vector in y-direction (assuming periodic boundary conditions).
(If you have a <a class="reference internal" href="tenpy.models.model.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a>,
give its <cite>lat</cite> attribute for this argument)</p>
</dd>
<dt><strong>swap_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The operator used to swap the phyiscal legs of a two-site wave function <cite>theta</cite>,
see <a class="reference internal" href="#tenpy.networks.mps.MPS.swap_sites" title="tenpy.networks.mps.MPS.swap_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swap_sites()</span></code></a>.</p>
</dd>
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
<dt><strong>canonicalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Check that <cite>self</cite> is in canonical form; call <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a>
if <a class="reference internal" href="#tenpy.networks.mps.MPS.norm_test" title="tenpy.networks.mps.MPS.norm_test"><code class="xref py py-meth docutils literal notranslate"><span class="pre">norm_test()</span></code></a> yields <code class="docutils literal notranslate"><span class="pre">np.linalg.norm(self.norm_test())</span> <span class="pre">&gt;</span> <span class="pre">canonicalize</span></code>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Level of verbosity, print status messages if verbose &gt; 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Unitary representation of the applied permutation on left Schmidt states.</p>
</dd>
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">1D array of the form <code class="docutils literal notranslate"><span class="pre">S**2</span> <span class="pre">exp(i</span> <span class="pre">K)</span></code>, where <cite>S</cite> are the Schmidt values
on the left bond. You can use <code class="xref py py-func docutils literal notranslate"><span class="pre">np.abs()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">np.angle()</span></code> to extract the
Schmidt values <cite>S</cite> and momenta <cite>K</cite> from <cite>W</cite>.</p>
</dd>
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">LegCharge corresponding to <cite>W</cite>.</p>
</dd>
<dt><strong>ov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex</span></dt>
<dd><p class="first last">The eigenvalue of the mixed transfer matrix <cite>&lt;psi|T|psi&gt;</cite> per <a class="reference internal" href="#tenpy.networks.mps.MPS.L" title="tenpy.networks.mps.MPS.L"><code class="xref py py-attr docutils literal notranslate"><span class="pre">L</span></code></a> sites.
An absolute value different smaller than 1 indicates that the state is not invariant
under the permutation or that the truncation error <cite>trunc_err</cite> was too large!</p>
</dd>
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error of the represented state introduced by the truncation after swaps when
performing the truncation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.convert_form">
<code class="descname">convert_form</code><span class="sig-paren">(</span><em>new_form='B'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.convert_form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.convert_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Tranform self into different canonical form (by scaling the legs with singular values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>new_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">The form the stored ‘matrices’. The table in module doc-string.
A single choice holds for all of the entries.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if trying to convert from a <code class="docutils literal notranslate"><span class="pre">None</span></code> form. Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">canonicalize()</span></code> instead!</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of <cite>self</cite>.</p>
<p>The copy still shares the sites, chinfo, and LegCharges of the _B,
but the values of B and S are deeply copied.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.correlation_function">
<code class="descname">correlation_function</code><span class="sig-paren">(</span><em>ops1</em>, <em>ops2</em>, <em>sites1=None</em>, <em>sites2=None</em>, <em>opstr=None</em>, <em>str_on_first=True</em>, <em>hermitian=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.correlation_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.correlation_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlation function  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op1_i</span> <span class="pre">op2_j|psi&gt;/&lt;psi|psi&gt;</span></code> of single site operators.</p>
<p>Given the MPS in canonical form, it calculates n-site expectation values.
For examples the contraction for a two-site operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...--</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="n">op2</span>    <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">op1</span>   <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>Onsite terms are taken in the order <code class="docutils literal notranslate"><span class="pre">&lt;psi</span> <span class="pre">|</span> <span class="pre">op1</span> <span class="pre">op2</span> <span class="pre">|</span> <span class="pre">psi&gt;</span></code>.</p>
<p>If <cite>opstr</cite> is given and <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code>, it calculates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>           <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span>                               <span class="k">for</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span>
<span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...-</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---.</span>     <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...-</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">opstr</span>  <span class="n">opstr</span>        <span class="n">op2</span>    <span class="o">|</span>     <span class="o">|</span>     <span class="n">op2</span>    <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">op1</span>    <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="n">opstr</span>  <span class="n">opstr</span>        <span class="n">op1</span>    <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...-</span> <span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--.</span>     <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...-</span> <span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">i==j</span></code>, no <cite>opstr</cite> is included.
For <code class="docutils literal notranslate"><span class="pre">str_on_first=False</span></code>, the <cite>opstr</cite> on site <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">j)</span></code> is always left out.</p>
<p>Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) in the operator lists are translated into single-site
operators defined by the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> on which they act.
Each operator should have the two legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'p*'</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ops1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">First operator of the correlation function (acting after ops2).
<code class="docutils literal notranslate"><span class="pre">ops1[x]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">sites1[x]</span></code>.
If less than <code class="docutils literal notranslate"><span class="pre">len(sites1)</span></code> operators are given, we repeat them periodically.</p>
</dd>
<dt><strong>ops2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">Second operator of the correlation function (acting before ops1).
<code class="docutils literal notranslate"><span class="pre">ops2[y]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">sites2[y]</span></code>.
If less than <code class="docutils literal notranslate"><span class="pre">len(sites2)</span></code> operators are given, we repeat them periodically.</p>
</dd>
<dt><strong>sites1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | int | list of int</span></dt>
<dd><p class="first last">List of site indices; a single <cite>int</cite> is translated to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">sites1)</span></code>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to all sites <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L)</span></code>.
Is sorted before use, i.e. the order is ignored.</p>
</dd>
<dt><strong>sites2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | int | list of int</span></dt>
<dd><p class="first last">List of site indices; a single <cite>int</cite> is translated to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">sites2)</span></code>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to all sites <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L)</span></code>.
Is sorted before use, i.e. the order is ignored.</p>
</dd>
<dt><strong>opstr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">Ignored by default (<code class="docutils literal notranslate"><span class="pre">None</span></code>).
Operator(s) to be inserted between <code class="docutils literal notranslate"><span class="pre">ops1</span></code> and <code class="docutils literal notranslate"><span class="pre">ops2</span></code>.
If given as a list, <code class="docutils literal notranslate"><span class="pre">opstr[r]</span></code> is inserted at site <cite>r</cite> (independent of <cite>sites1</cite> and
<cite>sites2</cite>).</p>
</dd>
<dt><strong>str_on_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the <cite>opstr</cite> is included on the site <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">j)</span></code>.
Note the order, which is chosen that way to handle fermionic Jordan-Wigner strings
correctly. (In other words: choose <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code> for fermions!)</p>
</dd>
<dt><strong>hermitian</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Optimization flag: if <code class="docutils literal notranslate"><span class="pre">sites1</span> <span class="pre">==</span> <span class="pre">sites2</span></code> and <code class="docutils literal notranslate"><span class="pre">Ops1[i]^\dagger</span> <span class="pre">==</span> <span class="pre">Ops2[i]</span></code>
(which is not checked explicitly!), the resulting <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span></code> will be hermitian.
We can use that to avoid calculations, so <code class="docutils literal notranslate"><span class="pre">hermitian=True</span></code> will run faster.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>C</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span></dt>
<dd><p class="first">The correlation function <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">ops1[i]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">i=sites1[x]</span></code> and <code class="docutils literal notranslate"><span class="pre">ops2[j]</span></code> on site <code class="docutils literal notranslate"><span class="pre">j=sites2[y]</span></code>.
If <cite>opstr</cite> is given, it gives (for <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code>):</p>
<ul class="simple">
<li>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">prod_{i</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">j}</span> <span class="pre">opstr[r]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|prod_{j</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">i}</span> <span class="pre">opstr[r]</span> <span class="pre">ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</li>
</ul>
<p class="last">The condition <code class="docutils literal notranslate"><span class="pre">&lt;=</span> <span class="pre">r</span></code> is replaced by a strict <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">r</span></code>, if <code class="docutils literal notranslate"><span class="pre">str_on_first=False</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.correlation_length">
<code class="descname">correlation_length</code><span class="sig-paren">(</span><em>target=1</em>, <em>tol_ev0=1e-08</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.correlation_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation length by diagonalizing the transfer matrix.</p>
<p>Assumes that <cite>self</cite> is in canonical form.</p>
<p>Works only for infinite MPS, where the transfer matrix is a useful concept.
Assuming a single-site unit cell, any correlation function splits into
<span class="math notranslate nohighlight">\(C(A_i, B_j) = A'_i T^{j-i-1} B'_j\)</span>
with some parts left and right and the <span class="math notranslate nohighlight">\(j-i-1\)</span>-th power of the transfer matrix in
between. The largest eigenvalue is 1 (if self is properly normalized)
and gives the dominant contribution of
<span class="math notranslate nohighlight">\(A'_i E_1 * 1^{j-i-1} * E_1^T B'_j = &lt;A&gt; &lt;B&gt;\)</span>,
and the second largest one gives a contribution <span class="math notranslate nohighlight">\(\propto \lambda_2^{j-i-1}\)</span>.
Thus <span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{1}{\xi})\)</span>.</p>
<p>More general for a <cite>L</cite>-site unit cell we get <span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{L}{\xi})\)</span>,
where the <cite>xi</cite> is given in units of 1 lattice spacing in the MPS.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For a higher-dimensional lattice (which the MPS class doesn’t know about),
the correct unit is the lattice spacing in x-direction, and the correct formula is
<span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{L_x}{\xi})\)</span>,
where <cite>L_x</cite> is the number of lattice spacings in the infinite direction within the
MPS unit cell, e.g. the number of “rings” of a cylinder in the MPS unit cell.
To get to these units, divide the returned <cite>xi</cite> by the number of sites within a “ring”,
for a lattice given in <code class="xref py py-attr docutils literal notranslate"><span class="pre">N_sites_per_ring</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">We look for the <cite>target</cite> + 1 largest eigenvalues.</p>
</dd>
<dt><strong>tol_ev0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Print warning if largest eigenvalue deviates from 1 by more than <cite>tol_ev0</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>xi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | 1D array</span></dt>
<dd><p class="first last">If <cite>target`=1, return just the correlation length,
otherwise an array of the `target</cite> largest correlation lengths.
It is measured in units of a single lattice spacing in the MPS language,
see the warning above.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.dim">
<code class="descname">dim</code><a class="headerlink" href="#tenpy.networks.mps.MPS.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>List of local physical dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.entanglement_entropy">
<code class="descname">entanglement_entropy</code><span class="sig-paren">(</span><em>n=1</em>, <em>bonds=None</em>, <em>for_matrix_S=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.entanglement_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.entanglement_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</p>
<p>Consider a bipartition of the sytem into <span class="math notranslate nohighlight">\(A = \{ j: j &lt;= i_b \}\)</span> and
<span class="math notranslate nohighlight">\(B = \{ j: j &gt; i_b\}\)</span> and the reduced density matrix <span class="math notranslate nohighlight">\(\rho_A = tr_B(\rho)\)</span>.
The von-Neumann entanglement entropy is defined as
<span class="math notranslate nohighlight">\(S(A, n=1) = -tr(\rho_A \log(\rho_A)) = S(B, n=1)\)</span>.
The generalization for <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">!=</span> <span class="pre">1,</span> <span class="pre">n&gt;0</span></code> are the Renyi entropies:
<span class="math notranslate nohighlight">\(S(A, n) = \frac{1}{1-n} \log(tr(\rho_A^2)) = S(B, n=1)\)</span></p>
<p>This function calculates the entropy for a cut at different bonds <cite>i</cite>, for which the
the eigenvalues of the reduced density matrix <span class="math notranslate nohighlight">\(\rho_A\)</span> and <span class="math notranslate nohighlight">\(\rho_B\)</span> is given
by the squared schmidt values <cite>S</cite> of the bond.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/float</span></dt>
<dd><p class="first last">Selects which entropy to calculate;
<cite>n=1</cite> (default) is the ususal von-Neumann entanglement entropy.</p>
</dd>
<dt><strong>bonds</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | (iterable of) int</span></dt>
<dd><p class="first last">Selects the bonds at which the entropy should be calculated.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L+1)[self.nontrivial_bonds]</span></code>.</p>
</dd>
<dt><strong>for_matrix_S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Switch calculate the entanglement entropy even if the <cite>_S</cite> are matrices.
Since <span class="math notranslate nohighlight">\(O(\chi^3)\)</span> is expensive compared to the ususal <span class="math notranslate nohighlight">\(O(\chi)\)</span>,
we raise an error by default.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>entropies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">Entanglement entropies for half-cuts.
<cite>entropies[j]</cite> contains the entropy for a cut at bond <code class="docutils literal notranslate"><span class="pre">bonds[j]</span></code>
(i.e. left to site <code class="docutils literal notranslate"><span class="pre">bonds[j]</span></code>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.entanglement_entropy_segment">
<code class="descname">entanglement_entropy_segment</code><span class="sig-paren">(</span><em>segment=[0], first_site=None, n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.entanglement_entropy_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.entanglement_entropy_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate entanglement entropy for general geometry of the bipartition.</p>
<p>This function is similar as <a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_entropy" title="tenpy.networks.mps.MPS.entanglement_entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">entanglement_entropy()</span></code></a>,
but for more general geometry of the region <cite>A</cite> to be a segment of a <em>few</em> sites.</p>
<p>This is acchieved by explicitly calculating the reduced density matrix of <cite>A</cite>
and thus works only for small segments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>segment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">Given a first site <cite>i</cite>, the region <code class="docutils literal notranslate"><span class="pre">A_i</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">[i+j</span> <span class="pre">for</span> <span class="pre">j</span> <span class="pre">in</span> <span class="pre">segment]</span></code>.</p>
</dd>
<dt><strong>first_site</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | (iterable of) int</span></dt>
<dd><p class="first last">Calculate the entropy for segments starting at these sites.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">range(L-segment[-1])</span></code> for finite
or <cite>range(L)</cite> for infinite boundary conditions.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | float</span></dt>
<dd><p class="first last">Selects which entropy to calculate;
<cite>n=1</cite> (default) is the ususal von-Neumann entanglement entropy,
otherwise the <cite>n</cite>-th Renyi entropy.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>entropies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">entropies[i]</span></code> contains the entropy for the the region <code class="docutils literal notranslate"><span class="pre">A_i</span></code> defined above.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.entanglement_spectrum">
<code class="descname">entanglement_spectrum</code><span class="sig-paren">(</span><em>by_charge=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.entanglement_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.entanglement_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>return entanglement energy spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>by_charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter we should sort the spectrum on each bond by the possible charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ent_spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">For each (non-trivial) bond the entanglement spectrum.
If <cite>by_charge</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, return (for each bond) a sorted 1D ndarray
with the convention <span class="math notranslate nohighlight">\(S_i^2 = e^{-\xi_i}\)</span>, where <span class="math notranslate nohighlight">\(S_i\)</span> labels a Schmidt value
and <span class="math notranslate nohighlight">\(\xi_i\)</span> labels the entanglement ‘energy’ in the returned spectrum.
If <cite>by_charge</cite> is True, return a a list of tuples <code class="docutils literal notranslate"><span class="pre">(charge,</span> <span class="pre">sub_spectrum)</span></code>
for each possible charge on that bond.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value">
<code class="descname">expectation_value</code><span class="sig-paren">(</span><em>ops</em>, <em>sites=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;</span></code> of (n-site) operator(s).</p>
<p>Given the MPS in canonical form, it calculates n-site expectation values.
For example the contraction for a two-site (<cite>n</cite> = 2) operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span> <span class="n">op</span>  <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">The operators, for wich the expectation value should be taken,
All operators should all have the same number of legs (namely <cite>2 n</cite>).
If less than <cite>self.L</cite> operators are given, we repeat them periodically.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of int</span></dt>
<dd><p class="first last">List of site indices. Expectation values are evaluated there.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the entire chain is taken (clipping for finite b.c.)</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (list of str, list of str)</span></dt>
<dd><p class="first last">Two lists of each <cite>n</cite> leg labels giving the physical legs of the operator used for
contraction. The first <cite>n</cite> legs are contracted with conjugated <cite>B</cite>,
the second <cite>n</cite> legs with the non-conjugated <cite>B</cite>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">(['p'],</span> <span class="pre">['p*'])</span></code> for single site operators (<cite>n</cite> = 1), or
<code class="docutils literal notranslate"><span class="pre">(['p0',</span> <span class="pre">'p1',</span> <span class="pre">...</span> <span class="pre">'p{n-1}'],</span> <span class="pre">['p0*',</span> <span class="pre">'p1*',</span> <span class="pre">....</span> <span class="pre">'p{n-1}*'])</span></code> for <cite>n</cite> &gt; 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">Expectation values, <code class="docutils literal notranslate"><span class="pre">exp_vals[i]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops[i]|psi&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">ops[i]</span></code> acts on
site(s) <code class="docutils literal notranslate"><span class="pre">j,</span> <span class="pre">j+1,</span> <span class="pre">...,</span> <span class="pre">j+{n-1}</span></code> with <code class="docutils literal notranslate"><span class="pre">j=sites[i]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>One site examples (n=1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="go">[Sz0, Sz1, ..., Sz{L-1}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Sx&#39;</span><span class="p">])</span>
<span class="go">[Sz0, Sx1, Sz2, Sx3, ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[Sz0, Sz3, Sz4]</span>
</pre></div>
</div>
<p>Two site example (n=2), assuming homogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                     psi.sites[1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx</span><span class="p">)</span>
<span class="go">[Sz0Sx1, Sz1Sx2, Sz2Sx3, ... ]   # with len L-1 for finite bc, or L for infinite</span>
</pre></div>
</div>
<p>Example measuring &lt;psi|SzSx|psi2&gt; on each second site, for inhomogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                           psi.sites[i+1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="go">                 for i in range(0, psi.L-1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx_list</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[Sz0Sx1, Sz2Sx3, Sz4Sx5, ...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value_multi_sites">
<code class="descname">expectation_value_multi_sites</code><span class="sig-paren">(</span><em>operators</em>, <em>i0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value_multi_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value_multi_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p>
<p>Calculates the expectation value of a tensor product of single-site operators
acting on different sites next to each other.
In other works, evaluate the expectation value of a term
<code class="docutils literal notranslate"><span class="pre">op0_i0</span> <span class="pre">op1_{i0+1}</span> <span class="pre">op2_{i0+2}</span> <span class="pre">...</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>operators</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of { <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">List of one-site operators. This method calculates the
expectation value of the n-sites operator given by their tensor
product.</p>
</dd>
<dt><strong>i0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The left most index on which an operator acts, i.e.,
<code class="docutils literal notranslate"><span class="pre">operators[i]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">i0</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">The expectation value of the tensorproduct of the given onsite operators,
<code class="docutils literal notranslate"><span class="pre">&lt;psi|operators[0]_{i0}</span> <span class="pre">operators[1]_{i0+1}</span> <span class="pre">...</span> <span class="pre">|psi&gt;/&lt;psi|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> is the represented MPS.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value_term">
<code class="descname">expectation_value_term</code><span class="sig-paren">(</span><em>term</em>, <em>autoJW=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p>
<p>Calculates the expectation value of a tensor product of single-site operators
acting on different sites <cite>i0</cite>, <cite>i1</cite>, … (not necessarily next to each other).
In other words, evaluate the expectation value of a term <code class="docutils literal notranslate"><span class="pre">op0_i0</span> <span class="pre">op1_i1</span> <span class="pre">op2_i2</span> <span class="pre">...</span></code>.</p>
<p>For example the contraction of three one-site operators on sites <cite>i0</cite>,
<cite>i1=i0+1</cite>, <cite>i2=i0+3</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>    <span class="n">op1</span>     <span class="n">op2</span>       <span class="o">|</span>       <span class="n">op3</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>term</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (str, int)</span></dt>
<dd><p class="first last">List of tuples <code class="docutils literal notranslate"><span class="pre">op,</span> <span class="pre">i</span></code> where <cite>i</cite> is the MPS index of the site the operator
named <cite>op</cite> acts on.
The order inside <cite>term</cite> determines the order in which they act
(in the mathematical convention: the last operator in <cite>term</cite> is right-most,
so it acts first on a Ket).</p>
</dd>
<dt><strong>autoJW</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True (default), automatically insert Jordan Wigner strings for Fermions as needed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">The expectation value of the tensorproduct of the given onsite operators,
<code class="docutils literal notranslate"><span class="pre">&lt;psi|op_i0</span> <span class="pre">op_i1</span> <span class="pre">...</span> <span class="pre">op_iN</span> <span class="pre">|psi&gt;/&lt;psi|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> is the represented MPS.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">([(</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">([(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_multi_sites</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">],</span> <span class="n">i0</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value_terms_sum">
<code class="descname">expectation_value_terms_sum</code><span class="sig-paren">(</span><em>term_list</em>, <em>prefactors</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value_terms_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value_terms_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate expectation values for a bunch of terms and sum them up.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>term_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of terms</span></dt>
<dd><p class="first last">Each <cite>term</cite> should have the form <code class="docutils literal notranslate"><span class="pre">[(Op1,</span> <span class="pre">site1),</span> <span class="pre">(Op2,</span> <span class="pre">site2),</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt><strong>prefactors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (complex) floats</span></dt>
<dd><p class="first last">Prefactors for the <code class="docutils literal notranslate"><span class="pre">total_sum</span></code> to be evaluated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>terms_sum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (complex) float</span></dt>
<dd><p class="first last">Equivalent to <code class="docutils literal notranslate"><span class="pre">sum([t*f</span> <span class="pre">for</span> <span class="pre">t,</span> <span class="pre">f</span> <span class="pre">in</span> <span class="pre">zip(terms,</span> <span class="pre">prefactors)])</span></code>.</p>
</dd>
<dt><strong>cache :</strong></dt>
<dd><p class="first last">Intermediate results. Currently the values for each of the term, but this might be
changed soon.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_term" title="tenpy.networks.mps.MPS.expectation_value_term"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expectation_value_term()</span></code></a></dt>
<dd>evaluates a single <cite>term</cite>.</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.finite">
<code class="descname">finite</code><a class="headerlink" href="#tenpy.networks.mps.MPS.finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Distinguish MPS (<code class="docutils literal notranslate"><span class="pre">True;</span> <span class="pre">bc='finite',</span> <span class="pre">'segment'</span></code> ) vs. iMPS (<code class="docutils literal notranslate"><span class="pre">False;</span> <span class="pre">bc='infinite'</span></code>)</p>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_Bflat">
<em class="property">classmethod </em><code class="descname">from_Bflat</code><span class="sig-paren">(</span><em>sites</em>, <em>Bflat</em>, <em>SVs=None</em>, <em>bc='finite'</em>, <em>dtype=None</em>, <em>permute=True</em>, <em>form='B'</em>, <em>legL=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_Bflat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_Bflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix product state from a set of numpy arrays <cite>Bflat</cite> and singular vals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>Bflat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of numpy ndarrays</span></dt>
<dd><p class="first last">The matrix defining the MPS on each site, with legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'vL',</span> <span class="pre">'vR'</span></code>
(physical, virtual left/right).</p>
</dd>
<dt><strong>SVs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D array | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">The singular values on <em>each</em> bond. Should always have length <cite>L+1</cite>.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), set all singular values to the same value.
Entries out of <a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a> are ignored.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt>
<dd><p class="first last">MPS boundary conditions. See docstring of <a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type or string</span></dt>
<dd><p class="first last">The data type of the array entries. Defaults to the common dtype of <cite>Bflat</cite>.</p>
</dd>
<dt><strong>permute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">The <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> might permute the local basis states if charge
conservation gets enabled.
If <cite>permute</cite> is True (default), we permute the given <cite>Bflat</cite> locally according to
each site’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">perm</span></code>.
The <cite>p_state</cite> argument should then always be given as if <cite>conserve=None</cite> in the Site.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">Defines the canonical form of <cite>Bflat</cite>. See module doc-string.
A single choice holds for all of the entries.</p>
</dd>
<dt><strong>leg_L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">LegCharge | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">Leg charges at bond 0, which are purely conventional.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use trivial charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">An MPS with the matrices <cite>Bflat</cite> converted to npc arrays.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_full">
<em class="property">classmethod </em><code class="descname">from_full</code><span class="sig-paren">(</span><em>sites</em>, <em>psi</em>, <em>form='B'</em>, <em>cutoff=1e-16</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an MPS from a single tensor <cite>psi</cite> with one leg per physical site.</p>
<p>Performs a sequence of SVDs of psi to split off the <cite>B</cite> matrices and obtain the singular
values, the result will be in canonical form.
Obviously, this is only well-defined for <cite>finite</cite> boundary conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>psi</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The full wave function to be represented as an MPS.
Should have labels <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1',</span> <span class="pre">...,</span>&#160; <span class="pre">'p{L-1}'</span></code>.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span></code></span></dt>
<dd><p class="first last">The canonical form of the resulting MPS, see module doc-string.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Cutoff of singular values used in the SVDs.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the resulting MPS should have ‘norm’ 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>psi_mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">MPS representation of <cite>psi</cite>, in canonical form and possibly normalized.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_product_state">
<em class="property">classmethod </em><code class="descname">from_product_state</code><span class="sig-paren">(</span><em>sites</em>, <em>p_state</em>, <em>bc='finite'</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>permute=True</em>, <em>form='B'</em>, <em>chargeL=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_product_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_product_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix product state from a given product state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>p_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of {int | str | 1D array}</span></dt>
<dd><p class="first last">Defines the product state to be represented.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is str, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> is in state
<code class="docutils literal notranslate"><span class="pre">self.sites[i].state_labels(p_state[i])</span></code>.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is int, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> is in state <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code>.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is an array, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> wavefunction is <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code>.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt>
<dd><p class="first last">MPS boundary conditions. See docstring of <a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type or string</span></dt>
<dd><p class="first last">The data type of the array entries.</p>
</dd>
<dt><strong>permute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">The <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> might permute the local basis states if charge
conservation gets enabled.
If <cite>permute</cite> is True (default), we permute the given <cite>p_state</cite> locally according to
each site’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">perm</span></code>.
The <cite>p_state</cite> argument should then always be given as if <cite>conserve=None</cite> in the Site.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">Defines the canonical form. See module doc-string.
A single choice holds for all of the entries.</p>
</dd>
<dt><strong>chargeL</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last">Leg charge at bond 0, which are purely conventional.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>product_mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">An MPS representing the specified product state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>To get a Neel state:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">SpinChain</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_state</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># repeats entries L/2 times</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">MPS</span><span class="o">.</span><span class="n">from_product_state</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">(),</span> <span class="n">p_state</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span><span class="p">)</span>
</pre></div>
</div>
<p>For Spin S=1/2, you could get a state with all sites pointing in negative x-direction with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">neg_x_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">neg_x_state</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">neg_x_state</span><span class="p">)]</span><span class="o">*</span><span class="n">L</span>  <span class="c1"># other parameters as above</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_singlets">
<em class="property">classmethod </em><code class="descname">from_singlets</code><span class="sig-paren">(</span><em>site</em>, <em>L</em>, <em>pairs</em>, <em>up='up'</em>, <em>down='down'</em>, <em>lonely=[]</em>, <em>lonely_state=0</em>, <em>bc='finite'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_singlets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_singlets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an MPS of entangled singlets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>site</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The <cite>site</cite> defining the local Hilbert space, taken uniformly for all sites.</p>
</dd>
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of sites.</p>
</dd>
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (int, int)</span></dt>
<dd><p class="first last">Pairs of sites to be entangled; the returned MPS will have a singlet
for each pair in <cite>pairs</cite>.</p>
</dd>
<dt><strong>up, down</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">A singlet is defined as <code class="docutils literal notranslate"><span class="pre">(|up</span> <span class="pre">down&gt;</span> <span class="pre">-</span> <span class="pre">|down</span> <span class="pre">up&gt;)/2**0.5</span></code>,
<code class="docutils literal notranslate"><span class="pre">up</span></code> and <code class="docutils literal notranslate"><span class="pre">down</span></code> give state indices or labels defined on the corresponding site.</p>
</dd>
<dt><strong>lonely</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">Sites which are not included into a singlet pair.</p>
</dd>
<dt><strong>lonely_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">The state for the lonely sites.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt>
<dd><p class="first last">MPS boundary conditions. See docstring of <a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>singlet_mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">An MPS representing singlets on the specified bonds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.gauge_total_charge">
<code class="descname">gauge_total_charge</code><span class="sig-paren">(</span><em>qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.gauge_total_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.gauge_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Gauge the legcharges of the virtual bonds such that the MPS has a total <cite>qtotal</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) charges</span></dt>
<dd><p class="first last">If a single <cite>qtotal</cite> is given, it is the desired total charge of the MPS
(which <a class="reference internal" href="#tenpy.networks.mps.MPS.get_total_charge" title="tenpy.networks.mps.MPS.get_total_charge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_total_charge()</span></code></a> will return afterwards).
Alternatively, the desired <cite>qtotal</cite> for each of the individual <cite>B</cite> tensors can be
specified.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><em>i</em>, <em>form='B'</em>, <em>copy=False</em>, <em>cutoff=1e-16</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (view of) <cite>B</cite> at site <cite>i</cite> in canonical form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index choosing the site.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt>
<dd><p class="first last">The (canonical) form of the returned B.
For <code class="docutils literal notranslate"><span class="pre">None</span></code>, return the matrix in whatever form it is.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to return a copy even if <cite>form</cite> matches the current form.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">During DMRG with a mixer, <cite>S</cite> may be a matrix for which we need the inverse.
This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
singular values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The MPS ‘matrix’ <cite>B</cite> at site <cite>i</cite> with leg labels <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p</span></code> (in undefined order).
May be a view of the matrix (if <code class="docutils literal notranslate"><span class="pre">copy=False</span></code>),
or a copy (if the form changed or <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if self is not in canoncial form and <code class="docutils literal notranslate"><span class="pre">form</span> <span class="pre">!=</span> <span class="pre">None</span></code>.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_SL">
<code class="descname">get_SL</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_SL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_SL" title="Permalink to this definition">¶</a></dt>
<dd><p>Return singular values on the left of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_SR">
<code class="descname">get_SR</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_SR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_SR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return singular values on the right of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_grouped_mps">
<code class="descname">get_grouped_mps</code><span class="sig-paren">(</span><em>blocklen</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_grouped_mps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_grouped_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>contract blocklen subsequent tensors into a single one and return result as a new MPS.</p>
<p>blocklen = number of subsequent sites to be combined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new MPS object with bunched sites.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_op">
<code class="descname">get_op</code><span class="sig-paren">(</span><em>op_list</em>, <em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of operators, select the one corresponding to site <cite>i</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>op_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {str | npc.array}</span></dt>
<dd><p class="first last">List of operators from which we choose. We assume that <code class="docutils literal notranslate"><span class="pre">op_list[j]</span></code> acts on site
<code class="docutils literal notranslate"><span class="pre">j</span></code>. If the length is shorter than <cite>L</cite>, we repeat it periodically.
Strings are translated using <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.get_op" title="tenpy.networks.site.Site.get_op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_op()</span></code></a> of site <cite>i</cite>.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index of the site on which the operator acts.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">npc.array</span></dt>
<dd><p class="first last">One of the entries in <cite>op_list</cite>, not copied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_rho_segment">
<code class="descname">get_rho_segment</code><span class="sig-paren">(</span><em>segment</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_rho_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_rho_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reduced density matrix for a segment.</p>
<p>Note that the dimension of rho_A scales exponentially in the length of the segment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>segment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Sites for which the reduced density matrix is to be calculated.
Assumed to be sorted.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Reduced density matrix of the segment sites.
Labels <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1',</span> <span class="pre">...,</span> <span class="pre">'pk',</span> <span class="pre">'p0*',</span> <span class="pre">'p1*',</span> <span class="pre">...,</span> <span class="pre">'pk*'</span></code> with <code class="docutils literal notranslate"><span class="pre">k=len(segment)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_theta">
<code class="descname">get_theta</code><span class="sig-paren">(</span><em>i</em>, <em>n=2</em>, <em>cutoff=1e-16</em>, <em>formL=1.0</em>, <em>formR=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_theta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>n</cite>-site wavefunction on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Site index.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites. The result lives on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">During DMRG with a mixer, <cite>S</cite> may be a matrix for which we need the inverse.
This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
singular values.</p>
</dd>
<dt><strong>formL</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Exponent for the singular values to the left.</p>
</dd>
<dt><strong>formR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Exponent for the singular values to the right.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The n-site wave function with leg labels <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p0,</span> <span class="pre">p1,</span> <span class="pre">....</span> <span class="pre">p{n-1}</span></code>
(in undefined order).
In Vidal’s notation (with s=lambda, G=Gamma):
<code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">=</span> <span class="pre">s**form_L</span> <span class="pre">G_i</span> <span class="pre">s</span> <span class="pre">G_{i+1}</span> <span class="pre">s</span> <span class="pre">...</span> <span class="pre">G_{i+n-1}</span> <span class="pre">s**form_R</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_total_charge">
<code class="descname">get_total_charge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_total_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and return the <cite>qtotal</cite> of the whole MPS (when contracted).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last">The sum of the <cite>qtotal</cite> of the individual <cite>B</cite> tensors.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.group_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> inplace to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.group_split" title="tenpy.networks.mps.MPS.group_split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group_split()</span></code></a></dt>
<dd>Reverts the grouping.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.group_split">
<code class="descname">group_split</code><span class="sig-paren">(</span><em>trunc_par={}</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.group_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.group_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> inplace to split previously grouped sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error introduced by the truncation for the splitting.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.group_sites" title="tenpy.networks.mps.MPS.group_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group_sites()</span></code></a></dt>
<dd>Should have been used before to combine sites.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.mutinf_two_site">
<code class="descname">mutinf_two_site</code><span class="sig-paren">(</span><em>max_range=None</em>, <em>n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.mutinf_two_site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.mutinf_two_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-site mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span>.</p>
<p>Calculates <span class="math notranslate nohighlight">\(I(i:j) = S(i) + S(j) - S(i,j)\)</span>,
where <span class="math notranslate nohighlight">\(S(i)\)</span> is the single site entropy on site <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(S(i,j)\)</span> the two-site entropy on sites <span class="math notranslate nohighlight">\(i,j\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>max_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximal distance <code class="docutils literal notranslate"><span class="pre">|i-j|</span></code> for which the mutual information should be calculated.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <cite>L-1</cite>.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Selects the entropy to use, see <a class="reference internal" href="tenpy.tools.math.html#tenpy.tools.math.entropy" title="tenpy.tools.math.entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Coordinates for the mutinf array.</p>
</dd>
<dt><strong>mutinf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">mutinf[k]</span></code> is the mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span> between the
sites <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">coords[k]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.nontrivial_bonds">
<code class="descname">nontrivial_bonds</code><a class="headerlink" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice of the non-trivial bond indices, depending on <code class="docutils literal notranslate"><span class="pre">self.bc</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.norm_test">
<code class="descname">norm_test</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.norm_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.norm_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that self is in canonical form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>norm_error: array, shape (L, 2)</strong></dt>
<dd><p class="first">For each site the norm error to the left and right.
The error <code class="docutils literal notranslate"><span class="pre">norm_error[i,</span> <span class="pre">0]</span></code> is defined as the norm-difference between
the following networks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">--</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---.</span>       <span class="o">--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>    <span class="n">vs</span>         <span class="o">|</span>
<span class="o">|</span>   <span class="o">--</span><span class="n">theta</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>       <span class="o">--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">norm_errror[i,</span> <span class="pre">1]</span></code> is the norm-difference of:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">.--</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span>         <span class="o">.--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span>
<span class="o">|</span>   <span class="o">|</span>    <span class="o">|</span>          <span class="n">vs</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="o">.--</span><span class="n">theta</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span>         <span class="o">.--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span>
</pre></div>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.overlap">
<code class="descname">overlap</code><span class="sig-paren">(</span><em>other</em>, <em>charge_sector=0</em>, <em>ignore_form=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute overlap <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">An MPS with the same physical sites.</p>
</dd>
<dt><strong>charge_sector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | charges | <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt>
<dd><p class="first last">Selects the charge sector in which the dominant eigenvector of the TransferMatrix is.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for <em>all</em> sectors, <code class="docutils literal notranslate"><span class="pre">0</span></code> stands for the zero-charge sector.
Defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>, i.e., <em>assumes</em> the dominant eigenvector is in charge sector 0.</p>
</dd>
<dt><strong>ignore_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), take into account the canonical form <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> at each site.
If <code class="docutils literal notranslate"><span class="pre">True</span></code>, we ignore the canonical form (i.e., whether the MPS is in left, right,
mixed or no canonical form) and just contract all the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_B</span></code> as they are.
(This can give different results!)</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Further keyword arguments given to <a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.eigenvectors" title="tenpy.networks.mps.TransferMatrix.eigenvectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TransferMatrix.eigenvectors()</span></code></a>;
only used for infinite boundary conditions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd><p class="first last">The contraction <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span> <span class="pre">*</span> <span class="pre">self.norm</span> <span class="pre">*</span> <span class="pre">other.norm</span></code>
(i.e., taking into account the <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code> of both MPS).
For an infinite MPS, <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code> is the overlap per unit cell, i.e.,
the largest eigenvalue of the TransferMatrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.permute_sites">
<code class="descname">permute_sites</code><span class="sig-paren">(</span><em>perm</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.permute_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.permute_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the permutation perm to the state (inplace).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray[ndim=1, int]</span></dt>
<dd><p class="first last">The applied permutation, such that <code class="docutils literal notranslate"><span class="pre">psi.permute_sites(perm)[i]</span> <span class="pre">=</span> <span class="pre">psi[perm[i]]</span></code>
(where <code class="docutils literal notranslate"><span class="pre">[i]</span></code> indicates the <cite>i</cite>-th site).</p>
</dd>
<dt><strong>swap_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The operator used to swap the phyiscal legs of a two-site wave function <cite>theta</cite>,
see <a class="reference internal" href="#tenpy.networks.mps.MPS.swap_sites" title="tenpy.networks.mps.MPS.swap_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swap_sites()</span></code></a>.</p>
</dd>
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Level of verbosity, print status messages if verbose &gt; 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error of the represented state introduced by the truncation after the swaps.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.probability_per_charge">
<code class="descname">probability_per_charge</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.probability_per_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.probability_per_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return probabilites of charge value on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
This function returns the possible values of <cite>N_b</cite> as rows of <cite>charge_values</cite>,
and for each row the probabilty that this combination occurs in the given state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The bond to be considered. The returned charges are summed on the left of this bond.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>charge_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Columns correspond to the different charges in <cite>self.chinfo</cite>.
Rows are the different charge fluctuations at this bond</p>
</dd>
<dt><strong>probabilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">For each row of <cite>charge_values</cite> the probablity for these values of charge fluctuations.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.set_B">
<code class="descname">set_B</code><span class="sig-paren">(</span><em>i</em>, <em>B</em>, <em>form='B'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.set_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.set_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <cite>B</cite> at site <cite>i</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index choosing the site.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The ‘matrix’ at site <cite>i</cite>. Should have leg labels <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p</span></code> (in any order).</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt>
<dd><p class="first last">The (canonical) form of the <cite>B</cite> to set.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for non-canonical form.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.set_SL">
<code class="descname">set_SL</code><span class="sig-paren">(</span><em>i</em>, <em>S</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.set_SL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.set_SL" title="Permalink to this definition">¶</a></dt>
<dd><p>Set singular values on the left of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.set_SR">
<code class="descname">set_SR</code><span class="sig-paren">(</span><em>i</em>, <em>S</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.set_SR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.set_SR" title="Permalink to this definition">¶</a></dt>
<dd><p>Set singular values on the right of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.swap_sites">
<code class="descname">swap_sites</code><span class="sig-paren">(</span><em>i</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.swap_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.swap_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the two neighboring sites <cite>i</cite> and <cite>i+1</cite> (inplace).</p>
<p>Exchange two neighboring sites: form theta, ‘swap’ the physical legs and split
with an svd. While the ‘swap’ is just a transposition/relabeling for bosons, one needs to
be careful about the sign for fermions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Swap the two sites at positions <cite>i</cite> and <cite>i+1</cite>.</p>
</dd>
<dt><strong>swap_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The operator used to swap the phyiscal legs of the two-site wave function <cite>theta</cite>.
For <code class="docutils literal notranslate"><span class="pre">None</span></code>, just transpose/relabel the legs, for <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> also take care of
fermionic signs. Alternative give an npc <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>
which represents the full operator used for the swap.
Should have legs <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p1',</span> <span class="pre">'p0*',</span> <span class="pre">'p1*']</span></code> whith <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1*'</span></code> contractible.</p>
</dd>
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error of the represented state introduced by the truncation after the swap.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises Errors if something is wrong.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.networks.mps.MPSEnvironment">
<em class="property">class </em><code class="descclassname">tenpy.networks.mps.</code><code class="descname">MPSEnvironment</code><span class="sig-paren">(</span><em>bra</em>, <em>ket</em>, <em>firstLP=None</em>, <em>lastRP=None</em>, <em>age_LP=0</em>, <em>age_RP=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Stores partial contractions of <span class="math notranslate nohighlight">\(&lt;bra|Op|ket&gt;\)</span> for local operators <cite>Op</cite>.</p>
<p>The network for a contraction <span class="math notranslate nohighlight">\(&lt;bra|Op|ket&gt;\)</span> of a local operator <cite>Op</cite>, say exemplary
at sites <cite>i, i+1</cite> looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>     <span class="o">.-----</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">---</span> <span class="o">...</span> <span class="o">--</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">---</span><span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">---</span> <span class="o">...</span> <span class="o">-&gt;--.</span>
<span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>             <span class="o">|</span>      <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>             <span class="o">|------|</span>               <span class="o">|</span>
<span class="o">|</span>     <span class="n">LP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span>             <span class="o">|</span>  <span class="n">Op</span>  <span class="o">|</span>               <span class="n">RP</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>             <span class="o">|------|</span>               <span class="o">|</span>
<span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>             <span class="o">|</span>      <span class="o">|</span>               <span class="o">|</span>
<span class="o">|</span>     <span class="o">.-----</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*--</span> <span class="o">...</span> <span class="o">--</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*--</span><span class="n">N</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*--</span> <span class="o">...</span> <span class="o">-&lt;--.</span>
</pre></div>
</div>
<p>Of course, we can also calculate the overlap <cite>&lt;bra|ket&gt;</cite> by using the special case <code class="docutils literal notranslate"><span class="pre">Op</span> <span class="pre">=</span> <span class="pre">Id</span></code>.</p>
<p>We use the following label convention (where arrows indicate <cite>qconj</cite>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="o">.--&gt;-</span> <span class="n">vR</span>           <span class="n">vL</span> <span class="o">-&gt;-.</span>
<span class="o">|</span>    <span class="o">|</span>                        <span class="o">|</span>
<span class="o">|</span>    <span class="n">LP</span>                       <span class="n">RP</span>
<span class="o">|</span>    <span class="o">|</span>                        <span class="o">|</span>
<span class="o">|</span>    <span class="o">.--&lt;-</span> <span class="n">vR</span><span class="o">*</span>         <span class="n">vL</span><span class="o">*</span> <span class="o">-&lt;-.</span>
</pre></div>
</div>
<p>To avoid recalculations of the whole network e.g. in the DMRG sweeps,
we store the contractions up to some site index in this class.
For <code class="docutils literal notranslate"><span class="pre">bc='finite','segment'</span></code>, the very left and right part <code class="docutils literal notranslate"><span class="pre">LP[0]</span></code> and
<code class="docutils literal notranslate"><span class="pre">RP[-1]</span></code> are trivial and don’t change,
but for <code class="docutils literal notranslate"><span class="pre">bc='infinite'</span></code> they are might be updated
(by inserting another unit cell to the left/right).</p>
<p>The MPS <cite>bra</cite> and <cite>ket</cite> have to be in canonical form.
All the environments are constructed without the singular values on the open bond.
In other words, we contract left-canonical <cite>A</cite> to the left parts <cite>LP</cite>
and right-canonical <cite>B</cite> to the right parts <cite>RP</cite>.
Thus, the special case <code class="docutils literal notranslate"><span class="pre">ket=bra</span></code> should yield identity matrices for <cite>LP</cite> and <cite>RP</cite>.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Initial firstLP and first_RP could be calculated with the TransferMatrix. Usefull?</p>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">Doesn’t work for different qtotal in ket._B / bra._B -&gt; Need MPS.gauge_qtotal()
Or just define firstLP and firstRP to have nonzero qtotal in this case…</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">The MPS to project on. Should be given in usual ‘ket’ form;
we call <cite>conj()</cite> on the matrices directly.</p>
</dd>
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">The MPS on which the local operator acts.</p>
</dd>
<dt><strong>firstLP</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Initial very left part. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, build trivial one.</p>
</dd>
<dt><strong>rightRP</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Initial very right part. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, build trivial one.</p>
</dd>
<dt><strong>age_LP</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of physical sites involved into the contraction yielding <cite>firstLP</cite>.</p>
</dd>
<dt><strong>age_RP</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of physical sites involved into the contraction yielding <cite>lastRP</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of physical sites. For iMPS the len of the MPS unit cell.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type | string</span></dt>
<dd><p class="first last">The data type of the Array entries.</p>
</dd>
<dt><strong>bra, ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">The two MPS for the contraction.</p>
</dd>
<dt><strong>_LP</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of {<code class="docutils literal notranslate"><span class="pre">None</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>}</span></dt>
<dd><p class="first last">Left parts of the environment, len <cite>L</cite>.
<code class="docutils literal notranslate"><span class="pre">LP[i]</span></code> contains the contraction strictly left of site <cite>i</cite>
(or <code class="docutils literal notranslate"><span class="pre">None</span></code>, if we don’t have it calculated).</p>
</dd>
<dt><strong>_RP</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of {<code class="docutils literal notranslate"><span class="pre">None</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>}</span></dt>
<dd><p class="first last">Right parts of the environment, len <cite>L</cite>.
<code class="docutils literal notranslate"><span class="pre">RP[i]</span></code> contains the contraction strictly right of site <cite>i</cite>
(or <code class="docutils literal notranslate"><span class="pre">None</span></code>, if we don’t have it calculated).</p>
</dd>
<dt><strong>_LP_age</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">Used for book-keeping, how large the DMRG system grew:
<code class="docutils literal notranslate"><span class="pre">_LP_age[i]</span></code> stores the number of physical sites invovled into the contraction
network which yields <code class="docutils literal notranslate"><span class="pre">self._LP[i]</span></code>.</p>
</dd>
<dt><strong>_RP_age</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">Used for book-keeping, how large the DMRG system grew:
<code class="docutils literal notranslate"><span class="pre">_RP_age[i]</span></code> stores the number of physical sites invovled into the contraction
network which yields <code class="docutils literal notranslate"><span class="pre">self._RP[i]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.del_LP" title="tenpy.networks.mps.MPSEnvironment.del_LP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">del_LP</span></code></a>(i)</td>
<td>Delete stored part strictly to the left of site <cite>i</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.del_RP" title="tenpy.networks.mps.MPSEnvironment.del_RP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">del_RP</span></code></a>(i)</td>
<td>Delete storde part scrictly to the right of site <cite>i</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.expectation_value" title="tenpy.networks.mps.MPSEnvironment.expectation_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value</span></code></a>(ops[,&nbsp;sites,&nbsp;axes])</td>
<td>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;bra|ops|ket&gt;</span></code> of (n-site) operator(s).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.full_contraction" title="tenpy.networks.mps.MPSEnvironment.full_contraction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_contraction</span></code></a>(i0)</td>
<td>Calculate the overlap by a full contraction of the network.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.get_LP" title="tenpy.networks.mps.MPSEnvironment.get_LP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_LP</span></code></a>(i[,&nbsp;store])</td>
<td>Calculate LP at given site from nearest available one (including <cite>i</cite>).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.get_LP_age" title="tenpy.networks.mps.MPSEnvironment.get_LP_age"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_LP_age</span></code></a>(i)</td>
<td>Return number of physical sites in the contractions of get_LP(i).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.get_RP" title="tenpy.networks.mps.MPSEnvironment.get_RP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_RP</span></code></a>(i[,&nbsp;store])</td>
<td>Calculate RP at given site from nearest available one (including <cite>i</cite>).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.get_RP_age" title="tenpy.networks.mps.MPSEnvironment.get_RP_age"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_RP_age</span></code></a>(i)</td>
<td>Return number of physical sites in the contractions of get_LP(i).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.set_LP" title="tenpy.networks.mps.MPSEnvironment.set_LP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_LP</span></code></a>(i,&nbsp;LP,&nbsp;age)</td>
<td>Store part to the left of site <cite>i</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.MPSEnvironment.set_RP" title="tenpy.networks.mps.MPSEnvironment.set_RP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_RP</span></code></a>(i,&nbsp;RP,&nbsp;age)</td>
<td>Store part to the right of site 1i1.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>test_sanity</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.del_LP">
<code class="descname">del_LP</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.del_LP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.del_LP" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete stored part strictly to the left of site <cite>i</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.del_RP">
<code class="descname">del_RP</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.del_RP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.del_RP" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete storde part scrictly to the right of site <cite>i</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.expectation_value">
<code class="descname">expectation_value</code><span class="sig-paren">(</span><em>ops</em>, <em>sites=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.expectation_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.expectation_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;bra|ops|ket&gt;</span></code> of (n-site) operator(s).</p>
<p>Calculates n-site expectation values of operators sandwiched between bra and ket.
For examples the contraction for a two-site operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="n">LP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">op</span>  <span class="o">|</span>       <span class="n">RP</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<p>Here, the <cite>B</cite> are taken from <cite>ket</cite>, the <cite>B*</cite> from <cite>bra</cite>.
The call structure is the same as for <a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value" title="tenpy.networks.mps.MPS.expectation_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MPS.expectation_value()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">The operators, for wich the expectation value should be taken,
All operators should all have the same number of legs (namely <cite>2 n</cite>).
If less than <code class="docutils literal notranslate"><span class="pre">len(sites)</span></code> operators are given, we repeat them periodically.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of site indices. Expectation values are evaluated there.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the entire chain is taken (clipping for finite b.c.)</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (list of str, list of str)</span></dt>
<dd><p class="first last">Two lists of each <cite>n</cite> leg labels giving the physical legs of the operator used for
contraction. The first <cite>n</cite> legs are contracted with conjugated <cite>B</cite>,
the second <cite>n</cite> legs with the non-conjugated <cite>B</cite>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">(['p'],</span> <span class="pre">['p*'])</span></code> for single site (n=1), or
<code class="docutils literal notranslate"><span class="pre">(['p0',</span> <span class="pre">'p1',</span> <span class="pre">...</span> <span class="pre">'p{n-1}'],</span> <span class="pre">['p0*',</span> <span class="pre">'p1*',</span> <span class="pre">....</span> <span class="pre">'p{n-1}*'])</span></code> for <cite>n</cite> &gt; 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">Expectation values, <code class="docutils literal notranslate"><span class="pre">exp_vals[i]</span> <span class="pre">=</span> <span class="pre">&lt;bra|ops[i]|ket&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">ops[i]</span></code> acts on
site(s) <code class="docutils literal notranslate"><span class="pre">j,</span> <span class="pre">j+1,</span> <span class="pre">...,</span> <span class="pre">j+{n-1}</span></code> with <code class="docutils literal notranslate"><span class="pre">j=sites[i]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>One site examples (n=1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="go">[Sz0, Sz1, ..., Sz{L-1}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Sx&#39;</span><span class="p">])</span>
<span class="go">[Sz0, Sx1, Sz2, Sx3, ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[Sz0, Sz3, Sz4]</span>
</pre></div>
</div>
<p>Two site example (n=2), assuming homogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                     psi.sites[1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx</span><span class="p">)</span>
<span class="go">[Sz0Sx1, Sz1Sx2, Sz2Sx3, ... ]   # with len L-1 for finite bc, or L for infinite</span>
</pre></div>
</div>
<p>Example measuring &lt;bra|SzSx|ket&gt; on each second site, for inhomogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                           psi.sites[i+1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="go">                 for i in range(0, psi.L-1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx_list</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[Sz0Sx1, Sz2Sx3, Sz4Sx5, ...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.full_contraction">
<code class="descname">full_contraction</code><span class="sig-paren">(</span><em>i0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.full_contraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.full_contraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overlap by a full contraction of the network.</p>
<p>The full contraction of the environments gives the overlap <code class="docutils literal notranslate"><span class="pre">&lt;bra|ket&gt;</span></code>,
taking into account <code class="xref py py-attr docutils literal notranslate"><span class="pre">MPS.norm</span></code> of both <cite>bra</cite> and <cite>ket</cite>.
For this purpose, this function contracts
<code class="docutils literal notranslate"><span class="pre">get_LP(i0+1,</span> <span class="pre">store=False)</span></code> and <code class="docutils literal notranslate"><span class="pre">get_RP(i0,</span> <span class="pre">store=False)</span></code> with appropriate singular
values in between.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Site index.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.get_LP">
<code class="descname">get_LP</code><span class="sig-paren">(</span><em>i</em>, <em>store=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.get_LP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.get_LP" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate LP at given site from nearest available one (including <cite>i</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The returned <cite>LP</cite> will contain the contraction <em>strictly</em> left of site <cite>i</cite>.</p>
</dd>
<dt><strong>store</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter to store the calculated <cite>LP</cite> in <cite>self</cite> (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or discard them (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>LP_i</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Contraction of everything left of site <cite>i</cite>,
with labels <code class="docutils literal notranslate"><span class="pre">'vR*',</span> <span class="pre">'vR'</span></code> for <cite>bra</cite>, <cite>ket</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.get_LP_age">
<code class="descname">get_LP_age</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.get_LP_age"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.get_LP_age" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of physical sites in the contractions of get_LP(i). Might be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.get_RP">
<code class="descname">get_RP</code><span class="sig-paren">(</span><em>i</em>, <em>store=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.get_RP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.get_RP" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate RP at given site from nearest available one (including <cite>i</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The returned <cite>RP</cite> will contain the contraction <em>strictly</em> rigth of site <cite>i</cite>.</p>
</dd>
<dt><strong>store</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter to store the calculated <cite>RP</cite> in <cite>self</cite> (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or discard them (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>RP_i</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Contraction of everything left of site <cite>i</cite>,
with labels <code class="docutils literal notranslate"><span class="pre">'vL*',</span> <span class="pre">'vL'</span></code> for <cite>bra</cite>, <cite>ket</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.get_RP_age">
<code class="descname">get_RP_age</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.get_RP_age"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.get_RP_age" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of physical sites in the contractions of get_LP(i). Might be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.set_LP">
<code class="descname">set_LP</code><span class="sig-paren">(</span><em>i</em>, <em>LP</em>, <em>age</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.set_LP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.set_LP" title="Permalink to this definition">¶</a></dt>
<dd><p>Store part to the left of site <cite>i</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.set_RP">
<code class="descname">set_RP</code><span class="sig-paren">(</span><em>i</em>, <em>RP</em>, <em>age</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.set_RP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.set_RP" title="Permalink to this definition">¶</a></dt>
<dd><p>Store part to the right of site 1i1.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPSEnvironment.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPSEnvironment.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPSEnvironment.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.networks.mps.TransferMatrix">
<em class="property">class </em><code class="descclassname">tenpy.networks.mps.</code><code class="descname">TransferMatrix</code><span class="sig-paren">(</span><em>bra</em>, <em>ket</em>, <em>shift_bra=0</em>, <em>shift_ket=None</em>, <em>transpose=False</em>, <em>charge_sector=0</em>, <em>form='B'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#TransferMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.TransferMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tenpy.linalg.sparse.html#tenpy.linalg.sparse.NpcLinearOperator" title="tenpy.linalg.sparse.NpcLinearOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.linalg.sparse.NpcLinearOperator</span></code></a></p>
<p>Transfer matrix of two MPS (bra &amp; ket).</p>
<p>For an iMPS in the thermodynamic limit, we often need to find the ‘dominant <cite>RP</cite>’ (and <cite>LP</cite>).
This mean nothing else than to take the transfer matrix of the unit cell and find the
(right/left) eigenvector with the largest (magnitude) eigenvalue, since it will dominate
<span class="math notranslate nohighlight">\((TM)^n RP\)</span> (or <span class="math notranslate nohighlight">\(LP (TM)^n\)</span>) in the limit <span class="math notranslate nohighlight">\(n \rightarrow \infty\)</span> - whatever
the initial <cite>RP</cite> is. This class provides exactly that functionality with <a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.eigenvectors" title="tenpy.networks.mps.TransferMatrix.eigenvectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eigenvectors()</span></code></a>.</p>
<p>Given two MPS, we define the transfer matrix as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>    <span class="o">---</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span> <span class="o">...</span> <span class="o">--</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">L</span><span class="p">]</span><span class="o">---</span>
<span class="o">|</span>       <span class="o">|</span>      <span class="o">|</span>             <span class="o">|</span>
<span class="o">|</span>    <span class="o">---</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*--</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span> <span class="o">...</span> <span class="o">--</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">L</span><span class="p">]</span><span class="o">*--</span>
</pre></div>
</div>
<p>Here the <cite>M</cite> denotes the matrices of the bra and <cite>N</cite> the ones of the ket, respectively.
To view it as a <cite>matrix</cite>, we combine the left and right indices to pipes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>  <span class="p">(</span><span class="n">vL</span><span class="o">.</span><span class="n">vL</span><span class="o">*</span><span class="p">)</span> <span class="o">-&gt;-</span><span class="n">TM</span><span class="o">-&gt;-</span> <span class="p">(</span><span class="n">vR</span><span class="o">.</span><span class="n">vR</span><span class="o">*</span><span class="p">)</span>   <span class="n">acting</span> <span class="n">on</span>  <span class="p">(</span><span class="n">vL</span><span class="o">.</span><span class="n">vL</span><span class="o">*</span><span class="p">)</span> <span class="o">-&gt;-</span><span class="n">RP</span>
</pre></div>
</div>
<p>Note that we keep all M and N as copies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">MPS</span></dt>
<dd><p class="first last">The MPS which is to be (complex) conjugated</p>
</dd>
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">MPS</span></dt>
<dd><p class="first last">The MPS which is not (complex) conjugated.</p>
</dd>
<dt><strong>shift_bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">We start the <cite>N</cite> of the bra at site <cite>shift_bra</cite> (i.e. the <cite>j</cite> in the above network).</p>
</dd>
<dt><strong>shift_ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">We start the <cite>M</cite> of the ket at site <cite>shift_ket</cite> (i.e. the <cite>i</cite> in the above network).
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <cite>shift_bra</cite>.</p>
</dd>
<dt><strong>transpose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter <cite>self.matvec</cite> acts on <cite>RP</cite> (<code class="docutils literal notranslate"><span class="pre">False</span></code>) or <cite>LP</cite> (<code class="docutils literal notranslate"><span class="pre">True</span></code>).</p>
</dd>
<dt><strong>charge_sector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | charges | <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt>
<dd><p class="first last">Selects the charge sector of the vector onto which the Linear operator acts.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for <em>all</em> sectors, <code class="docutils literal notranslate"><span class="pre">0</span></code> stands for the zero-charge sector.
Defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>, i.e., <em>assumes</em> the dominant eigenvector is in charge sector 0.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt>
<dd><p class="first last">In which canonical form we take the <cite>M</cite> and <cite>N</cite> matrices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of physical sites involved in the transfer matrix, i.e. the least common multiple
of <cite>bra.L</cite> and <cite>ket.L</cite>.</p>
</dd>
<dt><strong>shift_bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">We start the <cite>N</cite> of the bra at site <cite>shift_bra</cite>.</p>
</dd>
<dt><strong>shift_ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">We start the <cite>M</cite> of the ket at site <cite>shift_ket</cite>. <code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <cite>shift_bra</cite>.</p>
</dd>
<dt><strong>transpose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter <cite>self.matvec</cite> acts on <cite>RP</cite> (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or <cite>LP</cite> (<code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last">Total charge of the transfer matrix (which is gauged away in matvec).</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple(float, float) | None</span></dt>
<dd><p class="first last">In which canonical form (all of) the <cite>M</cite> and <cite>N</cite> matrices are.</p>
</dd>
<dt><strong>flat_linop</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.sparse.html#tenpy.linalg.sparse.FlatLinearOperator" title="tenpy.linalg.sparse.FlatLinearOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlatLinearOperator</span></code></a></span></dt>
<dd><p class="first last">Class lifting <a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.matvec" title="tenpy.networks.mps.TransferMatrix.matvec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matvec()</span></code></a> to ndarrays in order to use <a class="reference internal" href="tenpy.tools.math.html#tenpy.tools.math.speigs" title="tenpy.tools.math.speigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">speigs()</span></code></a>.</p>
</dd>
<dt><strong>pipe</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a></span></dt>
<dd><p class="first last">Pipe corresponding to <code class="docutils literal notranslate"><span class="pre">'(vL.vL*)'</span></code> for <code class="docutils literal notranslate"><span class="pre">transpose=False</span></code>
or to <code class="docutils literal notranslate"><span class="pre">'(vR.vR*)'</span></code> for <code class="docutils literal notranslate"><span class="pre">transpose=True</span></code>.</p>
</dd>
<dt><strong>label_split :</strong></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">['vL',</span> <span class="pre">'vL*']</span></code> if <code class="docutils literal notranslate"><span class="pre">tranpose=False</span></code> or <code class="docutils literal notranslate"><span class="pre">['vR',</span> <span class="pre">'vR*']</span></code> if <code class="docutils literal notranslate"><span class="pre">transpose=True</span></code>.</p>
</dd>
<dt><strong>_bra_N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of npc.Array</span></dt>
<dd><p class="first last">Complex conjugated matrices of the bra, transposed for fast <cite>matvec</cite>.</p>
</dd>
<dt><strong>_ket_M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of npc.Array</span></dt>
<dd><p class="first last">The matrices of the ket, transposed for fast <cite>matvec</cite>.</p>
</dd>
<dt><strong>_contract_legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of physical legs per site + 1.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.eigenvectors" title="tenpy.networks.mps.TransferMatrix.eigenvectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenvectors</span></code></a>([num_ev,&nbsp;max_num_ev,&nbsp;max_tol,&nbsp;…])</td>
<td>Find (dominant) eigenvector(s) of self using scipy.sparse.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.initial_guess" title="tenpy.networks.mps.TransferMatrix.initial_guess"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initial_guess</span></code></a>([diag])</td>
<td>Return a diagonal matrix as initial guess for the eigenvector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.matvec" title="tenpy.networks.mps.TransferMatrix.matvec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matvec</span></code></a>(vec)</td>
<td>Given <cite>vec</cite> as an npc.Array, apply the transfer matrix.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.networks.mps.TransferMatrix.eigenvectors">
<code class="descname">eigenvectors</code><span class="sig-paren">(</span><em>num_ev=1</em>, <em>max_num_ev=None</em>, <em>max_tol=1e-12</em>, <em>which='LM'</em>, <em>v0=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#TransferMatrix.eigenvectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.TransferMatrix.eigenvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Find (dominant) eigenvector(s) of self using scipy.sparse.</p>
<p>If no charge_sector was selected, we look in <em>all</em> charge sectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>num_ev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of eigenvalues/vectors to look for.</p>
</dd>
<dt><strong>max_num_ev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.speigs()</span></code> somtimes raises a NoConvergenceError for small
<cite>num_ev</cite>, which might be avoided by increasing <cite>num_ev</cite>. As a work-around,
we try it again in the case of an error, just with larger <cite>num_ev</cite> up to <cite>max_num_ev</cite>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">num_ev</span> <span class="pre">+</span> <span class="pre">2</span></code>.</p>
</dd>
<dt><strong>max_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">After the first <cite>NoConvergenceError</cite> we increase the <cite>tol</cite> argument to that value.</p>
</dd>
<dt><strong>which</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Which eigenvalues to look for, see <cite>scipy.sparse.linalg.speigs</cite>.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Further keyword arguments are given to <a class="reference internal" href="tenpy.tools.math.html#tenpy.tools.math.speigs" title="tenpy.tools.math.speigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">speigs()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">The eigenvalues, sorted according to <cite>which</cite>.</p>
</dd>
<dt><strong>w</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The eigenvectors corresponding to <cite>eta</cite>, as npc.Array with LegPipe.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.TransferMatrix.initial_guess">
<code class="descname">initial_guess</code><span class="sig-paren">(</span><em>diag=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#TransferMatrix.initial_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.TransferMatrix.initial_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a diagonal matrix as initial guess for the eigenvector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>diag</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | 1D ndarray</span></dt>
<dd><p class="first last">Should be <code class="docutils literal notranslate"><span class="pre">1.</span></code> for the identity or some singular values squared.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A 2D array with <cite>diag</cite> on the diagonal such that <a class="reference internal" href="#tenpy.networks.mps.TransferMatrix.matvec" title="tenpy.networks.mps.TransferMatrix.matvec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matvec()</span></code></a> can act on it.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.TransferMatrix.matvec">
<code class="descname">matvec</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#TransferMatrix.matvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.TransferMatrix.matvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <cite>vec</cite> as an npc.Array, apply the transfer matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Vector to act on with the transfermatrix.
If not <cite>transposed</cite>, <cite>vec</cite> is the right part <cite>RP</cite> of an environment,
with legs <code class="docutils literal notranslate"><span class="pre">'(vL.vL*)'</span></code> in a pipe or splitted.
If <cite>transposed</cite>, the left part <cite>LP</cite> of an environment with legs <code class="docutils literal notranslate"><span class="pre">'(vR*.vR)'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mat_vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The tranfer matrix acted on <cite>vec</cite>, in the same form as given.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.networks.mpo.html"
                        title="previous chapter">tenpy.networks.mpo module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.networks.purification_mps.html"
                        title="next chapter">tenpy.networks.purification_mps module</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tenpy.html">Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.algorithms.html">tenpy.algorithms package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.html">tenpy.linalg package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.html">tenpy.models package</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.networks.html">tenpy.networks package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.tools.html">tenpy.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#module-tenpy">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.purification_mps.html" title="tenpy.networks.purification_mps module"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mpo.html" title="tenpy.networks.mpo module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.networks.html" >tenpy.networks package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 01, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>