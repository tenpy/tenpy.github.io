
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tenpy.linalg.np_conserved module &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="tenpy.linalg.npc_helper module" href="tenpy.linalg.npc_helper.html" />
    <link rel="prev" title="tenpy.linalg.lanczos module" href="tenpy.linalg.lanczos.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.npc_helper.html" title="tenpy.linalg.npc_helper module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.lanczos.html" title="tenpy.linalg.lanczos module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.linalg.html" accesskey="U">tenpy.linalg package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tenpy.linalg.np_conserved">
<span id="tenpy-linalg-np-conserved-module"></span><h1>tenpy.linalg.np_conserved module<a class="headerlink" href="#module-tenpy.linalg.np_conserved" title="Permalink to this headline">¶</a></h1>
<p>A module to handle charge conservation in tensor networks.</p>
<p>A detailed introduction to this module (including notations) can be found in <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
<p>This module <cite>np_conserved</cite> implements an class <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>
designed to make use of charge conservation in tensor networks.
The idea is that the <cite>Array</cite> class is used in a fashion very similar to
the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.16)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, e.g you can call the functions <a class="reference internal" href="#tenpy.linalg.np_conserved.tensordot" title="tenpy.linalg.np_conserved.tensordot"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensordot()</span></code></a> or <a class="reference internal" href="#tenpy.linalg.np_conserved.svd" title="tenpy.linalg.np_conserved.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a>
(of this module) on them.
The structure of the algorithms (as DMRG) is thus the same as with basic numpy ndarrays.</p>
<p>Internally, an <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> saves charge meta data to keep track of blocks which are nonzero.
All possible operations (e.g. tensordot, svd, …) on such arrays preserve the total charge
structure. In addition, these operations make use of the charges to figure out which of the blocks
it hase to use/combine - this is the basis for the speed-up.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Classes:
<a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe" title="tenpy.linalg.np_conserved.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></p>
<p>Array creation:
<a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="tenpy.linalg.np_conserved.Array.from_ndarray_trivial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.from_ndarray_trivial()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.from_ndarray()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func" title="tenpy.linalg.np_conserved.Array.from_func"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.from_func()</span></code></a>,
<a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func_square" title="tenpy.linalg.np_conserved.Array.from_func_square"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.from_func_square()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.zeros" title="tenpy.linalg.np_conserved.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.eye_like" title="tenpy.linalg.np_conserved.eye_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">eye_like()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.diag" title="tenpy.linalg.np_conserved.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag()</span></code></a>,</p>
<p>Concatenation:
<a class="reference internal" href="#tenpy.linalg.np_conserved.concatenate" title="tenpy.linalg.np_conserved.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.grid_concat" title="tenpy.linalg.np_conserved.grid_concat"><code class="xref py py-func docutils literal notranslate"><span class="pre">grid_concat()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.grid_outer" title="tenpy.linalg.np_conserved.grid_outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">grid_outer()</span></code></a></p>
<p>Detecting charges of flat arrays:
<a class="reference internal" href="#tenpy.linalg.np_conserved.detect_qtotal" title="tenpy.linalg.np_conserved.detect_qtotal"><code class="xref py py-func docutils literal notranslate"><span class="pre">detect_qtotal()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.detect_legcharge" title="tenpy.linalg.np_conserved.detect_legcharge"><code class="xref py py-func docutils literal notranslate"><span class="pre">detect_legcharge()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.detect_grid_outer_legcharge" title="tenpy.linalg.np_conserved.detect_grid_outer_legcharge"><code class="xref py py-func docutils literal notranslate"><span class="pre">detect_grid_outer_legcharge()</span></code></a></p>
<p>Contraction of some legs:
<a class="reference internal" href="#tenpy.linalg.np_conserved.tensordot" title="tenpy.linalg.np_conserved.tensordot"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensordot()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.outer" title="tenpy.linalg.np_conserved.outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">outer()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.inner" title="tenpy.linalg.np_conserved.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">inner()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.trace" title="tenpy.linalg.np_conserved.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">trace()</span></code></a></p>
<p>Linear algebra:
<a class="reference internal" href="#tenpy.linalg.np_conserved.svd" title="tenpy.linalg.np_conserved.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.pinv" title="tenpy.linalg.np_conserved.pinv"><code class="xref py py-func docutils literal notranslate"><span class="pre">pinv()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.norm" title="tenpy.linalg.np_conserved.norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">norm()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.qr" title="tenpy.linalg.np_conserved.qr"><code class="xref py py-func docutils literal notranslate"><span class="pre">qr()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.expm" title="tenpy.linalg.np_conserved.expm"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm()</span></code></a></p>
<p>Eigen systems:
<a class="reference internal" href="#tenpy.linalg.np_conserved.eigh" title="tenpy.linalg.np_conserved.eigh"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigh()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.eig" title="tenpy.linalg.np_conserved.eig"><code class="xref py py-func docutils literal notranslate"><span class="pre">eig()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.eigvalsh" title="tenpy.linalg.np_conserved.eigvalsh"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigvalsh()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.eigvals" title="tenpy.linalg.np_conserved.eigvals"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigvals()</span></code></a>, <a class="reference internal" href="#tenpy.linalg.np_conserved.speigs" title="tenpy.linalg.np_conserved.speigs"><code class="xref py py-func docutils literal notranslate"><span class="pre">speigs()</span></code></a></p>
<dl class="data">
<dt id="tenpy.linalg.np_conserved.QCUTOFF">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">QCUTOFF</code><em class="property"> = 2.220446049250313e-15</em><a class="headerlink" href="#tenpy.linalg.np_conserved.QCUTOFF" title="Permalink to this definition">¶</a></dt>
<dd><p>A cutoff to ignore machine precision rounding errors when determining charges</p>
</dd></dl>

<dl class="class">
<dt id="tenpy.linalg.np_conserved.ChargeInfo">
<em class="property">class </em><code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">ChargeInfo</code><span class="sig-paren">(</span><em>mod=[]</em>, <em>names=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Meta-data about the charge of a tensor.</p>
<p>Saves info about the nature of the charge of a tensor.
Provides <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.make_valid" title="tenpy.linalg.np_conserved.ChargeInfo.make_valid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_valid()</span></code></a> for taking modulo <cite>m</cite>.</p>
<p>(This class is implemented in <a class="reference internal" href="tenpy.linalg.charges.html#module-tenpy.linalg.charges" title="tenpy.linalg.charges"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.charges</span></code></a> but also imported in
<a class="reference internal" href="#module-tenpy.linalg.np_conserved" title="tenpy.linalg.np_conserved"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.np_conserved</span></code></a> for convenience.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mod</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of QTYPE</span></dt>
<dd><p class="first last">The len gives the number of charges, <cite>qnumber</cite>.
For each charge one entry <cite>m</cite>: the charge is conserved modulo <cite>m</cite>.
Defaults to trivial, i.e., no charge.</p>
</dd>
<dt><strong>names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">Descriptive names for the charges.  Defaults to <code class="docutils literal notranslate"><span class="pre">['']*qnumber</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Instances of this class can (should) be shared between different <cite>LegCharge</cite> and <cite>Array</cite>’s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.qnumber" title="tenpy.linalg.np_conserved.ChargeInfo.qnumber"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qnumber</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of charges.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.mod" title="tenpy.linalg.np_conserved.ChargeInfo.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mod</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray[QTYPE,ndim=1]</span></dt>
<dd><p class="first last">Modulo how much each of the charges is taken.</p>
</dd>
<dt><strong>names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">A descriptive name for each of the charges.  May have ‘’ entries.</p>
</dd>
<dt><strong>_mask_mod1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array bool</span></dt>
<dd><p class="first last">mask <code class="docutils literal notranslate"><span class="pre">(mod</span> <span class="pre">==</span> <span class="pre">1)</span></code>, to speed up <cite>make_valid</cite> in pure python.</p>
</dd>
<dt><strong>_mod_masked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array QTYPE</span></dt>
<dd><p class="first last">Equivalent to <code class="docutils literal notranslate"><span class="pre">self.mod[self._maks_mod1]</span></code></p>
</dd>
<dt><strong>_qnumber, _mod :</strong></dt>
<dd><p class="first last">Storage of <cite>qnumber</cite> and <cite>mod</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.add" title="tenpy.linalg.np_conserved.ChargeInfo.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(chinfos)</td>
<td>Create a <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> combining multiple charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.change" title="tenpy.linalg.np_conserved.ChargeInfo.change"><code class="xref py py-obj docutils literal notranslate"><span class="pre">change</span></code></a>(chinfo,&nbsp;charge,&nbsp;new_qmod[,&nbsp;new_name])</td>
<td>Change the <cite>qmod</cite> of a given charge.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.check_valid" title="tenpy.linalg.np_conserved.ChargeInfo.check_valid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_valid</span></code></a>(charges)</td>
<td>Check, if <cite>charges</cite> has all entries as expected from self.mod.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.drop" title="tenpy.linalg.np_conserved.ChargeInfo.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code></a>(chinfo[,&nbsp;charge])</td>
<td>Remove a charge from a <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.make_valid" title="tenpy.linalg.np_conserved.ChargeInfo.make_valid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_valid</span></code></a>([charges])</td>
<td>Take charges modulo self.mod.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo.test_sanity" title="tenpy.linalg.np_conserved.ChargeInfo.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.add">
<em class="property">classmethod </em><code class="descname">add</code><span class="sig-paren">(</span><em>chinfos</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> combining multiple charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chinfos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">ChargeInfo instances to be combined into a single one (in the given order).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">ChargeInfo combining all the given charges.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.change">
<em class="property">classmethod </em><code class="descname">change</code><span class="sig-paren">(</span><em>chinfo</em>, <em>charge</em>, <em>new_qmod</em>, <em>new_name=''</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo.change"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.change" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the <cite>qmod</cite> of a given charge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo for which <cite>qmod</cite> of <cite>charge</cite> should be changed.</p>
</dd>
<dt><strong>new_qmod</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The new <cite>qmod</cite> to be set.</p>
</dd>
<dt><strong>new_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The new name of the charge.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">ChargeInfo where <cite>qmod</cite> of the specified charge was changed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.check_valid">
<code class="descname">check_valid</code><span class="sig-paren">(</span><em>charges</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo.check_valid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.check_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check, if <cite>charges</cite> has all entries as expected from self.mod.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>charges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray QTYPE_t</span></dt>
<dd><p class="first last">Charge values to be checked.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if all 0 &lt;= charges &lt;= self.mod (wherever self.mod != 1)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.drop">
<em class="property">classmethod </em><code class="descname">drop</code><span class="sig-paren">(</span><em>chinfo</em>, <em>charge=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo.drop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a charge from a <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo from where to drop/remove a charge.</p>
</dd>
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be dropped.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">ChargeInfo where the specified charge is dropped.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.make_valid">
<code class="descname">make_valid</code><span class="sig-paren">(</span><em>charges=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo.make_valid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.make_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Take charges modulo self.mod.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>charges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like or None</span></dt>
<dd><p class="first last">1D or 2D array of charges, last dimension <cite>self.qnumber</cite>
None defaults to trivial charges <code class="docutils literal notranslate"><span class="pre">np.zeros(qnumber,</span> <span class="pre">dtype=QTYPE)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>charges :</strong></dt>
<dd><p class="first last">A copy of <cite>charges</cite> taken modulo <cite>mod</cite>, but with <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">1</span> <span class="pre">:=</span> <span class="pre">x</span></code></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.mod">
<code class="descname">mod</code><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo how much each of the charges is taken.
1 for a U(1) charge, i.e., mod 1 -&gt; mod infinity.</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.qnumber">
<code class="descname">qnumber</code><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.qnumber" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of charges.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.ChargeInfo.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#ChargeInfo.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.ChargeInfo.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.linalg.np_conserved.LegCharge">
<em class="property">class </em><code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">LegCharge</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>slices</em>, <em>charges</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Save the charge data associated to a leg of a tensor.</p>
<p>This class is more or less a wrapper around a 2D numpy array <cite>charges</cite> and a 1D array <cite>slices</cite>.
See <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a> for more details.</p>
<p>(This class is implemented in <a class="reference internal" href="tenpy.linalg.charges.html#module-tenpy.linalg.charges" title="tenpy.linalg.charges"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.charges</span></code></a> but also imported in
<a class="reference internal" href="#module-tenpy.linalg.np_conserved" title="tenpy.linalg.np_conserved"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.np_conserved</span></code></a> for convenience.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>slices: 1D array_like, len(block_number+1)</strong></dt>
<dd><p class="first last">A block with ‘qindex’ <code class="docutils literal notranslate"><span class="pre">qi</span></code> correspondes to the leg indices in
<code class="docutils literal notranslate"><span class="pre">slice(slices[qi],</span> <span class="pre">slices[qi+1])</span></code>.</p>
</dd>
<dt><strong>charges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array_like, shape(block_number, chargeinfo.qnumber)</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">charges[qi]</span></code> gives the charges for a block with ‘qindex’ <code class="docutils literal notranslate"><span class="pre">qi</span></code>.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{+1, -1}</span></dt>
<dd><p class="first last">A flag telling whether the charge points inwards (+1, default) or outwards (-1).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Instances of this class can be shared between different <cite>npc.Array</cite>.
Thus, functions changing <code class="docutils literal notranslate"><span class="pre">self.slices</span></code> or <code class="docutils literal notranslate"><span class="pre">self.charges</span></code> <em>must</em> always make copies.
Further they <em>must</em> set <cite>sorted</cite> and <cite>bunched</cite> to <code class="docutils literal notranslate"><span class="pre">False</span></code> (if they might not preserve them).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ind_len: int</strong></dt>
<dd><p class="first last">The number of indices for this leg.</p>
</dd>
<dt><strong>block_number:</strong></dt>
<dd><p class="first last">The number of blocks, i.e., a ‘qindex’ for this leg is in <code class="docutils literal notranslate"><span class="pre">range(block_number)</span></code>.</p>
</dd>
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> instance</span></dt>
<dd><p class="first last">The nature of the charge. Can be shared between LegCharges.</p>
</dd>
<dt><strong>slices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray[np.intp_t,ndim=1] (block_number+1)</span></dt>
<dd><p class="first last">A block with ‘qindex’ <code class="docutils literal notranslate"><span class="pre">qi</span></code> correspondes to the leg indices in
<code class="docutils literal notranslate"><span class="pre">slice(self.slices[qi],</span> <span class="pre">self.slices[qi+1])</span></code>. See <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.get_slice" title="tenpy.linalg.np_conserved.LegCharge.get_slice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_slice()</span></code></a>.</p>
</dd>
<dt><strong>charges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray[QTYPE_t,ndim=1] (block_number, chinfo.qnumber)</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">charges[qi]</span></code> gives the charges for a block with ‘qindex’ <code class="docutils literal notranslate"><span class="pre">qi</span></code>.
Note: the sign might be changed by <cite>qconj</cite>. See also <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.get_charge" title="tenpy.linalg.np_conserved.LegCharge.get_charge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_charge()</span></code></a>.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{-1, 1}</span></dt>
<dd><p class="first last">A flag telling whether the charge points inwards (+1) or outwards (-1).
Whenever charges are added, they should be multiplied with their <cite>qconj</cite> value.</p>
</dd>
<dt><strong>sorted</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the charges are guaranteed to be sorted.</p>
</dd>
<dt><strong>bunched</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the charges are guaranteed to be bunched.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bunch</span></code></a>()</td>
<td>Return a copy with bunched self.charges: form blocks for contiguous equal charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.charge_sectors" title="tenpy.linalg.np_conserved.LegCharge.charge_sectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">charge_sectors</span></code></a>()</td>
<td>Return unique rows of self.charges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.conj" title="tenpy.linalg.np_conserved.LegCharge.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a>()</td>
<td>Return a (shallow) copy with opposite <code class="docutils literal notranslate"><span class="pre">self.qconj</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.copy" title="tenpy.linalg.np_conserved.LegCharge.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Return a (shallow) copy of self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.extend" title="tenpy.linalg.np_conserved.LegCharge.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(extra)</td>
<td>Return a new <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a>, which extends self with futher charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_add_charge" title="tenpy.linalg.np_conserved.LegCharge.from_add_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_add_charge</span></code></a>(legs[,&nbsp;chargeinfo])</td>
<td>Add the (independent) charges of two or more legs to get larger <cite>qnumber</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_change_charge" title="tenpy.linalg.np_conserved.LegCharge.from_change_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_change_charge</span></code></a>(leg,&nbsp;charge,&nbsp;new_qmod[,&nbsp;…])</td>
<td>Remove a charge from a LegCharge.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_drop_charge" title="tenpy.linalg.np_conserved.LegCharge.from_drop_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_drop_charge</span></code></a>(leg[,&nbsp;charge,&nbsp;chargeinfo])</td>
<td>Remove a charge from a LegCharge.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_qdict" title="tenpy.linalg.np_conserved.LegCharge.from_qdict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qdict</span></code></a>(chargeinfo,&nbsp;qdict[,&nbsp;qconj])</td>
<td>Create a LegCharge from qdict form.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_qflat" title="tenpy.linalg.np_conserved.LegCharge.from_qflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qflat</span></code></a>(chargeinfo,&nbsp;qflat[,&nbsp;qconj])</td>
<td>Create a LegCharge from qflat form.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_qind" title="tenpy.linalg.np_conserved.LegCharge.from_qind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qind</span></code></a>(chargeinfo,&nbsp;slices,&nbsp;charges[,&nbsp;qconj])</td>
<td>Just a wrapper around self.__init__(), see class doc-string for parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.from_trivial" title="tenpy.linalg.np_conserved.LegCharge.from_trivial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_trivial</span></code></a>(ind_len[,&nbsp;chargeinfo,&nbsp;qconj])</td>
<td>Create trivial (qnumber=0) LegCharge for given len of indices <cite>ind_len</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.get_charge" title="tenpy.linalg.np_conserved.LegCharge.get_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_charge</span></code></a>(qindex)</td>
<td>Return charge <code class="docutils literal notranslate"><span class="pre">self.charges[qindex]</span> <span class="pre">*</span> <span class="pre">self.qconj</span></code> for a given <cite>qindex</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.get_qindex" title="tenpy.linalg.np_conserved.LegCharge.get_qindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_qindex</span></code></a>(flat_index)</td>
<td>Find qindex containing a flat index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.get_slice" title="tenpy.linalg.np_conserved.LegCharge.get_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice</span></code></a>(qindex)</td>
<td>Return slice selecting the block for a given <cite>qindex</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.is_blocked" title="tenpy.linalg.np_conserved.LegCharge.is_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_blocked</span></code></a>()</td>
<td>Returns whether self is blocked, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.is_bunched" title="tenpy.linalg.np_conserved.LegCharge.is_bunched"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_bunched</span></code></a>()</td>
<td>Checks whether <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a> would change something.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.is_sorted" title="tenpy.linalg.np_conserved.LegCharge.is_sorted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_sorted</span></code></a>()</td>
<td>Returns whether <cite>self.charges</cite> is sorted lexiographically.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.perm_flat_from_perm_qind" title="tenpy.linalg.np_conserved.LegCharge.perm_flat_from_perm_qind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perm_flat_from_perm_qind</span></code></a>(perm_qind)</td>
<td>Convert a permutation of qind (acting on self) into a flat permutation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.perm_qind_from_perm_flat" title="tenpy.linalg.np_conserved.LegCharge.perm_qind_from_perm_flat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perm_qind_from_perm_flat</span></code></a>(perm_flat)</td>
<td>Convert flat permutation into qind permutation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.project" title="tenpy.linalg.np_conserved.LegCharge.project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code></a>(mask)</td>
<td>Return copy keeping only the indices specified by <cite>mask</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="tenpy.linalg.np_conserved.LegCharge.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>([bunch])</td>
<td>Return a copy of <cite>self</cite> sorted by charges (but maybe not bunched).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.test_contractible" title="tenpy.linalg.np_conserved.LegCharge.test_contractible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_contractible</span></code></a>(other)</td>
<td>Raises a ValueError if charges are incompatible for contraction with other.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.test_equal" title="tenpy.linalg.np_conserved.LegCharge.test_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_equal</span></code></a>(other)</td>
<td>Test if charges are <em>equal</em> including <cite>qconj</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.test_sanity" title="tenpy.linalg.np_conserved.LegCharge.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.to_qdict" title="tenpy.linalg.np_conserved.LegCharge.to_qdict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_qdict</span></code></a>()</td>
<td>Return charges in <cite>qdict</cite> form.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.to_qflat" title="tenpy.linalg.np_conserved.LegCharge.to_qflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_qflat</span></code></a>()</td>
<td>Return charges in <cite>qflat</cite> form.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.bunch">
<code class="descname">bunch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.bunch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy with bunched self.charges: form blocks for contiguous equal charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">idx[:-1]</span></code> are the indices of the old qind which are kept,
<code class="docutils literal notranslate"><span class="pre">idx[-1]</span> <span class="pre">=</span> <span class="pre">old_block_number</span></code>.</p>
</dd>
<dt><strong>cp</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A new LegCharge with the same charges at given indices of the leg,
but (possibly) shorter <code class="docutils literal notranslate"><span class="pre">self.charges</span></code> and <code class="docutils literal notranslate"><span class="pre">self.slices</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="tenpy.linalg.np_conserved.LegCharge.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a></dt>
<dd>sorts by charges, thus enforcing complete blocking in combination with bunch</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.charge_sectors">
<code class="descname">charge_sectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.charge_sectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.charge_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique rows of self.charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>charges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[QTYPE, ndim=2]</span></dt>
<dd><p class="first last">Rows are the rows of self.charges lexsorted and without duplicates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a (shallow) copy with opposite <code class="docutils literal notranslate"><span class="pre">self.qconj</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a (shallow) copy of self.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>extra</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.extend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a>, which extends self with futher charges.</p>
<p>This is needed to formally increase the dimension of an Array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>extra</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> | int</span></dt>
<dd><p class="first last">By what to extend, i.e. the charges to be appended to <cite>self</cite>.
An int stands for extending the length of the array by a single new block of that size
and zero charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extended_leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">Copy of <cite>self</cite> extended by the charge blocks of the <cite>extra</cite> leg.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_add_charge">
<em class="property">classmethod </em><code class="descname">from_add_charge</code><span class="sig-paren">(</span><em>legs</em>, <em>chargeinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_add_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_add_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the (independent) charges of two or more legs to get larger <cite>qnumber</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The legs for which the charges are to be combined/added.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo for all charges; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>combined</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A LegCharge with the charges of both legs. Is neither sorted nor bunched!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_change_charge">
<em class="property">classmethod </em><code class="descname">from_change_charge</code><span class="sig-paren">(</span><em>leg</em>, <em>charge</em>, <em>new_qmod</em>, <em>new_name=''</em>, <em>chargeinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_change_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_change_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a charge from a LegCharge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg from which to drop/remove a charge.</p>
</dd>
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) for which <cite>mod</cite> is to be changed.</p>
</dd>
<dt><strong>new_qmod</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The new <cite>mod</cite> to be set for <cite>charge</cite> in the <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a>.</p>
</dd>
<dt><strong>new_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The new name for <cite>charge</cite>.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo with <cite>charge</cite> changed; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A LegCharge with the specified charge changed. Is neither sorted nor bunched!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_drop_charge">
<em class="property">classmethod </em><code class="descname">from_drop_charge</code><span class="sig-paren">(</span><em>leg</em>, <em>charge=None</em>, <em>chargeinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_drop_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_drop_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a charge from a LegCharge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg from which to drop/remove a charge.</p>
</dd>
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be dropped.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo with <cite>charge</cite> dropped; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dropped</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A LegCharge with the specified charge dropped. Is neither sorted nor bunched!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_qdict">
<em class="property">classmethod </em><code class="descname">from_qdict</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>qdict</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_qdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_qdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a LegCharge from qdict form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>qdict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary mapping a tuple of charges to slices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_qflat">
<em class="property">classmethod </em><code class="descname">from_qflat</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>qflat</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_qflat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_qflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a LegCharge from qflat form.</p>
<p>Does <em>neither</em> bunch <em>nor</em> sort. We recommend to sort (and bunch) afterwards,
if you expect that tensors using the LegCharge have entries at all positions compatible
with the charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>qflat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (ind_len, <cite>qnumber</cite>)</span></dt>
<dd><p class="first last"><cite>qnumber</cite> charges for each index of the leg on entry.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{-1, 1}</span></dt>
<dd><p class="first last">A flag telling whether the charge points inwards (+1) or outwards (-1).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="tenpy.linalg.np_conserved.LegCharge.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a></dt>
<dd>sorts by charges</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a></dt>
<dd>bunches contiguous blocks of the same charge.</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_qind">
<em class="property">classmethod </em><code class="descname">from_qind</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>slices</em>, <em>charges</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_qind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_qind" title="Permalink to this definition">¶</a></dt>
<dd><p>Just a wrapper around self.__init__(), see class doc-string for parameters.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="tenpy.linalg.np_conserved.LegCharge.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a></dt>
<dd>sorts by charges</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">block</span></code></dt>
<dd>blocks by charges</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegCharge.from_trivial">
<em class="property">classmethod </em><code class="descname">from_trivial</code><span class="sig-paren">(</span><em>ind_len</em>, <em>chargeinfo=None</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.from_trivial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.from_trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>Create trivial (qnumber=0) LegCharge for given len of indices <cite>ind_len</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.get_charge">
<code class="descname">get_charge</code><span class="sig-paren">(</span><em>qindex</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.get_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.get_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return charge <code class="docutils literal notranslate"><span class="pre">self.charges[qindex]</span> <span class="pre">*</span> <span class="pre">self.qconj</span></code> for a given <cite>qindex</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.get_qindex">
<code class="descname">get_qindex</code><span class="sig-paren">(</span><em>flat_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.get_qindex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.get_qindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Find qindex containing a flat index.</p>
<p>Given a flat index, to find the corresponding entry in an Array, we need to determine the
block it is saved in. For example, if <code class="docutils literal notranslate"><span class="pre">qind[:,</span> <span class="pre">2]</span> <span class="pre">=</span> <span class="pre">[[0,</span> <span class="pre">3],</span> <span class="pre">[3,</span> <span class="pre">7],</span> <span class="pre">[7,</span> <span class="pre">12]]</span></code>,
the flat index <code class="docutils literal notranslate"><span class="pre">5</span></code> corresponds to the second entry, <code class="docutils literal notranslate"><span class="pre">qindex</span> <span class="pre">=</span> <span class="pre">1</span></code> (since 5 is in [3:7]),
and the index within the block would be <code class="docutils literal notranslate"><span class="pre">5-3</span> <span class="pre">=2</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>flat_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">A flat index of the leg. Negative index counts from behind.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qindex</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The qindex, i.e. the index of the block containing <cite>flat_index</cite>.</p>
</dd>
<dt><strong>index_within_block</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The index of <cite>flat_index</cite> within the block given by <cite>qindex</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.get_slice">
<code class="descname">get_slice</code><span class="sig-paren">(</span><em>qindex</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.get_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.get_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice selecting the block for a given <cite>qindex</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.is_blocked">
<code class="descname">is_blocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.is_blocked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.is_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether self is blocked, i.e. qindex map 1:1 to charge values.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.is_bunched">
<code class="descname">is_bunched</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.is_bunched"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.is_bunched" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a> would change something.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.is_sorted">
<code class="descname">is_sorted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.is_sorted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.is_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <cite>self.charges</cite> is sorted lexiographically.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.perm_flat_from_perm_qind">
<code class="descname">perm_flat_from_perm_qind</code><span class="sig-paren">(</span><em>perm_qind</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.perm_flat_from_perm_qind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.perm_flat_from_perm_qind" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a permutation of qind (acting on self) into a flat permutation.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.perm_qind_from_perm_flat">
<code class="descname">perm_qind_from_perm_flat</code><span class="sig-paren">(</span><em>perm_flat</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.perm_qind_from_perm_flat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.perm_qind_from_perm_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert flat permutation into qind permutation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm_flat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">A permutation acting on self, which doesn’t mix the blocks of qind.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm_qind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">The permutation of self.qind described by perm_flat.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">If perm_flat mixes blocks of different qindex.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy keeping only the indices specified by <cite>mask</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array(bool)</span></dt>
<dd><p class="first last">Whether to keep of the indices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>map_qind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Map of qindices, such that <code class="docutils literal notranslate"><span class="pre">qind_new</span> <span class="pre">=</span> <span class="pre">map_qind[qind_old]</span></code>,
and <code class="docutils literal notranslate"><span class="pre">map_qind[qind_old]</span> <span class="pre">=</span> <span class="pre">-1</span></code> for qindices projected out.</p>
</dd>
<dt><strong>block_masks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">The bool mask for each of the <em>remaining</em> blocks.</p>
</dd>
<dt><strong>projected_copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">Copy of self with the qind projected by <cite>mask</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>bunch=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of <cite>self</cite> sorted by charges (but maybe not bunched).</p>
<p>If bunch=True, the returned copy is completely blocked by charge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bunch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether <cite>self.bunch</cite> is called after sorting.
If True, the leg is guaranteed to be fully blocked by charge.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>perm_qind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array (self.block_len,)</span></dt>
<dd><p class="first last">The permutation of the qindices (before bunching) used for the sorting.
To obtain the flat permuation such that
<code class="docutils literal notranslate"><span class="pre">sorted_array[...,</span> <span class="pre">:]</span> <span class="pre">=</span> <span class="pre">unsorted_array[...,</span> <span class="pre">perm_flat]</span></code>, use
<code class="docutils literal notranslate"><span class="pre">perm_flat</span> <span class="pre">=</span> <span class="pre">unsorted_leg.perm_flat_from_perm_qind(perm_qind)</span></code></p>
</dd>
<dt><strong>sorted_copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A shallow copy of self, with new qind sorted (and thus blocked if bunch) by charges.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bunch</span></code></a></dt>
<dd>enlarge blocks for contiguous qind of the same charges.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.take</span></code></dt>
<dd>can apply <cite>perm_flat</cite> to a given axis</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_permutation</span></code></dt>
<dd>returns inverse of a permutation</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.test_contractible">
<code class="descname">test_contractible</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.test_contractible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.test_contractible" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises a ValueError if charges are incompatible for contraction with other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The LegCharge of the other leg condsidered for contraction.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">If the charges are incompatible for direct contraction.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.test_equal" title="tenpy.linalg.np_conserved.LegCharge.test_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_equal</span></code></a></dt>
<dd><code class="docutils literal notranslate"><span class="pre">self.test_contractible(other)</span></code> just performs <code class="docutils literal notranslate"><span class="pre">self.test_equal(other.conj())</span></code>.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function checks that two legs are <cite>ready</cite> for contraction.
This is the case, if all of the following conditions are met:</p>
<ul>
<li><p class="first">the <code class="docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is equal</p>
</li>
<li><p class="first">the <cite>slices</cite> are equal</p>
</li>
<li><p class="first">the <cite>charges</cite> are the same up to <em>opposite</em> signs <code class="docutils literal notranslate"><span class="pre">qconj</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qconj</span> <span class="o">=</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">qconj</span>
</pre></div>
</div>
</li>
</ul>
<p>In general, there could also be a change of the total charge, see <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>
This special case is not considered here - instead use
<code class="xref py py-meth docutils literal notranslate"><span class="pre">gauge_total_charge()</span></code>,
if a change of the charge is desired.</p>
<p>If you are sure that the legs should be contractable,
check whether the charges are actually valid
or whether <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are blocked or should be sorted.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.test_equal">
<code class="descname">test_equal</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.test_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.test_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if charges are <em>equal</em> including <cite>qconj</cite>.</p>
<p>Check that all of the following conditions are met:</p>
<ul>
<li><p class="first">the <code class="docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is equal</p>
</li>
<li><p class="first">the <cite>slices</cite> are equal</p>
</li>
<li><p class="first">the <cite>charges</cite> are the same up to the signs <code class="docutils literal notranslate"><span class="pre">qconj</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qconj</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">qconj</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.test_contractible" title="tenpy.linalg.np_conserved.LegCharge.test_contractible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_contractible</span></code></a></dt>
<dd><code class="docutils literal notranslate"><span class="pre">self.test_equal(other)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">self.test_contractible(other.conj())</span></code>.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.to_qdict">
<code class="descname">to_qdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.to_qdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.to_qdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return charges in <cite>qdict</cite> form. Raises ValueError, if not blocked.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegCharge.to_qflat">
<code class="descname">to_qflat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegCharge.to_qflat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegCharge.to_qflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return charges in <cite>qflat</cite> form.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.linalg.np_conserved.LegPipe">
<em class="property">class </em><code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">LegPipe</code><span class="sig-paren">(</span><em>legs</em>, <em>qconj=1</em>, <em>sort=True</em>, <em>bunch=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.linalg.charges.LegCharge</span></code></a></p>
<p>A <cite>LegPipe</cite> combines multiple legs of a tensor to one.</p>
<p>Often, it is necessary to “combine” multiple legs into one:
for example to perfom a SVD, the tensor needs to be viewed as a matrix.</p>
<p>This class does exactly this job: it combines multiple LegCharges (‘incoming legs’)
into one ‘pipe’ (<em>the</em> ‘outgoing leg’).
The pipe itself is a <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a>, with indices running from 0 to the product of the
individual legs’ <cite>ind_len</cite>, corresponding to all possible combinations of input leg indices.</p>
<p>(This class is implemented in <a class="reference internal" href="tenpy.linalg.charges.html#module-tenpy.linalg.charges" title="tenpy.linalg.charges"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.charges</span></code></a> but also imported in
<a class="reference internal" href="#module-tenpy.linalg.np_conserved" title="tenpy.linalg.np_conserved"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.np_conserved</span></code></a> for convenience.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The legs which are to be combined.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{+1, -1}</span></dt>
<dd><p class="first last">A flag telling whether the charge of the <em>resulting</em> pipe points inwards
(+1, default) or outwards (-1).</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the outgoing pipe should be sorted. Default <code class="docutils literal notranslate"><span class="pre">True</span></code>; recommended.
Note: calling <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.sort" title="tenpy.linalg.np_conserved.LegPipe.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> after initialization converts to a LegCharge.</p>
</dd>
<dt><strong>bunch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the outgoing pipe should be bunched. Default <code class="docutils literal notranslate"><span class="pre">True</span></code>; recommended.
Note: calling <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.bunch" title="tenpy.linalg.np_conserved.LegPipe.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a> after initialization converts to a LegCharge.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For np.reshape, taking, for example,  <span class="math notranslate nohighlight">\(i,j,... \rightarrow k\)</span> amounted to
<span class="math notranslate nohighlight">\(k = s_1*i + s_2*j + ...\)</span> for appropriate strides <span class="math notranslate nohighlight">\(s_1,s_2\)</span>.</p>
<p>In the charged case, however, we want to block <span class="math notranslate nohighlight">\(k\)</span> by charge, so we must
implicitly permute as well.  This reordering is encoded in <cite>q_map</cite>.</p>
<p>Each qindex combination of the <cite>nlegs</cite> input legs <span class="math notranslate nohighlight">\((i_1, ..., i_{nlegs})\)</span>,
will end up getting placed in some slice <span class="math notranslate nohighlight">\(a_j:a_{j+1}\)</span> of the outgoing pipe.
Within this slice, the data is simply reshaped in usual row-major fashion (‘C’-order),
i.e., with strides <span class="math notranslate nohighlight">\(s_1 &gt; s_2 &gt; ...\)</span>.</p>
<p>It will be a subslice of a new total block labeled by qindex <span class="math notranslate nohighlight">\(I_s\)</span>.
Because many charge combinations fuse to the same total charge,
in general there will be many tuples <span class="math notranslate nohighlight">\((i_1, ..., i_{nlegs})\)</span> belonging to the same
<span class="math notranslate nohighlight">\(I_s\)</span>.  The rows of <cite>q_map</cite> are precisely the collections of
<code class="docutils literal notranslate"><span class="pre">[b_j,</span> <span class="pre">b_{j+1},</span> <span class="pre">I_s,</span> <span class="pre">i_1,</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span> <span class="pre">,</span> <span class="pre">i_{nlegs}]</span></code>.
Here, <span class="math notranslate nohighlight">\(b_j:b_{j+1}\)</span> denotes the slice of this qindex combination <em>within</em>
the total block <cite>I_s</cite>, i.e., <code class="docutils literal notranslate"><span class="pre">b_j</span> <span class="pre">=</span> <span class="pre">a_j</span> <span class="pre">-</span> <span class="pre">self.slices[I_s]</span></code>.</p>
<p>The rows of <cite>q_map</cite> are lex-sorted first by <code class="docutils literal notranslate"><span class="pre">I_s</span></code>, then the <code class="docutils literal notranslate"><span class="pre">i</span></code>.
Each <code class="docutils literal notranslate"><span class="pre">I_s</span></code> will have multiple rows,
and the order in which they are stored in <cite>q_map</cite> is the order the data is stored
in the actual tensor, i.e., it might look like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="o">...</span><span class="p">,</span>
 <span class="p">[</span> <span class="n">b_j</span><span class="p">,</span>     <span class="n">b_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">},</span>  <span class="n">I_s</span><span class="p">,</span>     <span class="n">i_1</span><span class="p">,</span>    <span class="o">...</span><span class="p">,</span> <span class="n">i_</span><span class="p">{</span><span class="n">nlegs</span><span class="p">}</span>   <span class="p">],</span>
 <span class="p">[</span> <span class="n">b_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">},</span> <span class="n">b_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">},</span>  <span class="n">I_s</span><span class="p">,</span>     <span class="n">i</span><span class="s1">&#39;_1,   ..., i&#39;</span><span class="n">_</span><span class="p">{</span><span class="n">nlegs</span><span class="p">}</span>  <span class="p">],</span>
 <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>       <span class="n">b_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">},</span>  <span class="n">I_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="s1">&#39;&#39;</span><span class="n">_1</span><span class="p">,</span>  <span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="s1">&#39;&#39;</span><span class="n">_</span><span class="p">{</span><span class="n">nlegs</span><span class="p">}</span> <span class="p">],</span>
 <span class="p">[</span> <span class="n">b_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">},</span> <span class="n">b_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">4</span><span class="p">},</span>  <span class="n">I_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="s1">&#39;&#39;&#39;_1, ..., i&#39;&#39;&#39;</span><span class="n">_</span><span class="p">{</span><span class="n">nlegs</span><span class="p">}],</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>The charge fusion rule is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="n">Qi</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qconj</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">charges</span><span class="p">[</span><span class="n">qi_l</span><span class="p">]</span><span class="o">*</span><span class="n">l</span><span class="o">.</span><span class="n">qconj</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">])</span>  <span class="n">mod</span> <span class="n">qmod</span>
</pre></div>
</div>
<p>Here the qindex <code class="docutils literal notranslate"><span class="pre">Qi</span></code> of the pipe corresponds to qindices <code class="docutils literal notranslate"><span class="pre">qi_l</span></code> on the individual legs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nlegs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of legs.</p>
</dd>
<dt><strong>legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The original legs, which were combined in the pipe.</p>
</dd>
<dt><strong>subshape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span></dt>
<dd><p class="first last"><cite>ind_len</cite> for each of the incoming legs.</p>
</dd>
<dt><strong>subqshape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span></dt>
<dd><p class="first last"><cite>block_number</cite> for each of the incoming legs.</p>
</dd>
<dt><strong>q_map:  array[np.intp, ndim=2]</strong></dt>
<dd><p class="first last">Shape (<cite>block_number</cite>, 3 + <cite>nlegs</cite>). Rows: <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">b_j,</span> <span class="pre">b_{j+1},</span> <span class="pre">I_s,</span> <span class="pre">i_1,</span> <span class="pre">...,</span> <span class="pre">i_{nlegs}]</span></code>,
See Notes below for details.</p>
</dd>
<dt><strong>q_map_slices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[np.intp, ndim=1]</span></dt>
<dd><p class="first last">Defined such that the row indices of in
<code class="docutils literal notranslate"><span class="pre">range(q_map_slices[I_s],</span> <span class="pre">q_map_slices[I_s+1])</span></code> have <code class="docutils literal notranslate"><span class="pre">q_map[:,</span> <span class="pre">2]</span> <span class="pre">==</span> <span class="pre">I_s</span></code>.</p>
</dd>
<dt><strong>_perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">A permutation such that <code class="docutils literal notranslate"><span class="pre">q_map[_perm,</span> <span class="pre">3:]</span></code> is sorted by <cite>i_l</cite>.</p>
</dd>
<dt><strong>_strides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">Strides for mapping incoming qindices <cite>i_l</cite> to the index of <code class="docutils literal notranslate"><span class="pre">q_map[_perm,</span> <span class="pre">:]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.bunch" title="tenpy.linalg.np_conserved.LegPipe.bunch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bunch</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Convert to LegCharge and call <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegCharge.bunch()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.charge_sectors" title="tenpy.linalg.np_conserved.LegPipe.charge_sectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">charge_sectors</span></code></a>()</td>
<td>Return unique rows of self.charges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.conj" title="tenpy.linalg.np_conserved.LegPipe.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a>()</td>
<td>Return a shallow copy with opposite <code class="docutils literal notranslate"><span class="pre">self.qconj</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.copy" title="tenpy.linalg.np_conserved.LegPipe.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Return a (shallow) copy of self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.extend" title="tenpy.linalg.np_conserved.LegPipe.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(extra)</td>
<td>Return a new <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a>, which extends self with futher charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_add_charge" title="tenpy.linalg.np_conserved.LegPipe.from_add_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_add_charge</span></code></a>(legs[,&nbsp;chargeinfo])</td>
<td>Add the (independent) charges of two or more legs to get larger <cite>qnumber</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_change_charge" title="tenpy.linalg.np_conserved.LegPipe.from_change_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_change_charge</span></code></a>(leg,&nbsp;charge,&nbsp;new_qmod[,&nbsp;…])</td>
<td>Remove a charge from a LegCharge.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_drop_charge" title="tenpy.linalg.np_conserved.LegPipe.from_drop_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_drop_charge</span></code></a>(leg[,&nbsp;charge,&nbsp;chargeinfo])</td>
<td>Remove a charge from a LegCharge.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_qdict" title="tenpy.linalg.np_conserved.LegPipe.from_qdict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qdict</span></code></a>(chargeinfo,&nbsp;qdict[,&nbsp;qconj])</td>
<td>Create a LegCharge from qdict form.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_qflat" title="tenpy.linalg.np_conserved.LegPipe.from_qflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qflat</span></code></a>(chargeinfo,&nbsp;qflat[,&nbsp;qconj])</td>
<td>Create a LegCharge from qflat form.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_qind" title="tenpy.linalg.np_conserved.LegPipe.from_qind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_qind</span></code></a>(chargeinfo,&nbsp;slices,&nbsp;charges[,&nbsp;qconj])</td>
<td>Just a wrapper around self.__init__(), see class doc-string for parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.from_trivial" title="tenpy.linalg.np_conserved.LegPipe.from_trivial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_trivial</span></code></a>(ind_len[,&nbsp;chargeinfo,&nbsp;qconj])</td>
<td>Create trivial (qnumber=0) LegCharge for given len of indices <cite>ind_len</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.get_charge" title="tenpy.linalg.np_conserved.LegPipe.get_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_charge</span></code></a>(qindex)</td>
<td>Return charge <code class="docutils literal notranslate"><span class="pre">self.charges[qindex]</span> <span class="pre">*</span> <span class="pre">self.qconj</span></code> for a given <cite>qindex</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.get_qindex" title="tenpy.linalg.np_conserved.LegPipe.get_qindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_qindex</span></code></a>(flat_index)</td>
<td>Find qindex containing a flat index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.get_slice" title="tenpy.linalg.np_conserved.LegPipe.get_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice</span></code></a>(qindex)</td>
<td>Return slice selecting the block for a given <cite>qindex</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.is_blocked" title="tenpy.linalg.np_conserved.LegPipe.is_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_blocked</span></code></a>()</td>
<td>Returns whether self is blocked, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.is_bunched" title="tenpy.linalg.np_conserved.LegPipe.is_bunched"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_bunched</span></code></a>()</td>
<td>Checks whether <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.bunch" title="tenpy.linalg.np_conserved.LegPipe.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a> would change something.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.is_sorted" title="tenpy.linalg.np_conserved.LegPipe.is_sorted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_sorted</span></code></a>()</td>
<td>Returns whether <cite>self.charges</cite> is sorted lexiographically.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.map_incoming_flat" title="tenpy.linalg.np_conserved.LegPipe.map_incoming_flat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_incoming_flat</span></code></a>(incoming_indices)</td>
<td>Map (flat) incoming indices to an index in the outgoing pipe.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.outer_conj" title="tenpy.linalg.np_conserved.LegPipe.outer_conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer_conj</span></code></a>()</td>
<td>Like <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.conj" title="tenpy.linalg.np_conserved.LegPipe.conj"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conj()</span></code></a>, but don’t change <code class="docutils literal notranslate"><span class="pre">qconj</span></code> for incoming legs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.perm_flat_from_perm_qind" title="tenpy.linalg.np_conserved.LegPipe.perm_flat_from_perm_qind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perm_flat_from_perm_qind</span></code></a>(perm_qind)</td>
<td>Convert a permutation of qind (acting on self) into a flat permutation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.perm_qind_from_perm_flat" title="tenpy.linalg.np_conserved.LegPipe.perm_qind_from_perm_flat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">perm_qind_from_perm_flat</span></code></a>(perm_flat)</td>
<td>Convert flat permutation into qind permutation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.project" title="tenpy.linalg.np_conserved.LegPipe.project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Convert self to LegCharge and call <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.project" title="tenpy.linalg.np_conserved.LegCharge.project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegCharge.project()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.sort" title="tenpy.linalg.np_conserved.LegPipe.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Convert to LegCharge and call <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="tenpy.linalg.np_conserved.LegCharge.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegCharge.sort()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.test_contractible" title="tenpy.linalg.np_conserved.LegPipe.test_contractible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_contractible</span></code></a>(other)</td>
<td>Raises a ValueError if charges are incompatible for contraction with other.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.test_equal" title="tenpy.linalg.np_conserved.LegPipe.test_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_equal</span></code></a>(other)</td>
<td>Test if charges are <em>equal</em> including <cite>qconj</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.test_sanity" title="tenpy.linalg.np_conserved.LegPipe.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.to_LegCharge" title="tenpy.linalg.np_conserved.LegPipe.to_LegCharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_LegCharge</span></code></a>()</td>
<td>Convert self to a LegCharge, discarding the information how to split the legs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.to_qdict" title="tenpy.linalg.np_conserved.LegPipe.to_qdict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_qdict</span></code></a>()</td>
<td>Return charges in <cite>qdict</cite> form.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.to_qflat" title="tenpy.linalg.np_conserved.LegPipe.to_qflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_qflat</span></code></a>()</td>
<td>Return charges in <cite>qflat</cite> form.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.bunch">
<code class="descname">bunch</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.bunch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.bunch" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to LegCharge and call <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.bunch" title="tenpy.linalg.np_conserved.LegCharge.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegCharge.bunch()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.charge_sectors">
<code class="descname">charge_sectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.charge_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique rows of self.charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>charges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[QTYPE, ndim=2]</span></dt>
<dd><p class="first last">Rows are the rows of self.charges lexsorted and without duplicates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy with opposite <code class="docutils literal notranslate"><span class="pre">self.qconj</span></code>.</p>
<p>Also conjugates each of the incoming legs.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a (shallow) copy of self.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>extra</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a>, which extends self with futher charges.</p>
<p>This is needed to formally increase the dimension of an Array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>extra</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> | int</span></dt>
<dd><p class="first last">By what to extend, i.e. the charges to be appended to <cite>self</cite>.
An int stands for extending the length of the array by a single new block of that size
and zero charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extended_leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">Copy of <cite>self</cite> extended by the charge blocks of the <cite>extra</cite> leg.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_add_charge">
<em class="property">classmethod </em><code class="descname">from_add_charge</code><span class="sig-paren">(</span><em>legs</em>, <em>chargeinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_add_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the (independent) charges of two or more legs to get larger <cite>qnumber</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The legs for which the charges are to be combined/added.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo for all charges; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>combined</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A LegCharge with the charges of both legs. Is neither sorted nor bunched!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_change_charge">
<em class="property">classmethod </em><code class="descname">from_change_charge</code><span class="sig-paren">(</span><em>leg</em>, <em>charge</em>, <em>new_qmod</em>, <em>new_name=''</em>, <em>chargeinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_change_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a charge from a LegCharge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg from which to drop/remove a charge.</p>
</dd>
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) for which <cite>mod</cite> is to be changed.</p>
</dd>
<dt><strong>new_qmod</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The new <cite>mod</cite> to be set for <cite>charge</cite> in the <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a>.</p>
</dd>
<dt><strong>new_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The new name for <cite>charge</cite>.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo with <cite>charge</cite> changed; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A LegCharge with the specified charge changed. Is neither sorted nor bunched!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_drop_charge">
<em class="property">classmethod </em><code class="descname">from_drop_charge</code><span class="sig-paren">(</span><em>leg</em>, <em>charge=None</em>, <em>chargeinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_drop_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a charge from a LegCharge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg from which to drop/remove a charge.</p>
</dd>
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be dropped.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo with <cite>charge</cite> dropped; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dropped</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A LegCharge with the specified charge dropped. Is neither sorted nor bunched!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_qdict">
<em class="property">classmethod </em><code class="descname">from_qdict</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>qdict</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_qdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a LegCharge from qdict form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>qdict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary mapping a tuple of charges to slices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_qflat">
<em class="property">classmethod </em><code class="descname">from_qflat</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>qflat</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_qflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a LegCharge from qflat form.</p>
<p>Does <em>neither</em> bunch <em>nor</em> sort. We recommend to sort (and bunch) afterwards,
if you expect that tensors using the LegCharge have entries at all positions compatible
with the charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>qflat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like (ind_len, <cite>qnumber</cite>)</span></dt>
<dd><p class="first last"><cite>qnumber</cite> charges for each index of the leg on entry.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{-1, 1}</span></dt>
<dd><p class="first last">A flag telling whether the charge points inwards (+1) or outwards (-1).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.sort" title="tenpy.linalg.np_conserved.LegPipe.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a></dt>
<dd>sorts by charges</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.bunch" title="tenpy.linalg.np_conserved.LegPipe.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a></dt>
<dd>bunches contiguous blocks of the same charge.</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_qind">
<em class="property">classmethod </em><code class="descname">from_qind</code><span class="sig-paren">(</span><em>chargeinfo</em>, <em>slices</em>, <em>charges</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_qind" title="Permalink to this definition">¶</a></dt>
<dd><p>Just a wrapper around self.__init__(), see class doc-string for parameters.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.sort" title="tenpy.linalg.np_conserved.LegPipe.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a></dt>
<dd>sorts by charges</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">block</span></code></dt>
<dd>blocks by charges</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.LegPipe.from_trivial">
<em class="property">classmethod </em><code class="descname">from_trivial</code><span class="sig-paren">(</span><em>ind_len</em>, <em>chargeinfo=None</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.from_trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>Create trivial (qnumber=0) LegCharge for given len of indices <cite>ind_len</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.get_charge">
<code class="descname">get_charge</code><span class="sig-paren">(</span><em>qindex</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.get_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return charge <code class="docutils literal notranslate"><span class="pre">self.charges[qindex]</span> <span class="pre">*</span> <span class="pre">self.qconj</span></code> for a given <cite>qindex</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.get_qindex">
<code class="descname">get_qindex</code><span class="sig-paren">(</span><em>flat_index</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.get_qindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Find qindex containing a flat index.</p>
<p>Given a flat index, to find the corresponding entry in an Array, we need to determine the
block it is saved in. For example, if <code class="docutils literal notranslate"><span class="pre">qind[:,</span> <span class="pre">2]</span> <span class="pre">=</span> <span class="pre">[[0,</span> <span class="pre">3],</span> <span class="pre">[3,</span> <span class="pre">7],</span> <span class="pre">[7,</span> <span class="pre">12]]</span></code>,
the flat index <code class="docutils literal notranslate"><span class="pre">5</span></code> corresponds to the second entry, <code class="docutils literal notranslate"><span class="pre">qindex</span> <span class="pre">=</span> <span class="pre">1</span></code> (since 5 is in [3:7]),
and the index within the block would be <code class="docutils literal notranslate"><span class="pre">5-3</span> <span class="pre">=2</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>flat_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">A flat index of the leg. Negative index counts from behind.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qindex</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The qindex, i.e. the index of the block containing <cite>flat_index</cite>.</p>
</dd>
<dt><strong>index_within_block</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The index of <cite>flat_index</cite> within the block given by <cite>qindex</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.get_slice">
<code class="descname">get_slice</code><span class="sig-paren">(</span><em>qindex</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.get_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice selecting the block for a given <cite>qindex</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.is_blocked">
<code class="descname">is_blocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.is_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether self is blocked, i.e. qindex map 1:1 to charge values.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.is_bunched">
<code class="descname">is_bunched</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.is_bunched" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.bunch" title="tenpy.linalg.np_conserved.LegPipe.bunch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bunch()</span></code></a> would change something.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.is_sorted">
<code class="descname">is_sorted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.is_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <cite>self.charges</cite> is sorted lexiographically.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.map_incoming_flat">
<code class="descname">map_incoming_flat</code><span class="sig-paren">(</span><em>incoming_indices</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.map_incoming_flat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.map_incoming_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Map (flat) incoming indices to an index in the outgoing pipe.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>incoming_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">One (flat) index on each of the incoming legs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>outgoing_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The index in the outgoing leg.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.outer_conj">
<code class="descname">outer_conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.outer_conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.outer_conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.conj" title="tenpy.linalg.np_conserved.LegPipe.conj"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conj()</span></code></a>, but don’t change <code class="docutils literal notranslate"><span class="pre">qconj</span></code> for incoming legs.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.perm_flat_from_perm_qind">
<code class="descname">perm_flat_from_perm_qind</code><span class="sig-paren">(</span><em>perm_qind</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.perm_flat_from_perm_qind" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a permutation of qind (acting on self) into a flat permutation.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.perm_qind_from_perm_flat">
<code class="descname">perm_qind_from_perm_flat</code><span class="sig-paren">(</span><em>perm_flat</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.perm_qind_from_perm_flat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert flat permutation into qind permutation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm_flat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">A permutation acting on self, which doesn’t mix the blocks of qind.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm_qind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">The permutation of self.qind described by perm_flat.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">If perm_flat mixes blocks of different qindex.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self to LegCharge and call <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.project" title="tenpy.linalg.np_conserved.LegCharge.project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegCharge.project()</span></code></a>.</p>
<p>In general, this could be implemented for a LegPipe, but would make
<a class="reference internal" href="#tenpy.linalg.np_conserved.Array.split_legs" title="tenpy.linalg.np_conserved.Array.split_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split_legs()</span></code></a> more complicated, thus we keep it
simple.  If you really want to project and split afterwards, use the following work-around,
which is for example used in <code class="xref py py-class docutils literal notranslate"><span class="pre">exact_diagonalization</span></code>:</p>
<ol class="arabic simple">
<li>Create the full pipe and save it separetely.</li>
<li>Convert the Pipe to a Leg &amp; project the array with it.</li>
<li>[… do calculations …]</li>
<li>To split the ‘projected pipe’ of <cite>A</cite>, create and empty array <cite>B</cite> with the legs of A,
but replace the projected leg by the full pipe. Set <cite>A</cite> as a slice of <cite>B</cite>.
Finally split the pipe.</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to LegCharge and call <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge.sort" title="tenpy.linalg.np_conserved.LegCharge.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LegCharge.sort()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.test_contractible">
<code class="descname">test_contractible</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.test_contractible" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises a ValueError if charges are incompatible for contraction with other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The LegCharge of the other leg condsidered for contraction.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">If the charges are incompatible for direct contraction.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.test_equal" title="tenpy.linalg.np_conserved.LegPipe.test_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_equal</span></code></a></dt>
<dd><code class="docutils literal notranslate"><span class="pre">self.test_contractible(other)</span></code> just performs <code class="docutils literal notranslate"><span class="pre">self.test_equal(other.conj())</span></code>.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function checks that two legs are <cite>ready</cite> for contraction.
This is the case, if all of the following conditions are met:</p>
<ul>
<li><p class="first">the <code class="docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is equal</p>
</li>
<li><p class="first">the <cite>slices</cite> are equal</p>
</li>
<li><p class="first">the <cite>charges</cite> are the same up to <em>opposite</em> signs <code class="docutils literal notranslate"><span class="pre">qconj</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qconj</span> <span class="o">=</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">qconj</span>
</pre></div>
</div>
</li>
</ul>
<p>In general, there could also be a change of the total charge, see <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>
This special case is not considered here - instead use
<code class="xref py py-meth docutils literal notranslate"><span class="pre">gauge_total_charge()</span></code>,
if a change of the charge is desired.</p>
<p>If you are sure that the legs should be contractable,
check whether the charges are actually valid
or whether <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are blocked or should be sorted.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.test_equal">
<code class="descname">test_equal</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.test_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if charges are <em>equal</em> including <cite>qconj</cite>.</p>
<p>Check that all of the following conditions are met:</p>
<ul>
<li><p class="first">the <code class="docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is equal</p>
</li>
<li><p class="first">the <cite>slices</cite> are equal</p>
</li>
<li><p class="first">the <cite>charges</cite> are the same up to the signs <code class="docutils literal notranslate"><span class="pre">qconj</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qconj</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">charges</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">qconj</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe.test_contractible" title="tenpy.linalg.np_conserved.LegPipe.test_contractible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_contractible</span></code></a></dt>
<dd><code class="docutils literal notranslate"><span class="pre">self.test_equal(other)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">self.test_contractible(other.conj())</span></code>.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.to_LegCharge">
<code class="descname">to_LegCharge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/charges.html#LegPipe.to_LegCharge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.to_LegCharge" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self to a LegCharge, discarding the information how to split the legs.
Usually not needed, but called by functions, which are not implemented for a LegPipe.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.to_qdict">
<code class="descname">to_qdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.to_qdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return charges in <cite>qdict</cite> form. Raises ValueError, if not blocked.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.LegPipe.to_qflat">
<code class="descname">to_qflat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.linalg.np_conserved.LegPipe.to_qflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return charges in <cite>qflat</cite> form.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.linalg.np_conserved.Array">
<em class="property">class </em><code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">Array</code><span class="sig-paren">(</span><em>legcharges</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A multidimensional array (=tensor) for using charge conservation.</p>
<p>An <cite>Array</cite> represents a multi-dimensional tensor,
together with the charge structure of its legs (for abelian charges).
Further information can be found in <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
<p>The default <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> (i.e. <code class="docutils literal notranslate"><span class="pre">Array(...)</span></code>) does not insert any data,
and thus yields an Array ‘full’ of zeros, equivalent to <a class="reference internal" href="#tenpy.linalg.np_conserved.zeros" title="tenpy.linalg.np_conserved.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>.
Further, new arrays can be created with one of <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="tenpy.linalg.np_conserved.Array.from_ndarray_trivial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ndarray_trivial()</span></code></a>,
<a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ndarray()</span></code></a>, or <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func" title="tenpy.linalg.np_conserved.Array.from_func"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_func()</span></code></a>, and of course by copying/tensordot/svd etc.</p>
<p>In-place methods are indicated by a name starting with <code class="docutils literal notranslate"><span class="pre">i</span></code>.
(But <cite>is_completely_blocked</cite> is not inplace…)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>legcharges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg charges for each of the legs. The <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> is read out from it.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type or string</span></dt>
<dd><p class="first last">The data type of the array entries. Defaults to np.float64.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array of QTYPE</span></dt>
<dd><p class="first last">The total charge of the array. Defaults to 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.size" title="tenpy.linalg.np_conserved.Array.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></dt>
<dd><p class="first last">The number of dtype-objects stored.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.stored_blocks" title="tenpy.linalg.np_conserved.Array.stored_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stored_blocks</span></code></a></dt>
<dd><p class="first last">The number of (non-zero) blocks stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">_data</span></code>.</p>
</dd>
<dt><strong>rank</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The rank or “number of dimensions”, equivalent to <code class="docutils literal notranslate"><span class="pre">len(shape)</span></code>.</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple(int)</span></dt>
<dd><p class="first last">The number of indices for each of the legs.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.dtype</span></dt>
<dd><p class="first last">The data type of the entries.</p>
</dd>
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.ChargeInfo" title="tenpy.linalg.charges.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">The total charge of the tensor.</p>
</dd>
<dt><strong>legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg charges for each of the legs.</p>
</dd>
<dt><strong>labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict (string -&gt; int)</span></dt>
<dd><p class="first last">Labels for the different legs.</p>
</dd>
<dt><strong>_data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd><p class="first last">The actual entries of the tensor.</p>
</dd>
<dt><strong>_qdata</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array (len(_data), rank), dtype np.intp</span></dt>
<dd><p class="first last">For each of the _data entries the qindices of the different legs.</p>
</dd>
<dt><strong>_qdata_sorted</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Bool</span></dt>
<dd><p class="first last">Whether self._qdata is lexsorted. Defaults to <cite>True</cite>,
but <em>must</em> be set to <cite>False</cite> by algorithms changing _qdata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_charge" title="tenpy.linalg.np_conserved.Array.add_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_charge</span></code></a>(add_legs[,&nbsp;chinfo,&nbsp;qtotal])</td>
<td>Add charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_leg" title="tenpy.linalg.np_conserved.Array.add_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_leg</span></code></a>(leg,&nbsp;i[,&nbsp;axis,&nbsp;label])</td>
<td>Add a leg to <cite>self</cite>, setting the current array as slice for a given index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_trivial_leg" title="tenpy.linalg.np_conserved.Array.add_trivial_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_trivial_leg</span></code></a>([axis,&nbsp;label,&nbsp;qconj])</td>
<td>Add a trivial leg (with just one entry) to <cite>self</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.as_completely_blocked" title="tenpy.linalg.np_conserved.Array.as_completely_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_completely_blocked</span></code></a>()</td>
<td>Gives a version of self which is completely blocked by charges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.astype" title="tenpy.linalg.np_conserved.Array.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(dtype[,&nbsp;copy])</td>
<td>Return copy with new dtype, upcasting all blocks in <code class="docutils literal notranslate"><span class="pre">_data</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.binary_blockwise" title="tenpy.linalg.np_conserved.Array.binary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_blockwise</span></code></a>(func,&nbsp;other,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.change_charge" title="tenpy.linalg.np_conserved.Array.change_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">change_charge</span></code></a>(charge,&nbsp;new_qmod[,&nbsp;new_name,&nbsp;…])</td>
<td>Change the <cite>qmod</cite> of one charge in <cite>chinfo</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_legs</span></code></a>(combine_legs[,&nbsp;new_axes,&nbsp;…])</td>
<td>Reshape: combine multiple legs into multiple pipes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.complex_conj" title="tenpy.linalg.np_conserved.Array.complex_conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_conj</span></code></a>()</td>
<td>Return copy which is complex conjugated <em>without</em> conjugating the charge data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.conj" title="tenpy.linalg.np_conserved.Array.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a>([complex_conj,&nbsp;inplace])</td>
<td>Conjugate: complex conjugate data, conjugate charge data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.copy" title="tenpy.linalg.np_conserved.Array.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([deep])</td>
<td>Return a (deep or shallow) copy of self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.drop_charge" title="tenpy.linalg.np_conserved.Array.drop_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_charge</span></code></a>([charge,&nbsp;chinfo])</td>
<td>Drop (one of) the charges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.extend" title="tenpy.linalg.np_conserved.Array.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(axis,&nbsp;extra)</td>
<td>Increase the dimension of a given axis, filling the values with zeros.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func" title="tenpy.linalg.np_conserved.Array.from_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_func</span></code></a>(func,&nbsp;legcharges[,&nbsp;dtype,&nbsp;qtotal,&nbsp;…])</td>
<td>Create an Array from a numpy func.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func_square" title="tenpy.linalg.np_conserved.Array.from_func_square"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_func_square</span></code></a>(func,&nbsp;leg[,&nbsp;dtype,&nbsp;…])</td>
<td>Create an Array from a (numpy) function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_ndarray</span></code></a>(data_flat,&nbsp;legcharges[,&nbsp;dtype,&nbsp;…])</td>
<td>convert a flat (numpy) ndarray to an Array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="tenpy.linalg.np_conserved.Array.from_ndarray_trivial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_ndarray_trivial</span></code></a>(data_flat[,&nbsp;dtype])</td>
<td>convert a flat numpy ndarray to an Array with trivial charge conservation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.gauge_total_charge" title="tenpy.linalg.np_conserved.Array.gauge_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_total_charge</span></code></a>(axis[,&nbsp;newqtotal,&nbsp;new_qconj])</td>
<td>Changes the total charge by adjusting the charge on a certain leg.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg" title="tenpy.linalg.np_conserved.Array.get_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg</span></code></a>(label)</td>
<td>Return <code class="docutils literal notranslate"><span class="pre">self.legs[self.get_leg_index(label)]</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_index" title="tenpy.linalg.np_conserved.Array.get_leg_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_index</span></code></a>(label)</td>
<td>translate a leg-index or leg-label to a leg-index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_indices" title="tenpy.linalg.np_conserved.Array.get_leg_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_indices</span></code></a>(labels)</td>
<td>Translate a list of leg-indices or leg-labels to leg indices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_labels" title="tenpy.linalg.np_conserved.Array.get_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_labels</span></code></a>()</td>
<td>Return list of the leg labels, with <cite>None</cite> for anonymous legs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iadd_prefactor_other" title="tenpy.linalg.np_conserved.Array.iadd_prefactor_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iadd_prefactor_other</span></code></a>(prefactor,&nbsp;other)</td>
<td><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">+=</span> <span class="pre">prefactor</span> <span class="pre">*</span> <span class="pre">other</span></code> for scalar <cite>prefactor</cite> and <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> <cite>other</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ibinary_blockwise" title="tenpy.linalg.np_conserved.Array.ibinary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ibinary_blockwise</span></code></a>(func,&nbsp;other,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iconj" title="tenpy.linalg.np_conserved.Array.iconj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iconj</span></code></a>([complex_conj])</td>
<td>Wraper around <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.conj()</span></code> with <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.idrop_labels" title="tenpy.linalg.np_conserved.Array.idrop_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">idrop_labels</span></code></a>([old_labels])</td>
<td>Remove leg labels from self.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iproject" title="tenpy.linalg.np_conserved.Array.iproject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iproject</span></code></a>(mask,&nbsp;axes)</td>
<td>Applying masks to one or multiple axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ipurge_zeros" title="tenpy.linalg.np_conserved.Array.ipurge_zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ipurge_zeros</span></code></a>([cutoff,&nbsp;norm_order])</td>
<td>Removes <code class="docutils literal notranslate"><span class="pre">self._data</span></code> blocks with <em>norm</em> less than cutoff.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ireplace_label" title="tenpy.linalg.np_conserved.Array.ireplace_label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ireplace_label</span></code></a>(old_label,&nbsp;new_label)</td>
<td>Replace the leg label <cite>old_label</cite> with <cite>new_label</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ireplace_labels" title="tenpy.linalg.np_conserved.Array.ireplace_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ireplace_labels</span></code></a>(old_labels,&nbsp;new_labels)</td>
<td>Replace leg label <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> with <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.is_completely_blocked" title="tenpy.linalg.np_conserved.Array.is_completely_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_completely_blocked</span></code></a>()</td>
<td>Return bool whether all legs are blocked by charge.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="tenpy.linalg.np_conserved.Array.iscale_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscale_axis</span></code></a>(s[,&nbsp;axis])</td>
<td>Scale with varying values along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_prefactor" title="tenpy.linalg.np_conserved.Array.iscale_prefactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscale_prefactor</span></code></a>(prefactor)</td>
<td><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*=</span> <span class="pre">prefactor</span></code> for scalar <cite>prefactor</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="tenpy.linalg.np_conserved.Array.iset_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iset_leg_labels</span></code></a>(labels)</td>
<td>Set labels for the different axes/legs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.isort_qdata" title="tenpy.linalg.np_conserved.Array.isort_qdata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isort_qdata</span></code></a>()</td>
<td>(Lexiographically) sort <code class="docutils literal notranslate"><span class="pre">self._qdata</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iswapaxes" title="tenpy.linalg.np_conserved.Array.iswapaxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iswapaxes</span></code></a>(axis1,&nbsp;axis2)</td>
<td>Similar as <code class="docutils literal notranslate"><span class="pre">np.swapaxes</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.itranspose" title="tenpy.linalg.np_conserved.Array.itranspose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itranspose</span></code></a>([axes])</td>
<td>Transpose axes like <cite>np.transpose</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iunary_blockwise" title="tenpy.linalg.np_conserved.Array.iunary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iunary_blockwise</span></code></a>(func,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">f(self)</span></code>, block-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.make_pipe" title="tenpy.linalg.np_conserved.Array.make_pipe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_pipe</span></code></a>(axes,&nbsp;**kwargs)</td>
<td>Generates a <a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> for specified axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.matvec" title="tenpy.linalg.np_conserved.Array.matvec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matvec</span></code></a>(other)</td>
<td>This function is used by the Lanczos algorithm needed for DMRG.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.norm" title="tenpy.linalg.np_conserved.Array.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([ord,&nbsp;convert_to_float])</td>
<td>Norm of flattened data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.permute" title="tenpy.linalg.np_conserved.Array.permute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute</span></code></a>(perm,&nbsp;axis)</td>
<td>Apply a permutation in the indices of an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.replace_label" title="tenpy.linalg.np_conserved.Array.replace_label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_label</span></code></a>(old_label,&nbsp;new_label)</td>
<td>Return a shallow copy with the leg label <cite>old_label</cite> replaced by <cite>new_label</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.replace_labels" title="tenpy.linalg.np_conserved.Array.replace_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_labels</span></code></a>(old_labels,&nbsp;new_labels)</td>
<td>Return a shallow copy with <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> replaced by <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.scale_axis" title="tenpy.linalg.np_conserved.Array.scale_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_axis</span></code></a>(s[,&nbsp;axis])</td>
<td>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="tenpy.linalg.np_conserved.Array.iscale_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iscale_axis()</span></code></a>, but return a (deep) copy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_legcharge</span></code></a>([sort,&nbsp;bunch])</td>
<td>Return a copy with one or all legs sorted by charges.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sparse_stats" title="tenpy.linalg.np_conserved.Array.sparse_stats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_stats</span></code></a>()</td>
<td>Returns a string detailing the sparse statistics</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.split_legs" title="tenpy.linalg.np_conserved.Array.split_legs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_legs</span></code></a>([axes,&nbsp;cutoff])</td>
<td>Reshape: opposite of combine_legs: split (some) legs which are LegPipes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.squeeze" title="tenpy.linalg.np_conserved.Array.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>([axes])</td>
<td>Like <code class="docutils literal notranslate"><span class="pre">np.squeeze</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.take_slice" title="tenpy.linalg.np_conserved.Array.take_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take_slice</span></code></a>(indices,&nbsp;axes)</td>
<td>Return a copy of self fixing <cite>indices</cite> along one or multiple <cite>axes</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.test_sanity" title="tenpy.linalg.np_conserved.Array.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.to_ndarray" title="tenpy.linalg.np_conserved.Array.to_ndarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_ndarray</span></code></a>()</td>
<td>Convert self to a dense numpy ndarray.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.transpose" title="tenpy.linalg.np_conserved.Array.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>([axes])</td>
<td>Like <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.itranspose" title="tenpy.linalg.np_conserved.Array.itranspose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itranspose()</span></code></a>, but on a deep copy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.unary_blockwise" title="tenpy.linalg.np_conserved.Array.unary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unary_blockwise</span></code></a>(func,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self)</span></code>, block-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.zeros_like" title="tenpy.linalg.np_conserved.Array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a>()</td>
<td>Return a copy of self with only zeros as entries, containing no <cite>_data</cite>.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.add_charge">
<code class="descname">add_charge</code><span class="sig-paren">(</span><em>add_legs</em>, <em>chinfo=None</em>, <em>qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.add_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.add_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>add_legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">One <cite>LegCharge</cite> for each axis of <cite>self</cite>, to be added to the one in <code class="xref py py-attr docutils literal notranslate"><span class="pre">legs</span></code>.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The ChargeInfo for all charges; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | charges</span></dt>
<dd><p class="first last">The total charge with respect to <cite>add_legs</cite>.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, derive it from non-zero entries of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>charges_added</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of <cite>self</cite>, where the LegCharges <cite>add_legs</cite> where added to <cite>self.legs</cite>.
Note that the LegCharges are neither bunched or sorted;
you might want to use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.add_leg">
<code class="descname">add_leg</code><span class="sig-paren">(</span><em>leg</em>, <em>i</em>, <em>axis=0</em>, <em>label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.add_leg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.add_leg" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a leg to <cite>self</cite>, setting the current array as slice for a given index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The charge data of the leg to be added.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index within the leg for which the data of <cite>self</cite> should be set.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">axis</span></dt>
<dd><p class="first last">The new leg is inserted before this current axis.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, use it as label for the new leg.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extended</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of self with the new <cite>leg</cite> at axis <cite>axis</cite> , such that
<code class="docutils literal notranslate"><span class="pre">extended.take_slice(i,</span> <span class="pre">axis)</span></code> returns a copy of <cite>self</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.take_slice" title="tenpy.linalg.np_conserved.Array.take_slice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">take_slice()</span></code></a></dt>
<dd>opposite action reducing the number of legs.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.add_trivial_leg">
<code class="descname">add_trivial_leg</code><span class="sig-paren">(</span><em>axis=0</em>, <em>label=None</em>, <em>qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.add_trivial_leg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.add_trivial_leg" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trivial leg (with just one entry) to <cite>self</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The new leg is inserted before index <cite>axis</cite>.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, use it as label for the new leg.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">+1 | -1</span></dt>
<dd><p class="first last">The direction of the new leg.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extended</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A (possibly) <em>shallow</em> copy of self with an additional leg of ind_len 1 and charge 0.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.as_completely_blocked">
<code class="descname">as_completely_blocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.as_completely_blocked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.as_completely_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a version of self which is completely blocked by charges.</p>
<p>Functions like <a class="reference internal" href="#tenpy.linalg.np_conserved.svd" title="tenpy.linalg.np_conserved.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a> or <a class="reference internal" href="#tenpy.linalg.np_conserved.eigh" title="tenpy.linalg.np_conserved.eigh"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigh()</span></code></a> require a complete blocking by charges.
This can be achieved by encapsulating each leg which is not completely blocked into a
<a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe" title="tenpy.linalg.np_conserved.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> (containing only that single leg). The LegPipe will then contain all
necessary information to revert the blocking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>encapsulated_axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">The leg indices which have been encapsulated into Pipes.</p>
</dd>
<dt><strong>blocked_self</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Self (if <code class="docutils literal notranslate"><span class="pre">len(encapsulated_axes)</span> <span class="pre">=</span> <span class="pre">0</span></code>) or a copy of self,
which is completely blocked.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>dtype</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.astype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy with new dtype, upcasting all blocks in <code class="docutils literal notranslate"><span class="pre">_data</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">convertible to a np.dtype</span></dt>
<dd><p class="first last">The new data type.
If None, deduce the new dtype as common type of <code class="docutils literal notranslate"><span class="pre">self._data</span></code>.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to make a copy of the blocks even if the type didn’t change.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Deep copy of self with new dtype.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.binary_blockwise">
<code class="descname">binary_blockwise</code><span class="sig-paren">(</span><em>func</em>, <em>other</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.binary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.binary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise. Copies.</p>
<p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ibinary_blockwise" title="tenpy.linalg.np_conserved.Array.ibinary_blockwise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ibinary_blockwise()</span></code></a>, but makes a <strong>shallow</strong> copy first.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.change_charge">
<code class="descname">change_charge</code><span class="sig-paren">(</span><em>charge</em>, <em>new_qmod</em>, <em>new_name=''</em>, <em>chinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.change_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.change_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the <cite>qmod</cite> of one charge in <cite>chinfo</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be changed.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
<dt><strong>new_qmod</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The new <cite>qmod</cite> to be set.</p>
</dd>
<dt><strong>new_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The new name of the charge.</p>
</dd>
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> with <cite>qmod</cite> of <cite>charge</cite> changed; create a new one if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>changed</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of <cite>self</cite>, where the <cite>qmod</cite> of the specified <cite>charge</cite> has been changed.
Note that the LegCharges are neither bunched or sorted;
you might want to use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.combine_legs">
<code class="descname">combine_legs</code><span class="sig-paren">(</span><em>combine_legs</em>, <em>new_axes=None</em>, <em>pipes=None</em>, <em>qconj=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.combine_legs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape: combine multiple legs into multiple pipes. If necessary, transpose before.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>combine_legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) iterable of {str|int}</span></dt>
<dd><p class="first last">Bundles of leg indices or labels, which should be combined into a new output pipes.
If multiple pipes should be created, use a list fore each new pipe.</p>
</dd>
<dt><strong>new_axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (iterable of) int</span></dt>
<dd><p class="first last">The leg-indices, at which the combined legs should appear in the resulting array.
Default: for each pipe the position of its first pipe in the original array,
(taking into account that some axes are ‘removed’ by combining).
Thus no transposition is perfomed if <cite>combine_legs</cite> contains only contiguous ranges.</p>
</dd>
<dt><strong>pipes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (iterable of) {<code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipes</span></code> | None}</span></dt>
<dd><p class="first last">Optional: provide one or multiple of the resulting LegPipes to avoid overhead of
computing new leg pipes for the same legs multiple times.
The LegPipes are conjugated, if that is necessary for compatibility with the legs.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) {+1, -1}</span></dt>
<dd><p class="first last">Specify whether new created pipes point inward or outward. Defaults to +1.
Ignored for given <cite>pipes</cite>, which are not newly calculated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reshaped</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of self, whith some legs combined into pipes as specified by the arguments.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.split_legs" title="tenpy.linalg.np_conserved.Array.split_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split_legs()</span></code></a></dt>
<dd>inverse reshaping splitting LegPipes.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Labels are inherited from self.
New pipe labels are generated as <code class="docutils literal notranslate"><span class="pre">'('</span> <span class="pre">+</span> <span class="pre">'.'.join(*leglabels)</span> <span class="pre">+</span> <span class="pre">')'</span></code>.
For these new labels, previously unlabeled legs are replaced by <code class="docutils literal notranslate"><span class="pre">'?#'</span></code>,
where <code class="docutils literal notranslate"><span class="pre">#</span></code> is the leg-index in the original tensor <cite>self</cite>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oldarray</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">oldarray</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># only single output pipe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;(b.c)&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>Indices of <cite>combine_legs</cite> refer to the original array.
If transposing is necessary, it is performed automatically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">oldarray</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># two output pipes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;(a.d)&#39;, &#39;c&#39;, &#39;(e.b)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">oldarray</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="n">pipes</span><span class="o">=</span><span class="p">[</span><span class="n">c2</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c2</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;b&#39;, &#39;(e.b)&#39;, &#39;(a.d)&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.complex_conj">
<code class="descname">complex_conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.complex_conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.complex_conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy which is complex conjugated <em>without</em> conjugating the charge data.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><em>complex_conj=True</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate: complex conjugate data, conjugate charge data.</p>
<p>Conjugate all legs, set negative qtotal.</p>
<p>Labeling: takes ‘a’ -&gt; ‘a*’, ‘a*’-&gt; ‘a’ and
‘(a,(b*,c))’ -&gt; ‘(a*, (b, c*))’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>complex_conj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the data should be complex conjugated.</p>
</dd>
<dt><strong>inplace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to apply changes to <cite>self</cite>, or to return a <em>deep</em> copy.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a (deep or shallow) copy of self.</p>
<p><strong>Both</strong> deep and shallow copies will share <code class="docutils literal notranslate"><span class="pre">chinfo</span></code> and the <cite>LegCharges</cite> in <code class="docutils literal notranslate"><span class="pre">legs</span></code>.</p>
<p>In contrast to a deep copy, the shallow copy will also share the tensor entries,
namely the <em>same</em> instances of <code class="docutils literal notranslate"><span class="pre">_qdata</span></code> and <code class="docutils literal notranslate"><span class="pre">_data</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
(and other ‘immutable’ properties like the shape or dtype).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shallow copies are <em>not</em> recommended unless you know the consequences!
See the following examples illustrating some of the pitfalls.</p>
</div>
<p class="rubric">Examples</p>
<p>Be (very!) careful when making non-deep copies: In the following example,
the original <cite>a</cite> is changed if and only if the corresponding block existed in <cite>a</cite> before.
&gt;&gt;&gt; b = a.copy(deep=False)  # shallow copy
&gt;&gt;&gt; b[1, 2] = 4.</p>
<p>Other <cite>inplace</cite> operations might have no effect at all (although we don’t guarantee that):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># has no effect on `b`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">iconj</span><span class="p">()</span>  <span class="c1"># nor does this change `a`</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.drop_charge">
<code class="descname">drop_charge</code><span class="sig-paren">(</span><em>charge=None</em>, <em>chinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.drop_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.drop_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop (one of) the charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be dropped.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
<dt><strong>chinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> with <cite>charge</cite> dropped; create a new one if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dropped</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of <cite>self</cite>, where the specified <cite>charge</cite> has been removed.
Note that the LegCharges are neither bunched or sorted;
you might want to use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>axis</em>, <em>extra</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.extend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase the dimension of a given axis, filling the values with zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">The axis (or axis-label) to be extended.</p>
</dd>
<dt><strong>extra</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> | int</span></dt>
<dd><p class="first last">By what to extend, i.e. the charges to be appended to the leg of <cite>axis</cite>.
An int stands for extending the length of the array by a single new block of that size
with zero charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>extended</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of self with the specified axis increased.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.Array.from_func">
<em class="property">classmethod </em><code class="descname">from_func</code><span class="sig-paren">(</span><em>func</em>, <em>legcharges</em>, <em>dtype=None</em>, <em>qtotal=None</em>, <em>func_args=()</em>, <em>func_kwargs={}</em>, <em>shape_kw=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Array from a numpy func.</p>
<p>This function creates an array and fills the blocks <em>compatible</em> with the charges
using <cite>func</cite>, where <cite>func</cite> is a function returning a <cite>array_like</cite> when given a shape,
e.g. one of <code class="docutils literal notranslate"><span class="pre">np.ones</span></code> or <code class="docutils literal notranslate"><span class="pre">np.random.standard_normal</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">A function-like object which is called to generate the data blocks.
We expect that <cite>func</cite> returns a flat array of the given <cite>shape</cite> convertible to <cite>dtype</cite>.
If no <cite>shape_kw</cite> is given, it is called like <code class="docutils literal notranslate"><span class="pre">func(shape,</span> <span class="pre">*fargs,</span> <span class="pre">**fkwargs)</span></code>,
otherwise as <code class="docutils literal notranslate"><span class="pre">func(*fargs,</span> <span class="pre">`shape_kw`=shape,</span> <span class="pre">**fkwargs)</span></code>.
<cite>shape</cite> is a tuple of int.</p>
</dd>
<dt><strong>legcharges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg charges for each of the legs. The <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> is read out from it.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | type | string</span></dt>
<dd><p class="first last">The data type of the output entries. Defaults to np.float64.
Defaults to <cite>None</cite>: obtain it from the return value of the function.
Note that this argument is not given to func, but rather a type conversion
is performed afterwards. You might want to set a <cite>dtype</cite> in <cite>func_kwargs</cite> as well.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | charges</span></dt>
<dd><p class="first last">The total charge of the new array. Defaults to charge 0.</p>
</dd>
<dt><strong>func_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd><p class="first last">Additional arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>func_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional keyword arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>shape_kw</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">If given, the keyword with which shape is given to <cite>func</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">An Array with blocks filled using <cite>func</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.Array.from_func_square">
<em class="property">classmethod </em><code class="descname">from_func_square</code><span class="sig-paren">(</span><em>func</em>, <em>leg</em>, <em>dtype=None</em>, <em>func_args=()</em>, <em>func_kwargs={}</em>, <em>shape_kw=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_func_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_func_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Array from a (numpy) function.</p>
<p>This function creates an array and fills the blocks <em>compatible</em> with the charges
using <cite>func</cite>, where <cite>func</cite> is a function returning a <cite>array_like</cite> when given a shape,
e.g. one of <code class="docutils literal notranslate"><span class="pre">np.ones</span></code> or <code class="docutils literal notranslate"><span class="pre">np.random.standard_normal</span></code> or the functions defined in
<a class="reference internal" href="tenpy.linalg.random_matrix.html#module-tenpy.linalg.random_matrix" title="tenpy.linalg.random_matrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">random_matrix</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">A function-like object which is called to generate the data blocks.
We expect that <cite>func</cite> returns a flat array of the given <cite>shape</cite> convertible to <cite>dtype</cite>.
If no <cite>shape_kw</cite> is given, it is called like <code class="docutils literal notranslate"><span class="pre">func(shape,</span> <span class="pre">*fargs,</span> <span class="pre">**fkwargs)</span></code>,
otherwise as <code class="docutils literal notranslate"><span class="pre">func(*fargs,</span> <span class="pre">`shape_kw`=shape,</span> <span class="pre">**fkwargs)</span></code>.
<cite>shape</cite> is a tuple of int.</p>
</dd>
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg charges for the first leg; the second leg is set to <code class="docutils literal notranslate"><span class="pre">leg.conj()</span></code>.
The <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> is read out from it.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | type | string</span></dt>
<dd><p class="first last">The data type of the output entries.
Defaults to <cite>None</cite>: obtain it from the return value of the function.
Note that this argument is not given to func, but rather a type conversion
is performed afterwards. You might want to set a <cite>dtype</cite> in <cite>func_kwargs</cite> as well.</p>
</dd>
<dt><strong>func_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd><p class="first last">Additional arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>func_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Additional keyword arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>shape_kw</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">If given, the keyword with which shape is given to <cite>func</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">An Array with blocks filled using <cite>func</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.Array.from_ndarray">
<em class="property">classmethod </em><code class="descname">from_ndarray</code><span class="sig-paren">(</span><em>data_flat</em>, <em>legcharges</em>, <em>dtype=None</em>, <em>qtotal=None</em>, <em>cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_ndarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a flat (numpy) ndarray to an Array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data_flat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The flat ndarray which should be converted to a npc <cite>Array</cite>.
The shape has to be compatible with legcharges.</p>
</dd>
<dt><strong>legcharges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The leg charges for each of the legs. The <a class="reference internal" href="#tenpy.linalg.np_conserved.ChargeInfo" title="tenpy.linalg.np_conserved.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a> is read out from it.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">np.dtype</span></code> | string</span></dt>
<dd><p class="first last">The data type of the array entries. Defaults to dtype of data_flat.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | charges</span></dt>
<dd><p class="first last">The total charge of the new array.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Blocks with <code class="docutils literal notranslate"><span class="pre">np.max(np.abs(block))</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code> are considered as zero.
Defaults to <a class="reference internal" href="#tenpy.linalg.np_conserved.QCUTOFF" title="tenpy.linalg.np_conserved.QCUTOFF"><code class="xref py py-data docutils literal notranslate"><span class="pre">QCUTOFF</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">An Array with data of <cite>data_flat</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_qtotal" title="tenpy.linalg.np_conserved.detect_qtotal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_qtotal</span></code></a></dt>
<dd>used to detect <code class="docutils literal notranslate"><span class="pre">qtotal</span></code> if not given.</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.linalg.np_conserved.Array.from_ndarray_trivial">
<em class="property">classmethod </em><code class="descname">from_ndarray_trivial</code><span class="sig-paren">(</span><em>data_flat</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_ndarray_trivial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a flat numpy ndarray to an Array with trivial charge conservation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data_flat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The data to be converted to a Array.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type | string</span></dt>
<dd><p class="first last">The data type of the array entries. Defaults to <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">An Array with data of data_flat.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.gauge_total_charge">
<code class="descname">gauge_total_charge</code><span class="sig-paren">(</span><em>axis</em>, <em>newqtotal=None</em>, <em>new_qconj=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.gauge_total_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.gauge_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the total charge by adjusting the charge on a certain leg.</p>
<p>The total charge is given by finding a nonzero entry [i1, i2, …] and calculating:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">qi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Thus, the total charge can be changed by redefining (= shifting) the LegCharge
of a single given leg. This is exaclty what this function does.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or string</span></dt>
<dd><p class="first last">The new leg (index or label), for which the charge is changed.</p>
</dd>
<dt><strong>newqtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charge values, defaults to 0</span></dt>
<dd><p class="first last">The new total charge.</p>
</dd>
<dt><strong>new_qconj: {+1, -1, None}</strong></dt>
<dd><p class="first last">Whether the new LegCharge points inward (+1) or outward (-1) afterwards.
By default (None) use the previous <code class="docutils literal notranslate"><span class="pre">self.legs[leg].qconj</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A shallow copy of self with <code class="docutils literal notranslate"><span class="pre">copy.qtotal</span> <span class="pre">==</span> <span class="pre">newqtotal</span></code> and new <code class="docutils literal notranslate"><span class="pre">copy.legs[leg]</span></code>.
The new leg will be a :class`LegCharge`, even if the old leg was a <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe" title="tenpy.linalg.np_conserved.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg">
<code class="descname">get_leg</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">self.legs[self.get_leg_index(label)]</span></code>.</p>
<p>Convenient function returning the leg corresponding to a leg label/index.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg_index">
<code class="descname">get_leg_index</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg_index" title="Permalink to this definition">¶</a></dt>
<dd><p>translate a leg-index or leg-label to a leg-index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | string</span></dt>
<dd><p class="first last">The leg-index directly or a label (string) set before.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>leg_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The index of the label.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_indices" title="tenpy.linalg.np_conserved.Array.get_leg_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_indices</span></code></a></dt>
<dd>calls get_leg_index for a list of labels.</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="tenpy.linalg.np_conserved.Array.iset_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iset_leg_labels</span></code></a></dt>
<dd>set the labels of different legs.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg_indices">
<code class="descname">get_leg_indices</code><span class="sig-paren">(</span><em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a list of leg-indices or leg-labels to leg indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of string/int</span></dt>
<dd><p class="first last">The leg-labels (or directly indices) to be translated in leg-indices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>leg_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">The translated labels.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_index" title="tenpy.linalg.np_conserved.Array.get_leg_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_index</span></code></a></dt>
<dd>used to translate each of the single entries.</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="tenpy.linalg.np_conserved.Array.iset_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iset_leg_labels</span></code></a></dt>
<dd>set the labels of different legs.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg_labels">
<code class="descname">get_leg_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of the leg labels, with <cite>None</cite> for anonymous legs.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iadd_prefactor_other">
<code class="descname">iadd_prefactor_other</code><span class="sig-paren">(</span><em>prefactor</em>, <em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iadd_prefactor_other"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iadd_prefactor_other" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">+=</span> <span class="pre">prefactor</span> <span class="pre">*</span> <span class="pre">other</span></code> for scalar <cite>prefactor</cite> and <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> <cite>other</cite>.</p>
<p>Note that we allow the type of <cite>self</cite> to change if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ibinary_blockwise">
<code class="descname">ibinary_blockwise</code><span class="sig-paren">(</span><em>func</em>, <em>other</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ibinary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ibinary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise. In place.</p>
<p>Applies a binary function ‘block-wise’ to the non-zero blocks of
<code class="docutils literal notranslate"><span class="pre">self._data</span></code> and <code class="docutils literal notranslate"><span class="pre">other._data</span></code>, storing result in place.
Assumes that <cite>other</cite> is an <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> as well, with the same shape
and compatible legs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Assumes implicitly that
<code class="docutils literal notranslate"><span class="pre">func(np.zeros(...),</span> <span class="pre">np.zeros(...),</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> gives 0,
since we don’t let <cite>func</cite> act on zero blocks!</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># equivalent to ``a += b``, if ``b`` is an `Array`.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># overwrites ``a`` to ``a = max(a, b)``</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iconj">
<code class="descname">iconj</code><span class="sig-paren">(</span><em>complex_conj=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iconj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iconj" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraper around <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.conj()</span></code> with <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.idrop_labels">
<code class="descname">idrop_labels</code><span class="sig-paren">(</span><em>old_labels=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.idrop_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.idrop_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove leg labels from self. In place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>old_labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str|int</span></dt>
<dd><p class="first last">The leg labels/indices for which the label should be removed.
By default (None), remove all labels.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iproject">
<code class="descname">iproject</code><span class="sig-paren">(</span><em>mask</em>, <em>axes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iproject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Applying masks to one or multiple axes. In place.</p>
<p>This function is similar as <cite>np.compress</cite> with boolean arrays
For each specified axis, a boolean 1D array <cite>mask</cite> can be given,
which chooses the indices to keep.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Although it is possible to use an 1D int array as a mask, the order is ignored!
If you need to permute an axis, use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.permute" title="tenpy.linalg.np_conserved.Array.permute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permute()</span></code></a> or <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) 1D array(bool|int)</span></dt>
<dd><p class="first last">For each axis specified by <cite>axes</cite> a mask, which indices of the axes should be kept.
If <cite>mask</cite> is a bool array, keep the indices where <cite>mask</cite> is True.
If <cite>mask</cite> is an int array, keep the indices listed in the mask, <em>ignoring</em> the
order or multiplicity.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) int | string</span></dt>
<dd><p class="first last">The <cite>i`th entry in this list specifies the axis for the `i`th entry of `mask</cite>,
either as an int, or with a leg label.
If axes is just a single int/string, specify just a single mask.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>map_qind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D arrays</span></dt>
<dd><p class="first last">The mapping of qindices for each of the specified axes.</p>
</dd>
<dt><strong>block_masks: list of lists of 1D bool arrays</strong></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">block_masks[a][qind]</span></code> is a boolen mask which indices to keep
in block <code class="docutils literal notranslate"><span class="pre">qindex</span></code> of <code class="docutils literal notranslate"><span class="pre">axes[a]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ipurge_zeros">
<code class="descname">ipurge_zeros</code><span class="sig-paren">(</span><em>cutoff=2.220446049250313e-15</em>, <em>norm_order=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ipurge_zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ipurge_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">self._data</span></code> blocks with <em>norm</em> less than cutoff. In place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Blocks with norm &lt;= <cite>cutoff</cite> are removed. defaults to <a class="reference internal" href="#tenpy.linalg.np_conserved.QCUTOFF" title="tenpy.linalg.np_conserved.QCUTOFF"><code class="xref py py-data docutils literal notranslate"><span class="pre">QCUTOFF</span></code></a>.</p>
</dd>
<dt><strong>norm_order :</strong></dt>
<dd><p class="first last">A valid <cite>ord</cite> argument for <cite>np.linalg.norm</cite>.
Default <code class="docutils literal notranslate"><span class="pre">None</span></code> gives the Frobenius norm/2-norm for matrices/everything else.
Note that this differs from other methods, e.g. <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ndarray()</span></code></a>,
which use the maximum norm.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ireplace_label">
<code class="descname">ireplace_label</code><span class="sig-paren">(</span><em>old_label</em>, <em>new_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ireplace_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ireplace_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the leg label <cite>old_label</cite> with <cite>new_label</cite>. In place.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ireplace_labels">
<code class="descname">ireplace_labels</code><span class="sig-paren">(</span><em>old_labels</em>, <em>new_labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ireplace_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ireplace_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace leg label <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> with <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>. In place.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.is_completely_blocked">
<code class="descname">is_completely_blocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.is_completely_blocked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.is_completely_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return bool whether all legs are blocked by charge.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iscale_axis">
<code class="descname">iscale_axis</code><span class="sig-paren">(</span><em>s</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iscale_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale with varying values along an axis. In place.</p>
<p>Rescale to <code class="docutils literal notranslate"><span class="pre">new_self[i1,</span> <span class="pre">...,</span> <span class="pre">i_axis,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">s[i_axis]</span> <span class="pre">*</span> <span class="pre">self[i1,</span> <span class="pre">...,</span> <span class="pre">i_axis,</span> <span class="pre">...]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array, len=self.shape[axis]</span></dt>
<dd><p class="first last">The vector with which the axis should be scaled.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str|int</span></dt>
<dd><p class="first last">The leg label or index for the axis which should be scaled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iproject" title="tenpy.linalg.np_conserved.Array.iproject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iproject</span></code></a></dt>
<dd>can be used to discard indices for which s is zero.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iscale_prefactor">
<code class="descname">iscale_prefactor</code><span class="sig-paren">(</span><em>prefactor</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iscale_prefactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iscale_prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*=</span> <span class="pre">prefactor</span></code> for scalar <cite>prefactor</cite>.</p>
<p>Note that we allow the type of <cite>self</cite> to change if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iset_leg_labels">
<code class="descname">iset_leg_labels</code><span class="sig-paren">(</span><em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iset_leg_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Set labels for the different axes/legs. In place.</p>
<p>Introduction to leg labeling can be found in <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable (strings | None), len=self.rank</span></dt>
<dd><p class="first last">One label for each of the legs.
An entry can be None for an anonymous leg.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg" title="tenpy.linalg.np_conserved.Array.get_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg</span></code></a></dt>
<dd>translate the labels to indices.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.isort_qdata">
<code class="descname">isort_qdata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.isort_qdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.isort_qdata" title="Permalink to this definition">¶</a></dt>
<dd><p>(Lexiographically) sort <code class="docutils literal notranslate"><span class="pre">self._qdata</span></code>. In place.</p>
<p>Lexsort <code class="docutils literal notranslate"><span class="pre">self._qdata</span></code> and <code class="docutils literal notranslate"><span class="pre">self._data</span></code> and set <code class="docutils literal notranslate"><span class="pre">self._qdata_sorted</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iswapaxes">
<code class="descname">iswapaxes</code><span class="sig-paren">(</span><em>axis1</em>, <em>axis2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iswapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iswapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar as <code class="docutils literal notranslate"><span class="pre">np.swapaxes</span></code>. In place.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.itranspose">
<code class="descname">itranspose</code><span class="sig-paren">(</span><em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.itranspose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.itranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose axes like <cite>np.transpose</cite>. In place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axes: iterable (int|string), len ``rank`` | None</strong></dt>
<dd><p class="first last">The new order of the axes. By default (None), reverse axes.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iunary_blockwise">
<code class="descname">iunary_blockwise</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iunary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iunary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">f(self)</span></code>, block-wise. In place.</p>
<p>Applies an unary function <cite>func</cite> to the non-zero blocks in <code class="docutils literal notranslate"><span class="pre">self._data</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Assumes implicitly that <code class="docutils literal notranslate"><span class="pre">func(np.zeros(...),</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> gives 0,
since we don’t let <cite>func</cite> act on zero blocks!</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">A function acting on flat arrays, returning flat arrays.
It is called like <code class="docutils literal notranslate"><span class="pre">new_block</span> <span class="pre">=</span> <span class="pre">func(block,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
</dd>
<dt><strong>*args :</strong></dt>
<dd><p class="first last">Additional arguments given to function <em>after</em> the block.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Keyword arguments given to the function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">iunaray_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>  <span class="c1"># get real part</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">iunaray_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">)</span>  <span class="c1"># same data as a.iconj(), but doesn&#39;t charge conjugate.</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.linalg.np_conserved.Array.labels">
<code class="descname">labels</code><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.labels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.make_pipe">
<code class="descname">make_pipe</code><span class="sig-paren">(</span><em>axes</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.make_pipe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.make_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a <a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> for specified axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of str|int</span></dt>
<dd><p class="first last">The leg labels for the axes which should be combined. Order matters!</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Additional keyword arguments given to <a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pipe</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a></span></dt>
<dd><p class="first last">A pipe of the legs specified by axes.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.matvec">
<code class="descname">matvec</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.matvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.matvec" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used by the Lanczos algorithm needed for DMRG.</p>
<p>It is supposed to calculate the matrix - vector - product
for a rank-2 matrix <code class="docutils literal notranslate"><span class="pre">self</span></code> and a rank-1 vector <cite>other</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>ord=None</em>, <em>convert_to_float=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of flattened data.</p>
<p>See <a class="reference internal" href="#tenpy.linalg.np_conserved.norm" title="tenpy.linalg.np_conserved.norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">norm()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.permute">
<code class="descname">permute</code><span class="sig-paren">(</span><em>perm</em>, <em>axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.permute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a permutation in the indices of an axis.</p>
<p>Similar as np.take with a 1D array.
Roughly equivalent to <code class="docutils literal notranslate"><span class="pre">res[:,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">self[perm,</span> <span class="pre">...]</span></code> for the corresponding <cite>axis</cite>.
Note: This function is quite slow, and usually not needed!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like 1D int</span></dt>
<dd><p class="first last">The permutation which should be applied to the leg given by <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | int</span></dt>
<dd><p class="first last">A leg label or index specifying on which leg to take the permutation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of self with leg <cite>axis</cite> permuted, such that
<code class="docutils literal notranslate"><span class="pre">res[i,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">self[perm[i],</span> <span class="pre">...]</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span></code> along <cite>axis</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_legcharge</span></code></a></dt>
<dd>can also be used to perform a general permutation. Preferable, since it is faster for permutations which don’t mix charge blocks.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.replace_label">
<code class="descname">replace_label</code><span class="sig-paren">(</span><em>old_label</em>, <em>new_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.replace_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.replace_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy with the leg label <cite>old_label</cite> replaced by <cite>new_label</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.replace_labels">
<code class="descname">replace_labels</code><span class="sig-paren">(</span><em>old_labels</em>, <em>new_labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.replace_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.replace_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy with <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> replaced by <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.scale_axis">
<code class="descname">scale_axis</code><span class="sig-paren">(</span><em>s</em>, <em>axis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.scale_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.scale_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="tenpy.linalg.np_conserved.Array.iscale_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iscale_axis()</span></code></a>, but return a (deep) copy.</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.linalg.np_conserved.Array.size">
<code class="descname">size</code><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dtype-objects stored.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.sort_legcharge">
<code class="descname">sort_legcharge</code><span class="sig-paren">(</span><em>sort=True</em>, <em>bunch=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.sort_legcharge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy with one or all legs sorted by charges.</p>
<p>Sort/bunch one or multiple of the LegCharges.
Legs which are sorted <em>and</em> bunched are guaranteed to be blocked by charge.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">True | False | list of {True, False, perm}</span></dt>
<dd><p class="first last">A single bool holds for all legs, default=True.
Else, <cite>sort</cite> should contain one entry for each leg, with a bool for sort/don’t sort,
or a 1D array perm for a given permuation to apply to a leg.</p>
</dd>
<dt><strong>bunch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">True | False | list of {True, False}</span></dt>
<dd><p class="first last">A single bool holds for all legs, default=True.
Whether or not to bunch at each leg, i.e. combine contiguous blocks with equal charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of 1D arrays</span></dt>
<dd><p class="first last">The permutation applied to each of the legs, such that
<code class="docutils literal notranslate"><span class="pre">cp.to_ndarray()</span> <span class="pre">=</span> <span class="pre">self.to_ndarray(perm)</span></code>.</p>
</dd>
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Array</span></dt>
<dd><p class="first last">A shallow copy of self, with legs sorted/bunched.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.sparse_stats">
<code class="descname">sparse_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.sparse_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.sparse_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string detailing the sparse statistics</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.split_legs">
<code class="descname">split_legs</code><span class="sig-paren">(</span><em>axes=None</em>, <em>cutoff=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.split_legs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.split_legs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape: opposite of combine_legs: split (some) legs which are LegPipes.</p>
<p>Reverts <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_legs()</span></code></a> (except a possibly performed <cite>transpose</cite>).
The splited legs are replacing the LegPipes at their position, see the examples below.
Labels are split reverting what was done in <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_legs()</span></code></a>.
‘?#’ labels are replaced with <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) int|str</span></dt>
<dd><p class="first last">Leg labels or indices determining the axes to split.
The corresponding entries in self.legs must be <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe" title="tenpy.linalg.np_conserved.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> instances.
Defaults to all legs, which are <a class="reference internal" href="#tenpy.linalg.np_conserved.LegPipe" title="tenpy.linalg.np_conserved.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> instances.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Splitted data blocks with <code class="docutils literal notranslate"><span class="pre">np.max(np.abs(block))</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code> are considered as zero.
Defaults to 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reshaped</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of self where the specified legs are splitted.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_legs()</span></code></a></dt>
<dd>this is reversed by split_legs.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Given a rank-5 Array <cite>old_array</cite>, you can combine it and split it again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_array</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comb_array</span> <span class="o">=</span> <span class="n">old_array</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comb_array</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;(a.d)&#39;, &#39;b&#39;, &#39;(c.e)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_array</span> <span class="o">=</span> <span class="n">comb_array</span><span class="o">.</span><span class="n">split_legs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_array</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">np.squeeze</span></code>.</p>
<p>If a squeezed leg has non-zero charge, this charge is added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">qtotal</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (iterable of) {int|str}</span></dt>
<dd><p class="first last">Labels or indices of the legs which should be ‘squeezed’, i.e. the legs removed.
The corresponding legs must be trivial, i.e., have <cite>ind_len</cite> 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>squeezed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class:Array | scalar</span></dt>
<dd><p class="first last">A scalar of <code class="docutils literal notranslate"><span class="pre">self.dtype</span></code>, if all axes were squeezed.
Else a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with reduced <code class="docutils literal notranslate"><span class="pre">rank</span></code> as specified by <cite>axes</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.linalg.np_conserved.Array.stored_blocks">
<code class="descname">stored_blocks</code><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.stored_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of (non-zero) blocks stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">_data</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.take_slice">
<code class="descname">take_slice</code><span class="sig-paren">(</span><em>indices</em>, <em>axes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.take_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.take_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self fixing <cite>indices</cite> along one or multiple <cite>axes</cite>.</p>
<p>For a rank-4 Array <code class="docutils literal notranslate"><span class="pre">A.take_slice([i,</span> <span class="pre">j],</span> <span class="pre">[1,2])</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">A[:,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">:]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) int</span></dt>
<dd><p class="first last">The (flat) index for each of the legs specified by <cite>axes</cite>.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) str/int</span></dt>
<dd><p class="first last">Leg labels or indices to specify the legs for which the indices are given.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sliced_self</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A copy of self, equivalent to taking slices with indices inserted in axes.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_leg" title="tenpy.linalg.np_conserved.Array.add_leg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_leg()</span></code></a></dt>
<dd>opposite action of inserting a new leg.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.to_ndarray">
<code class="descname">to_ndarray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.to_ndarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.to_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self to a dense numpy ndarray.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.itranspose" title="tenpy.linalg.np_conserved.Array.itranspose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itranspose()</span></code></a>, but on a deep copy.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.unary_blockwise">
<code class="descname">unary_blockwise</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.unary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.unary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self)</span></code>, block-wise. Copies.</p>
<p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iunary_blockwise" title="tenpy.linalg.np_conserved.Array.iunary_blockwise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iunary_blockwise()</span></code></a>, but makes a <strong>shallow</strong> copy first.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.zeros_like">
<code class="descname">zeros_like</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.zeros_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self with only zeros as entries, containing no <cite>_data</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.zeros">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>legcharges</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a npc array full of zeros (with no _data).</p>
<p>This is just a wrapper around <code class="docutils literal notranslate"><span class="pre">Array(...)</span></code>,
detailed documentation can be found in the class doc-string of <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.eye_like">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">eye_like</code><span class="sig-paren">(</span><em>a</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#eye_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.eye_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an identity matrix contractible with the leg <cite>axis</cite> of the <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> <cite>a</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.diag">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">diag</code><span class="sig-paren">(</span><em>s</em>, <em>leg</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#diag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a square, diagonal matrix of entries <cite>s</cite>.</p>
<p>The resulting matrix has legs <code class="docutils literal notranslate"><span class="pre">(leg,</span> <span class="pre">leg.conj())</span></code> and charge 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>s</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | 1D array</span></dt>
<dd><p class="first last">The entries to put on the diagonal. If scalar, all diagonal entries are the same.</p>
</dd>
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">The first leg of the resulting matrix.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | type</span></dt>
<dd><p class="first last">The data type to be used for the result. By default, use dtype of <cite>s</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>diagonal</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A square matrix with diagonal entries <cite>s</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.scale_axis" title="tenpy.linalg.np_conserved.Array.scale_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.scale_axis()</span></code></a></dt>
<dd>similar as <code class="docutils literal notranslate"><span class="pre">tensordot(diag(s),</span> <span class="pre">...)</span></code>, but faster.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.concatenate">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>arrays</em>, <em>axis=0</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#concatenate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays along a given axis, similar as np.concatenate.</p>
<p>Stacks the qind of the array, without sorting/blocking.
Labels are inherited from the first array only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>arrays</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The arrays to be stacked. They must have the same shape and charge data
except on the specified axis.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Leg index or label of the first array. Defines the axis along which the arrays are stacked.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to copy the data blocks.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>stacked</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Concatenation of the given <cite>arrays</cite> along the specified axis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.sort_legcharge()</span></code></a></dt>
<dd>can be used to block by charges along the axis.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.grid_concat">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">grid_concat</code><span class="sig-paren">(</span><em>grid</em>, <em>axes</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#grid_concat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.grid_concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an np.array of npc.Arrays, performs a multi-dimensional concatentation along ‘axes’.</p>
<p>Stacks the qind of the array, <em>without</em> sorting/blocking.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The grid of arrays.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">The axes along which to concatenate the arrays,  same len as the dimension of the grid.
Concatenate arrays of the <cite>i`th axis of the grid along the axis ``axes[i]`</cite></p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the _data blocks are copied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.sort_legcharge()</span></code></a></dt>
<dd>can be used to block by charges.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Assume we have rank 2 Arrays <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">D</span></code> of shapes
<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2),</span> <span class="pre">(1,</span> <span class="pre">4),</span> <span class="pre">(3,</span> <span class="pre">2),</span> <span class="pre">(3,</span> <span class="pre">4)</span></code> sharing the legs of equal sizes.
Then the following grid will result in a <code class="docutils literal notranslate"><span class="pre">(1+3,</span> <span class="pre">2+4)</span></code> shaped array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">grid_concat</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 6)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">D</span></code> were rank 4 arrays, with the first and last leg as before, and sharing
<em>common</em> legs <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>, then you would get a rank-4 array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">grid_concat</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.grid_outer">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">grid_outer</code><span class="sig-paren">(</span><em>grid</em>, <em>grid_legs</em>, <em>qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#grid_outer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.grid_outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an np.array of npc.Arrays, return the corresponding higher-dimensional Array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of {<a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | None}</span></dt>
<dd><p class="first last">The grid gives the first part of the axes of the resulting array.
Entries have to have all the same shape and charge-data, giving the remaining axes.
<code class="docutils literal notranslate"><span class="pre">None</span></code> entries in the grid are interpreted as zeros.</p>
</dd>
<dt><strong>grid_legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">One LegCharge for each dimension of the grid along the grid.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charge</span></dt>
<dd><p class="first last">The total charge of the Array.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), derive it out from a non-trivial entry of the grid.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">An Array with shape <code class="docutils literal notranslate"><span class="pre">grid.shape</span> <span class="pre">+</span> <span class="pre">nontrivial_grid_entry.shape</span></code>.
Constructed such that <code class="docutils literal notranslate"><span class="pre">res[idx]</span> <span class="pre">==</span> <span class="pre">grid[idx]</span></code> for any index <code class="docutils literal notranslate"><span class="pre">idx</span></code> of the <cite>grid</cite>
the <cite>grid</cite> entry is not trivial (<code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_grid_outer_legcharge" title="tenpy.linalg.np_conserved.detect_grid_outer_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_grid_outer_legcharge</span></code></a></dt>
<dd>can calculate one missing <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> of the grid.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>A typical use-case for this function is the generation of an MPO.
Say you have npc.Arrays <code class="docutils literal notranslate"><span class="pre">Splus,</span> <span class="pre">Sminus,</span> <span class="pre">Sz</span></code>, each with legs <code class="docutils literal notranslate"><span class="pre">[phys.conj(),</span> <span class="pre">phys]</span></code>.
Further, you have to define appropriate LegCharges <cite>l_left</cite> and <cite>l_right</cite>.
Then one ‘matrix’ of the MPO for a nearest neighbour Heisenberg Hamiltonian could look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye_like</span><span class="p">(</span><span class="n">Sz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W_mpo</span> <span class="o">=</span> <span class="n">grid_outer</span><span class="p">([[</span><span class="n">Id</span><span class="p">,</span> <span class="n">Splus</span><span class="p">,</span> <span class="n">Sminus</span><span class="p">,</span> <span class="n">Sz</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">J</span><span class="o">*</span><span class="n">Sminus</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">J</span><span class="o">*</span><span class="n">Splus</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">J</span><span class="o">*</span><span class="n">Sz</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Id</span><span class="p">]],</span>
<span class="gp">... </span>                   <span class="n">leg_charges</span><span class="o">=</span><span class="p">[</span><span class="n">l_left</span><span class="p">,</span> <span class="n">l_right</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">W_mpo</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 5, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.detect_grid_outer_legcharge">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">detect_grid_outer_legcharge</code><span class="sig-paren">(</span><em>grid</em>, <em>grid_legs</em>, <em>qtotal=None</em>, <em>qconj=1</em>, <em>bunch=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#detect_grid_outer_legcharge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.detect_grid_outer_legcharge" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive a LegCharge for a grid used for <a class="reference internal" href="#tenpy.linalg.np_conserved.grid_outer" title="tenpy.linalg.np_conserved.grid_outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">grid_outer()</span></code></a>.</p>
<p>Note: The resulting LegCharge is <em>not</em> bunched.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of {<a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | None}</span></dt>
<dd><p class="first last">The grid as it will be given to <a class="reference internal" href="#tenpy.linalg.np_conserved.grid_outer" title="tenpy.linalg.np_conserved.grid_outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">grid_outer()</span></code></a>.</p>
</dd>
<dt><strong>grid_legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of {<a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a> | None}</span></dt>
<dd><p class="first last">One LegCharge for each dimension of the grid, except for one entry which is <code class="docutils literal notranslate"><span class="pre">None</span></code>.
This missing entry is to be calculated.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charge</span></dt>
<dd><p class="first last">The desired total charge of the array. Defaults to 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_grid_legs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A copy of the given <cite>grid_legs</cite> with the <code class="docutils literal notranslate"><span class="pre">None</span></code> replaced by a compatible LegCharge.
The new LegCharge is neither bunched nor sorted!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_legcharge" title="tenpy.linalg.np_conserved.detect_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_legcharge</span></code></a></dt>
<dd>similar functionality for a flat numpy array instead of a grid.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.detect_qtotal">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">detect_qtotal</code><span class="sig-paren">(</span><em>flat_array</em>, <em>legcharges</em>, <em>cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#detect_qtotal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.detect_qtotal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total charge (w.r.t <cite>legs</cite>) of first non-zero sector found in <cite>flat_array</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>flat_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The flat numpy array from which you want to detect the charges.</p>
</dd>
<dt><strong>legcharges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">For each leg the LegCharge.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Blocks with <code class="docutils literal notranslate"><span class="pre">np.max(np.abs(block))</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code> are considered as zero.
Defaults to <a class="reference internal" href="#tenpy.linalg.np_conserved.QCUTOFF" title="tenpy.linalg.np_conserved.QCUTOFF"><code class="xref py py-data docutils literal notranslate"><span class="pre">QCUTOFF</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charge</span></dt>
<dd><p class="first last">The total charge fo the first non-zero (i.e. &gt; cutoff) charge block.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_legcharge" title="tenpy.linalg.np_conserved.detect_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_legcharge</span></code></a></dt>
<dd>detects the charges of one missing LegCharge if <cite>qtotal</cite> is known.</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_grid_outer_legcharge" title="tenpy.linalg.np_conserved.detect_grid_outer_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_grid_outer_legcharge</span></code></a></dt>
<dd>similar functionality if the flat array is given by a ‘grid’.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.detect_legcharge">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">detect_legcharge</code><span class="sig-paren">(</span><em>flat_array</em>, <em>chargeinfo</em>, <em>legcharges</em>, <em>qtotal=None</em>, <em>qconj=1</em>, <em>cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#detect_legcharge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.detect_legcharge" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a missing <cite>LegCharge</cite> by looking for nonzero entries of a flat array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>flat_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A flat array, in which we look for non-zero entries.</p>
</dd>
<dt><strong>chargeinfo</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.html#tenpy.linalg.charges.ChargeInfo" title="tenpy.linalg.charges.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt>
<dd><p class="first last">The nature of the charge.</p>
</dd>
<dt><strong>legcharges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">One LegCharge for each dimension of flat_array, except for one entry which is <code class="docutils literal notranslate"><span class="pre">None</span></code>.
This missing entry is to be calculated.</p>
</dd>
<dt><strong>qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{+1, -1}</span></dt>
<dd><p class="first last"><cite>qconj</cite> for the new calculated LegCharge.</p>
</dd>
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last">Desired total charge of the array. Defaults to zeros.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Blocks with <code class="docutils literal notranslate"><span class="pre">np.max(np.abs(block))</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code> are considered as zero.
Defaults to <a class="reference internal" href="#tenpy.linalg.np_conserved.QCUTOFF" title="tenpy.linalg.np_conserved.QCUTOFF"><code class="xref py py-data docutils literal notranslate"><span class="pre">QCUTOFF</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new_legcharges</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.LegCharge" title="tenpy.linalg.np_conserved.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">A copy of the given <cite>legcharges</cite> with the <code class="docutils literal notranslate"><span class="pre">None</span></code> replaced by a compatible LegCharge.
The new legcharge is ‘bunched’, but not sorted!</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_grid_outer_legcharge" title="tenpy.linalg.np_conserved.detect_grid_outer_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_grid_outer_legcharge</span></code></a></dt>
<dd>similar functionality if the flat array is given by a ‘grid’.</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.detect_qtotal" title="tenpy.linalg.np_conserved.detect_qtotal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_qtotal</span></code></a></dt>
<dd>detects the total charge, if all legs are known.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.trace">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">trace</code><span class="sig-paren">(</span><em>a</em>, <em>leg1=0</em>, <em>leg2=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace of <cite>a</cite>, summing over leg1 and leg2.</p>
<p>Requires that the contracted legs are contractible (i.e. have opposite charges).
Labels are inherited from <cite>a</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>leg1, leg2: str|int</strong></dt>
<dd><p class="first last">The leg label or index for the two legs which should be contracted (i.e. summed over).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>traced</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | <code class="docutils literal notranslate"><span class="pre">a.dtype</span></code></span></dt>
<dd><p class="first last">A scalar if <code class="docutils literal notranslate"><span class="pre">a.rank</span> <span class="pre">==</span> <span class="pre">2</span></code>, else an <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> of rank <code class="docutils literal notranslate"><span class="pre">a.rank</span> <span class="pre">-</span> <span class="pre">2</span></code>.
Equivalent to <code class="docutils literal notranslate"><span class="pre">sum([a.take_slice([i,</span> <span class="pre">i],</span> <span class="pre">[leg1,</span> <span class="pre">leg2])</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(a.shape[leg1])])</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.outer">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">outer</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#outer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms the outer tensor product, equivalent to <code class="docutils literal notranslate"><span class="pre">tensordot(a,</span> <span class="pre">b,</span> <span class="pre">axes=0)</span></code>.</p>
<p>Labels are inherited from <cite>a</cite> and <cite>b</cite>. In case of a collision (same label in both <cite>a</cite> and <cite>b</cite>),
they are both dropped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The arrays for which to form the product.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>c</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first">Array of rank <code class="docutils literal notranslate"><span class="pre">a.rank</span> <span class="pre">+</span> <span class="pre">b.rank</span></code> such that (for <code class="docutils literal notranslate"><span class="pre">Ra</span> <span class="pre">=</span> <span class="pre">a.rank;</span> <span class="pre">Rb</span> <span class="pre">=</span> <span class="pre">b.rank</span></code>):</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_Ra</span><span class="p">,</span> <span class="n">j_1</span><span class="p">,</span> <span class="o">...</span> <span class="n">j_R</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i_Ra</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j_1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">j_rank_b</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.inner">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">inner</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>axes=None</em>, <em>do_conj=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract all legs in <cite>a</cite> and <cite>b</cite>, return scalar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">class:<cite>Array</cite></span></dt>
<dd><p class="first last">The arrays for which to calculate the product.
Must have same rank, and compatible LegCharges.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">(axes_a,</span> <span class="pre">axes_b)</span></code> | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">None</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(range(rank),</span> <span class="pre">range(rank))</span></code>.
Alternatively, <cite>axes_a</cite> and <cite>axes_b</cite> specifiy the legs of <cite>a</cite> and <cite>b</cite>, respectively,
which should be contracted. Legs can be specified with leg labels or indices.
Contract leg <code class="docutils literal notranslate"><span class="pre">axes_a[i]</span></code> of <cite>a</cite> with leg <code class="docutils literal notranslate"><span class="pre">axes_b[i]</span></code> of <cite>b</cite>.</p>
</dd>
<dt><strong>do_conj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">False</span></code> (Default), ignore it.
if <code class="docutils literal notranslate"><span class="pre">True</span></code>, conjugate <cite>a</cite> before, i.e., return <code class="docutils literal notranslate"><span class="pre">inner(a.conj(),</span> <span class="pre">b,</span> <span class="pre">axes)</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inner_product</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dtype</span></dt>
<dd><p class="first last">A scalar (of common dtype of <cite>a</cite> and <cite>b</cite>) giving the full contraction of <cite>a</cite> and <cite>b</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.tensordot">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">tensordot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>axes=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#tensordot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar as <code class="docutils literal notranslate"><span class="pre">np.tensordot</span></code> but for <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
<p>Builds the tensor product of <cite>a</cite> and <cite>b</cite> and sums over the specified axes.
Does not require complete blocking of the charges.</p>
<p>Labels are inherited from <cite>a</cite> and <cite>b</cite>.
In case of a collision (= the same label would be inherited from <cite>a</cite> and <cite>b</cite>
after the contraction), both labels are dropped.</p>
<p>Detailed implementation notes are available in the doc-string of <code class="xref py py-func docutils literal notranslate"><span class="pre">_tensordot_worker()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a, b</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The first and second npc Array for which axes are to be contracted.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">(axes_a,</span> <span class="pre">axes_b)</span></code> | int</span></dt>
<dd><p class="first last">A single integer is equivalent to <code class="docutils literal notranslate"><span class="pre">(range(-axes,</span> <span class="pre">0),</span> <span class="pre">range(axes))</span></code>.
Alternatively, <cite>axes_a</cite> and <cite>axes_b</cite> specifiy the legs of <cite>a</cite> and <cite>b</cite>, respectively,
which should be contracted. Legs can be specified with leg labels or indices.
Contract leg <code class="docutils literal notranslate"><span class="pre">axes_a[i]</span></code> of <cite>a</cite> with leg <code class="docutils literal notranslate"><span class="pre">axes_b[i]</span></code> of <cite>b</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a_dot_b</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The tensorproduct of <cite>a</cite> and <cite>b</cite>, summed over the specified axes.
Returns a scalar in case of a full contraction.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.svd">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">svd</code><span class="sig-paren">(</span><em>a, full_matrices=False, compute_uv=True, cutoff=None, qtotal_LR=[None, None], inner_labels=[None, None], inner_qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#svd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Singualar value decomposition of an Array <cite>a</cite>.</p>
<p>Factorizes <code class="docutils literal notranslate"><span class="pre">U,</span> <span class="pre">S,</span> <span class="pre">VH</span> <span class="pre">=</span> <span class="pre">svd(a)</span></code>, such that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">U*diag(S)*VH</span></code> (where <code class="docutils literal notranslate"><span class="pre">*</span></code> stands for
a <a class="reference internal" href="#tenpy.linalg.np_conserved.tensordot" title="tenpy.linalg.np_conserved.tensordot"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensordot()</span></code></a> and <cite>diag</cite> creates an correctly shaped Array with <cite>S</cite> on the diagonal).
For a non-zero <cite>cutoff</cite> this holds only approximately.</p>
<p>There is a gauge freedom regarding the charges, see also <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.gauge_total_charge" title="tenpy.linalg.np_conserved.Array.gauge_total_charge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Array.gauge_total_charge()</span></code></a>.
We ensure contractibility by setting <code class="docutils literal notranslate"><span class="pre">U.legs[1]</span> <span class="pre">=</span> <span class="pre">VH.legs[0].conj()</span></code>.
Further, we gauge the LegCharge such that <cite>U</cite> and <cite>V</cite> have the desired <cite>qtotal_LR</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>, shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N)</span></code></span></dt>
<dd><p class="first last">The matrix to be decomposed.</p>
</dd>
<dt><strong>full_matrices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), <cite>U</cite> and <cite>V</cite> have shapes <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">K)</span></code> and <code class="docutils literal notranslate"><span class="pre">(K,</span> <span class="pre">N)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">K=len(S)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>U</cite> and <cite>V</cite> are full square unitary matrices with shapes <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">M)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">N)</span></code>. Note that the arrays are not directly contractible in that case; <code class="docutils literal notranslate"><span class="pre">diag(S)</span></code>
would need to be a rectangluar <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N)</span></code> matrix.</p>
</dd>
<dt><strong>compute_uv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to compute and return <cite>U</cite> and <cite>V</cite>.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | float</span></dt>
<dd><p class="first last">Keep only singular values which are (strictly) greater than <cite>cutoff</cite>.
(Then the factorization holds only approximately).
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), ignored.</p>
</dd>
<dt><strong>qtotal_LR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[{charges|None}, {charges|None}]</span></dt>
<dd><p class="first last">The desired <cite>qtotal</cite> for <cite>U</cite> and <cite>VH</cite>, respectively.
<code class="docutils literal notranslate"><span class="pre">[None,</span> <span class="pre">None]</span></code> (Default) is equivalent to <code class="docutils literal notranslate"><span class="pre">[None,</span> <span class="pre">a.qtotal]</span></code>.
A single <cite>None</cite> entry is replaced the unique charge satisfying the requirement
<code class="docutils literal notranslate"><span class="pre">U.qtotal</span> <span class="pre">+</span> <span class="pre">VH.qtotal</span> <span class="pre">=</span> <span class="pre">a.qtotal</span> <span class="pre">(modulo</span> <span class="pre">qmod)</span></code>.</p>
</dd>
<dt><strong>inner_labels_LR: [{str|None}, {str|None}]</strong></dt>
<dd><p class="first last">The first label corresponds to <code class="docutils literal notranslate"><span class="pre">U.legs[1]</span></code>, the second to <code class="docutils literal notranslate"><span class="pre">VH.legs[0]</span></code>.</p>
</dd>
<dt><strong>inner_qconj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{+1, -1}</span></dt>
<dd><p class="first last">Direction of the charges for the new leg. Default +1.
The new LegCharge is constructed such that <code class="docutils literal notranslate"><span class="pre">VH.legs[0].qconj</span> <span class="pre">=</span> <span class="pre">qconj</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Matrix with left singular vectors as columns.
Shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">M)</span></code> or <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">K)</span></code> depending on <cite>full_matrices</cite>.</p>
</dd>
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">The singluar values of the array. If no <cite>cutoff</cite> is given, it has lenght <code class="docutils literal notranslate"><span class="pre">min(M,</span> <span class="pre">N)</span></code>.</p>
</dd>
<dt><strong>VH</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Matrix with right singular vectors as rows.
Shape <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">N)</span></code> or <code class="docutils literal notranslate"><span class="pre">(K,</span> <span class="pre">N)</span></code> depending on <cite>full_matrices</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.pinv">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">pinv</code><span class="sig-paren">(</span><em>a</em>, <em>cutoff=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#pinv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.pinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Equivalent to the following procedure: Perform a SVD, <code class="docutils literal notranslate"><span class="pre">U,</span> <span class="pre">S,</span> <span class="pre">VH</span> <span class="pre">=</span> <span class="pre">svd(a,</span> <span class="pre">cutoff=cutoff)</span></code>
with a <cite>cutoff</cite> &gt; 0, calculate <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">diag(1/S)</span> <span class="pre">*</span> <span class="pre">VH</span></code>
(with <code class="docutils literal notranslate"><span class="pre">*</span></code> denoting tensordot) and return <code class="docutils literal notranslate"><span class="pre">P.conj.transpose()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Matrix to be pseudo-inverted.</p>
</dd>
<dt><strong>cuttof</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Cutoff for small singular values, as given to <a class="reference internal" href="#tenpy.linalg.np_conserved.svd" title="tenpy.linalg.np_conserved.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a>.
(Note: different convetion than numpy.)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, M) <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The pseudo-inverse of <cite>a</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.norm">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>a</em>, <em>ord=None</em>, <em>convert_to_float=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of flattened data.</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.linalg.norm(a.to_ndarray().flatten(),</span> <span class="pre">ord)</span></code>.</p>
<p>In contrast to numpy, we don’t distinguish between matrices and vectors,
but simply calculate the norm for the <strong>flat</strong> (block) data.
The usual <cite>ord</cite>-norm is defined as  <span class="math notranslate nohighlight">\((\sum_i |a_i|^{ord} )^{1/ord}\)</span>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ord</th>
<th class="head">norm</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>None/’fro’</td>
<td>Frobenius norm (same as 2-norm)</td>
</tr>
<tr class="row-odd"><td>np.inf</td>
<td><code class="docutils literal notranslate"><span class="pre">max(abs(x))</span></code></td>
</tr>
<tr class="row-even"><td>-np.inf</td>
<td><code class="docutils literal notranslate"><span class="pre">min(abs(x))</span></code></td>
</tr>
<tr class="row-odd"><td>0</td>
<td><code class="docutils literal notranslate"><span class="pre">sum(a</span> <span class="pre">!=</span> <span class="pre">0)</span> <span class="pre">==</span> <span class="pre">np.count_nonzero(x)</span></code></td>
</tr>
<tr class="row-even"><td>other</td>
<td>ususal <cite>ord</cite>-norm</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | np.ndarray</span></dt>
<dd><p class="first last">The array of which the norm should be calculated.</p>
</dd>
<dt><strong>ord :</strong></dt>
<dd><p class="first last">The order of the norm. See table above.</p>
</dd>
<dt><strong>convert_to_float :</strong></dt>
<dd><p class="first last">Convert integer to float before calculating the norm, avoiding int overflow.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The norm over the <em>flat</em> data of the array.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.eigh">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">eigh</code><span class="sig-paren">(</span><em>a</em>, <em>UPLO='L'</em>, <em>sort=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#eigh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.eigh" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate eigenvalues and eigenvectors for a hermitian matrix.</p>
<p><code class="docutils literal notranslate"><span class="pre">W,</span> <span class="pre">V</span> <span class="pre">=</span> <span class="pre">eigh(a)</span></code> yields <span class="math notranslate nohighlight">\(a = V diag(w) V^{\dagger}\)</span>.
<strong>Assumes</strong> that a is hermitian, <code class="docutils literal notranslate"><span class="pre">a.conj().transpose()</span> <span class="pre">==</span> <span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The hermitian square matrix to be diagonalized.</p>
</dd>
<dt><strong>UPLO</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘L’, ‘U’}</span></dt>
<dd><p class="first last">Whether to take the lower (‘L’, default) or upper (‘U’) triangular part of <cite>a</cite>.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘m&gt;’, ‘m&lt;’, ‘&gt;’, ‘&lt;’, <code class="docutils literal notranslate"><span class="pre">None</span></code>}</span></dt>
<dd><p class="first last">How the eigenvalues should are sorted <em>within</em> each charge block.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is same as ‘&lt;’. See <code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code> for details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">The eigenvalues, sorted within the same charge blocks according to <cite>sort</cite>.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Unitary matrix; <code class="docutils literal notranslate"><span class="pre">V[:,</span> <span class="pre">i]</span></code> is normalized eigenvector with eigenvalue <code class="docutils literal notranslate"><span class="pre">W[i]</span></code>.
The first label is inherited from <cite>A</cite>, the second label is <code class="docutils literal notranslate"><span class="pre">'eig'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Requires the legs to be contractible.
If <cite>a</cite> is not blocked by charge, a blocked copy is made via a permutation <code class="docutils literal notranslate"><span class="pre">P</span></code>,
:math:` a’ =  P a P = V’ W’ (V’)^{dagger}`.
The eigenvectors <cite>V</cite> are then obtained by the reverse permutation,
<span class="math notranslate nohighlight">\(V = P^{-1} V'\)</span> such that <cite>A = V W V^{dagger}</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.eig">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">eig</code><span class="sig-paren">(</span><em>a</em>, <em>sort=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate eigenvalues and eigenvectors for a non-hermitian matrix.</p>
<p><code class="docutils literal notranslate"><span class="pre">W,</span> <span class="pre">V</span> <span class="pre">=</span> <span class="pre">eig(a)</span></code> yields <span class="math notranslate nohighlight">\(a V = V diag(w)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The hermitian square matrix to be diagonalized.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘m&gt;’, ‘m&lt;’, ‘&gt;’, ‘&lt;’, <code class="docutils literal notranslate"><span class="pre">None</span></code>}</span></dt>
<dd><p class="first last">How the eigenvalues should are sorted <em>within</em> each charge block.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is same as ‘&lt;’. See <code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code> for details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">The eigenvalues, sorted within the same charge blocks according to <cite>sort</cite>.</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Unitary matrix; <code class="docutils literal notranslate"><span class="pre">V[:,</span> <span class="pre">i]</span></code> is normalized eigenvector with eigenvalue <code class="docutils literal notranslate"><span class="pre">W[i]</span></code>.
The first label is inherited from <cite>A</cite>, the second label is <code class="docutils literal notranslate"><span class="pre">'eig'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Requires the legs to be contractible.
If <cite>a</cite> is not blocked by charge, a blocked copy is made via a permutation <code class="docutils literal notranslate"><span class="pre">P</span></code>,
:math:` a’ =  P a P = V’ W’ (V’)^{dagger}`.
The eigenvectors <cite>V</cite> are then obtained by the reverse permutation,
<span class="math notranslate nohighlight">\(V = P^{-1} V'\)</span> such that <cite>A = V W V^{dagger}</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.eigvalsh">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">eigvalsh</code><span class="sig-paren">(</span><em>a</em>, <em>UPLO='L'</em>, <em>sort=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#eigvalsh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.eigvalsh" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate eigenvalues for a hermitian matrix.</p>
<p><strong>Assumes</strong> that a is hermitian, <code class="docutils literal notranslate"><span class="pre">a.conj().transpose()</span> <span class="pre">==</span> <span class="pre">a</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The hermitian square matrix to be diagonalized.</p>
</dd>
<dt><strong>UPLO</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘L’, ‘U’}</span></dt>
<dd><p class="first last">Whether to take the lower (‘L’, default) or upper (‘U’) triangular part of <cite>a</cite>.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘m&gt;’, ‘m&lt;’, ‘&gt;’, ‘&lt;’, <code class="docutils literal notranslate"><span class="pre">None</span></code>}</span></dt>
<dd><p class="first last">How the eigenvalues should are sorted <em>within</em> each charge block.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is same as ‘&lt;’. See <code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code> for details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">The eigenvalues, sorted within the same charge blocks according to <cite>sort</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The eigenvalues are sorted within blocks of the completely blocked legs.</p>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.eigvals">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">eigvals</code><span class="sig-paren">(</span><em>a</em>, <em>sort=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#eigvals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.eigvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate eigenvalues for a hermitian matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The hermitian square matrix to be diagonalized.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘m&gt;’, ‘m&lt;’, ‘&gt;’, ‘&lt;’, <code class="docutils literal notranslate"><span class="pre">None</span></code>}</span></dt>
<dd><p class="first last">How the eigenvalues should are sorted <em>within</em> each charge block.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is same as ‘&lt;’. See <code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code> for details.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">The eigenvalues, sorted within the same charge blocks according to <cite>sort</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The eigenvalues are sorted within blocks of the completely blocked legs.</p>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.speigs">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">speigs</code><span class="sig-paren">(</span><em>a</em>, <em>charge_sector</em>, <em>k</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#speigs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.speigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse eigenvalue decomposition <code class="docutils literal notranslate"><span class="pre">w,</span> <span class="pre">v</span></code> of square <cite>a</cite> in a given charge sector.</p>
<p>Finds <cite>k</cite> right eigenvectors (chosen by <code class="docutils literal notranslate"><span class="pre">kwargs['which']</span></code>) in a given charge sector,
<code class="docutils literal notranslate"><span class="pre">tensordot(A,</span> <span class="pre">V[i],</span> <span class="pre">axes=1)</span> <span class="pre">=</span> <span class="pre">W[i]</span> <span class="pre">*</span> <span class="pre">V[i]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A square array with contractible legs and vanishing total charge.</p>
</dd>
<dt><strong>charge_sector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last"><cite>ndim</cite> charges to select the block.</p>
</dd>
<dt><strong>k</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">How many eigenvalues/vectors should be calculated.
If the block of <cite>charge_sector</cite> is smaller than <cite>k</cite>, <cite>k</cite> may be reduced accordingly.</p>
</dd>
<dt><strong>*args, **kwargs :</strong></dt>
<dd><p class="first last">Additional arguments given to <cite>scipy.sparse.linalg.eigs</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last"><cite>k</cite> (or less) eigenvalues</p>
</dd>
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last"><cite>k</cite> (or less) right eigenvectors of <cite>A</cite> with total charge <cite>charge_sector</cite>.
Note that when interpreted as a matrix,
this is the transpose of what <code class="docutils literal notranslate"><span class="pre">np.eigs</span></code> normally gives.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.qr">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">qr</code><span class="sig-paren">(</span><em>a, mode='reduced', inner_labels=[None, None]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#qr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.qr" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-R decomposition of a matrix.</p>
<p>Decomposition such that <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">==</span> <span class="pre">npc.tensordot(q,</span> <span class="pre">r,</span> <span class="pre">axes=1)</span></code> up to numerical rounding errors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A square matrix to be exponentiated, shape <code class="docutils literal notranslate"><span class="pre">(M,N)</span></code>.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘reduced’, ‘complete’</span></dt>
<dd><p class="first last">‘reduced’: return <cite>q</cite> and <cite>r</cite> with shapes (M,K) and (K,N), where K=min(M,N)
‘complete’: return <cite>q</cite> with shape (M,M).</p>
</dd>
<dt><strong>inner_labels: [{str|None}, {str|None}]</strong></dt>
<dd><p class="first last">The first label is used for <code class="docutils literal notranslate"><span class="pre">Q.legs[1]</span></code>, the second for <code class="docutils literal notranslate"><span class="pre">R.legs[0]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">If <cite>mode</cite> is ‘complete’, a unitary matrix.
For <cite>mode</cite> ‘reduced’ such thatOtherwise such that
<span class="math notranslate nohighlight">\(q^{*}_{j,i} q_{j,k} = \delta_{i,k}\)</span></p>
</dd>
<dt><strong>r</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Upper triangular matrix if both legs of A are sorted by charges;
Otherwise a simple transposition (performed when sorting by charges) brings it to
upper triangular form.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.expm">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">expm</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#expm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.expm" title="Permalink to this definition">¶</a></dt>
<dd><p>Use scipy.linalg.expm to calculate the matrix exponential of a square matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">A square matrix to be exponentiated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_a</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The matrix exponential <code class="docutils literal notranslate"><span class="pre">expm(a)</span></code>, calculated using scipy.linalg.expm.
Same legs/labels as <cite>a</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tenpy.linalg.np_conserved.to_iterable_arrays">
<code class="descclassname">tenpy.linalg.np_conserved.</code><code class="descname">to_iterable_arrays</code><span class="sig-paren">(</span><em>array_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#to_iterable_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.to_iterable_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar as <a class="reference internal" href="tenpy.tools.misc.html#tenpy.tools.misc.to_iterable" title="tenpy.tools.misc.to_iterable"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_iterable()</span></code></a>, but also enclose npc Arrays in a list.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">tenpy.linalg.np_conserved module</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.linalg.lanczos.html"
                        title="previous chapter">tenpy.linalg.lanczos module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.linalg.npc_helper.html"
                        title="next chapter">tenpy.linalg.npc_helper module</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tenpy.html">Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.algorithms.html">tenpy.algorithms package</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.linalg.html">tenpy.linalg package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.html">tenpy.models package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.html">tenpy.networks package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.tools.html">tenpy.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#module-tenpy">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.npc_helper.html" title="tenpy.linalg.npc_helper module"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.lanczos.html" title="tenpy.linalg.lanczos module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.linalg.html" >tenpy.linalg package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 05, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>