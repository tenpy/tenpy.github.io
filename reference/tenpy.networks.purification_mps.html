
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>purification_mps &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PurificationMPS" href="tenpy.networks.purification_mps.PurificationMPS.html" />
    <link rel="prev" title="grid_insert_ops" href="tenpy.networks.mpo.grid_insert_ops.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.purification_mps.PurificationMPS.html" title="PurificationMPS"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mpo.grid_insert_ops.html" title="grid_insert_ops"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.networks.html" accesskey="U">networks</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="purification-mps">
<h1>purification_mps<a class="headerlink" href="#purification-mps" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>full name: tenpy.networks.purification_mps</li>
<li>parent module: <a class="reference internal" href="tenpy.networks.html#module-tenpy.networks" title="tenpy.networks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.networks</span></code></a></li>
<li>type: module</li>
</ul>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS" title="tenpy.networks.purification_mps.PurificationMPS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PurificationMPS</span></code></a>(sites,&nbsp;Bs,&nbsp;SVs[,&nbsp;bc,&nbsp;form,&nbsp;norm])</td>
<td>An MPS representing a finite-temperature ensemble using purification.</td>
</tr>
</tbody>
</table>
<p class="rubric">Module description</p>
<span class="target" id="module-tenpy.networks.purification_mps"></span><p>This module contains an MPS class representing an density matrix by purification.</p>
<p>Usually, an MPS represents a pure state, i.e. the density matrix is <span class="math notranslate nohighlight">\(\rho = |\psi&gt;&lt;\psi|\)</span>,
describing observables as <span class="math notranslate nohighlight">\(&lt;O&gt; = Tr(O|\psi&gt;&lt;\psi|) = &lt;\psi|O|\psi&gt;\)</span>.
Clearly, if <span class="math notranslate nohighlight">\(|\psi&gt;\)</span> is the ground state of a Hamiltonian, this is the density matrix at
<cite>T=0</cite>.</p>
<p>At finite temperatures <span class="math notranslate nohighlight">\(T &gt; 0\)</span>, we want to describe a non-pure density matrix
<span class="math notranslate nohighlight">\(\rho = \exp(-H/T)\)</span>. This can be accieved by the so-called purification: in addition to
the physical space <cite>P</cite>, we introduce a second ‘auxiliar’ space <cite>Q</cite> and define the density matrix
of the physical system as <span class="math notranslate nohighlight">\(\rho = Tr_Q(|\phi&gt;&lt;\phi|)\)</span>, where <span class="math notranslate nohighlight">\(|\phi&gt;\)</span> is a pure state
in the combined phyisical and auxiliar system.</p>
<p>For <span class="math notranslate nohighlight">\(T=\infty\)</span>, the density matrix <span class="math notranslate nohighlight">\(\rho_\infty\)</span> is the identity matrix.
In other words, expectation values are sums over all possible states
<span class="math notranslate nohighlight">\(&lt;O&gt; = Tr_P(\rho_\infty O) = Tr_P(O)\)</span>.
Saying that each <code class="docutils literal notranslate"><span class="pre">:</span></code> on top is to be connected with the corresponding <code class="docutils literal notranslate"><span class="pre">:</span></code> on the bottom,
the trace is simply a contraction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>         <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>
<span class="o">|</span>         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">|</span>         <span class="o">|-------------------|</span>
<span class="o">|</span>         <span class="o">|</span>        <span class="n">O</span>          <span class="o">|</span>
<span class="o">|</span>         <span class="o">|-------------------|</span>
<span class="o">|</span>         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">|</span>         <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>
</pre></div>
</div>
<p>Clearly, we get the same result, if we insert an identity operator, written as MPO, on the top
and bottom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>         <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>
<span class="o">|</span>         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">|</span>         <span class="n">B</span><span class="o">---</span><span class="n">B</span><span class="o">---</span><span class="n">B</span><span class="o">---</span><span class="n">B</span><span class="o">---</span><span class="n">B</span><span class="o">---</span><span class="n">B</span>
<span class="o">|</span>         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">|</span>         <span class="o">|-------------------|</span>
<span class="o">|</span>         <span class="o">|</span>        <span class="n">O</span>          <span class="o">|</span>
<span class="o">|</span>         <span class="o">|-------------------|</span>
<span class="o">|</span>         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">|</span>         <span class="n">B</span><span class="o">*--</span><span class="n">B</span><span class="o">*--</span><span class="n">B</span><span class="o">*--</span><span class="n">B</span><span class="o">*--</span><span class="n">B</span><span class="o">*--</span><span class="n">B</span><span class="o">*</span>
<span class="o">|</span>         <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>   <span class="o">|</span>
<span class="o">|</span>         <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>   <span class="p">:</span>
</pre></div>
</div>
<p>We  use the following label convention:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>         <span class="n">q</span>
<span class="o">|</span>         <span class="o">^</span>
<span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>  <span class="n">vL</span> <span class="o">-&gt;-</span> <span class="n">B</span> <span class="o">-&gt;-</span> <span class="n">vR</span>
<span class="o">|</span>         <span class="o">|</span>
<span class="o">|</span>         <span class="o">^</span>
<span class="o">|</span>         <span class="n">p</span>
</pre></div>
</div>
<p>You can view the <cite>MPO</cite> as an MPS by combining the <cite>p</cite> and <cite>q</cite> leg and defining every physical
operator to act trivial on the <cite>q</cite> leg. In expecation values, you would then sum over
over the <cite>q</cite> legs, which is exactly what we need.
In other words, the choice <span class="math notranslate nohighlight">\(B = \delta_{p,q}\)</span> with trivial (length-1) virtual bonds yields
infinite temperature expectation values for operators action only on the <cite>p</cite> legs!</p>
<p>Now, you go a step further and also apply imaginary time evolution (acting only on <cite>p</cite> legs)
to the initial infinite temperature state.
For example, the normalized state <span class="math notranslate nohighlight">\(|\psi&gt; \propto \exp(-\beta/2 H)|\phi&gt;\)</span>
yields expecation values</p>
<div class="math notranslate nohighlight">
\[&lt;O&gt;  = Tr(\exp(-\beta H) O) / Tr(\exp(-\beta H))
\propto &lt;\phi|\exp(-\beta/2 H) O \exp(-\beta/2 H)|\phi&gt;.\]</div>
<p>An additional real-time evolution allows to calculate time correlation functions:</p>
<div class="math notranslate nohighlight">
\[&lt;A(t)B(0)&gt; \propto &lt;\phi|\exp(-\beta H/2) \exp(+i H t) A \exp(-i H t) B \exp(-\beta H/2) |\phi&gt;\]</div>
<p>See also <a class="reference internal" href="../literature.html#karrasch2013" id="id1">[Karrasch2013]</a> for additional tricks! On of their crucial observations is, that
one can apply arbitrary unitaries on the auxiliar space (i.e. the <cite>q</cite>) without changing the result.
This can actually be used to reduce the necessary virtual bond dimensions:
From the definition, it is easy to see that if we apply <span class="math notranslate nohighlight">\(exp(-i H t)\)</span> to the <cite>p</cite> legs of
<span class="math notranslate nohighlight">\(|\phi&gt;\)</span>, and <span class="math notranslate nohighlight">\(\exp(+iHt)\)</span> to the <cite>q</cite> legs, they just cancel out!
(They commute with <span class="math notranslate nohighlight">\(\exp(-\beta H/2)\)</span>…)
If the state is modified (e.g. by applying <cite>A</cite> or <cite>B</cite> to calculate correlation functions),
this is not true any more. However, we still can find unitaries, which are ‘optimal’ in the sense
of reducing the entanglement of the MPS/MPO to the minimal value.
For a discussion of <cite>Disentanglers</cite> (implemented in <a class="reference internal" href="tenpy.algorithms.purification_tebd.html#module-tenpy.algorithms.purification_tebd" title="tenpy.algorithms.purification_tebd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">purification_tebd</span></code></a>),
see <a class="reference internal" href="../literature.html#hauschild2018" id="id2">[Hauschild2018]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The classes <code class="xref py py-class docutils literal notranslate"><span class="pre">MPSEnvironment</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">TransferMatrix</span></code> should also work for the
<a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS" title="tenpy.networks.purification_mps.PurificationMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">PurificationMPS</span></code></a> defined here.
For example, you can use <a class="reference internal" href="tenpy.networks.mps.MPSEnvironment.html#tenpy.networks.mps.MPSEnvironment.expectation_value" title="tenpy.networks.mps.MPSEnvironment.expectation_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expectation_value()</span></code></a>
for the expectation value of operators between different PurificationMPS.
However, this makes only sense if the <em>same</em> disentangler was applied
to the <cite>bra</cite> and <cite>ket</cite> PurificationMPS.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The literature (e.g. section 7.2 of <a class="reference internal" href="../literature.html#schollwoeck2011" id="id3">[Schollwoeck2011]</a> or <a class="reference internal" href="../literature.html#karrasch2013" id="id4">[Karrasch2013]</a>) suggests to use
a <cite>singlet</cite> as a maximally entangled state.
Here, we use instead the identity <span class="math notranslate nohighlight">\(\delta_{p,q}\)</span>, since it is easier to
generalize for <cite>p</cite> running over more than two indices, and allows a simple use of charge
conservation with the above <cite>qconj</cite> convention.
Moreover, we don’t split the physical and auxiliar space into separate sites, which makes
TEBD as costly as <span class="math notranslate nohighlight">\(O(d^6 \chi^3)\)</span>.</p>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">One can also look at the canonical ensembles by defining the conserved quantities
differently, see Barthel (2016), <a class="reference external" href="https://arxiv.org/abs/1607.01696">arXiv:1607.01696</a> for details.
Idea: usual charges on <cite>p</cite>, trivial charges on <cite>q</cite>; fix total charge to desired value.
I think it should suffice to implement another <cite>from_infiniteT</cite>.</p>
</div>
<dl class="class">
<dt id="tenpy.networks.purification_mps.PurificationMPS">
<em class="property">class </em><code class="descclassname">tenpy.networks.purification_mps.</code><code class="descname">PurificationMPS</code><span class="sig-paren">(</span><em>sites</em>, <em>Bs</em>, <em>SVs</em>, <em>bc='finite'</em>, <em>form='B'</em>, <em>norm=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tenpy.networks.mps.MPS.html#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.networks.mps.MPS</span></code></a></p>
<p>An MPS representing a finite-temperature ensemble using purification.</p>
<p>Similar as an MPS, but each <cite>B</cite> has now the four legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR',</span> <span class="pre">'p',</span> <span class="pre">'q'</span></code>.
From the point of algorithms, it is to be considered as a ususal MPS by combining the legs
<cite>p</cite> and <cite>q</cite>, but all physical operators act only on the <cite>p</cite> part.
For example, the right-canonical form is defined as if the legs ‘p’ and ‘q’ would be combined,
e.g. a right-canonical <cite>B</cite> full-fills:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">npc</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="n">axes</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;vR&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;vR*&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">,</span> <span class="s1">&#39;q*&#39;</span><span class="p">]])</span> <span class="o">==</span> \
    <span class="n">npc</span><span class="o">.</span><span class="n">eye_like</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;vL&#39;</span><span class="p">)</span>  <span class="c1"># up to round-off errors</span>
</pre></div>
</div>
<p>For expectation values / correlation functions, all operators are to understood to act on
<cite>p</cite> only, i.e. they act trivial on <cite>q</cite>, so we just trace over <code class="docutils literal notranslate"><span class="pre">'q',</span> <span class="pre">'q*'</span></code>.</p>
<p>See also the docstring of the module for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.L" title="tenpy.networks.purification_mps.PurificationMPS.L"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L</span></code></a></dt>
<dd><p class="first last">Number of physical sites.</p>
</dd>
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.chi" title="tenpy.networks.purification_mps.PurificationMPS.chi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi</span></code></a></dt>
<dd><p class="first last">Dimensions of the (nontrivial) virtual bonds.</p>
</dd>
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.dim" title="tenpy.networks.purification_mps.PurificationMPS.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a></dt>
<dd><p class="first last">List of local physical dimensions.</p>
</dd>
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.finite" title="tenpy.networks.purification_mps.PurificationMPS.finite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finite</span></code></a></dt>
<dd><p class="first last">Distinguish MPS (<code class="docutils literal notranslate"><span class="pre">True;</span> <span class="pre">bc='finite',</span> <span class="pre">'segment'</span></code> ) vs.</p>
</dd>
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.nontrivial_bonds" title="tenpy.networks.purification_mps.PurificationMPS.nontrivial_bonds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a></dt>
<dd><p class="first last">Slice of the non-trivial bond indices, depending on <code class="docutils literal notranslate"><span class="pre">self.bc</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.add" title="tenpy.networks.purification_mps.PurificationMPS.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(other,&nbsp;alpha,&nbsp;beta[,&nbsp;cutoff])</td>
<td>Return an MPS which represents <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.apply_local_op" title="tenpy.networks.purification_mps.PurificationMPS.apply_local_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_local_op</span></code></a>(i,&nbsp;op[,&nbsp;unitary,&nbsp;renormalize])</td>
<td>Apply a local operator to <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.average_charge" title="tenpy.networks.purification_mps.PurificationMPS.average_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_charge</span></code></a>([bond])</td>
<td>Return the average charge for the block on the left of a given bond.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form</span></code></a>([renormalize])</td>
<td>Bring self into canonical ‘B’ form, (re-)calculate singular values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form_finite" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form_finite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form_finite</span></code></a>([renormalize,&nbsp;cutoff])</td>
<td>Bring a finite (or segment) MPS into canonical form (in place).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form_infinite" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form_infinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form_infinite</span></code></a>([renormalize,&nbsp;tol_xi])</td>
<td>Bring an infinite MPS into canonical form (in place).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.charge_variance" title="tenpy.networks.purification_mps.PurificationMPS.charge_variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">charge_variance</span></code></a>([bond])</td>
<td>Return the charge variance on the left of a given bond.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.compute_K" title="tenpy.networks.purification_mps.PurificationMPS.compute_K"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_K</span></code></a>(perm[,&nbsp;swap_op,&nbsp;trunc_par,&nbsp;…])</td>
<td>Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.convert_form" title="tenpy.networks.purification_mps.PurificationMPS.convert_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_form</span></code></a>([new_form])</td>
<td>Tranform self into different canonical form (by scaling the legs with singular values).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.copy" title="tenpy.networks.purification_mps.PurificationMPS.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Returns a copy of <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.correlation_function" title="tenpy.networks.purification_mps.PurificationMPS.correlation_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_function</span></code></a>(ops1,&nbsp;ops2[,&nbsp;sites1,&nbsp;…])</td>
<td>Correlation function  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op1_i</span> <span class="pre">op2_j|psi&gt;/&lt;psi|psi&gt;</span></code> of single site operators.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.correlation_length" title="tenpy.networks.purification_mps.PurificationMPS.correlation_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_length</span></code></a>([target,&nbsp;tol_ev0])</td>
<td>Calculate the correlation length by diagonalizing the transfer matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy" title="tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_entropy</span></code></a>([n,&nbsp;bonds,&nbsp;for_matrix_S])</td>
<td>Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy_segment" title="tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_entropy_segment</span></code></a>([segment,&nbsp;…])</td>
<td>Calculate entanglement entropy for general geometry of the bipartition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.entanglement_spectrum" title="tenpy.networks.purification_mps.PurificationMPS.entanglement_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_spectrum</span></code></a>([by_charge])</td>
<td>return entanglement energy spectrum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.expectation_value" title="tenpy.networks.purification_mps.PurificationMPS.expectation_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value</span></code></a>(ops[,&nbsp;sites,&nbsp;axes])</td>
<td>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;</span></code> of (n-site) operator(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.expectation_value_multi_sites" title="tenpy.networks.purification_mps.PurificationMPS.expectation_value_multi_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_multi_sites</span></code></a>(operators,&nbsp;i0)</td>
<td>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.expectation_value_term" title="tenpy.networks.purification_mps.PurificationMPS.expectation_value_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_term</span></code></a>(term[,&nbsp;autoJW])</td>
<td>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.expectation_value_terms_sum" title="tenpy.networks.purification_mps.PurificationMPS.expectation_value_terms_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_terms_sum</span></code></a>(term_list,&nbsp;…)</td>
<td>Calculate expectation values for a bunch of terms and sum them up.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.from_Bflat" title="tenpy.networks.purification_mps.PurificationMPS.from_Bflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_Bflat</span></code></a>(sites,&nbsp;Bflat[,&nbsp;SVs,&nbsp;bc,&nbsp;dtype,&nbsp;…])</td>
<td>Construct a matrix product state from a set of numpy arrays <cite>Bflat</cite> and singular vals.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.from_full" title="tenpy.networks.purification_mps.PurificationMPS.from_full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_full</span></code></a>(sites,&nbsp;psi[,&nbsp;form,&nbsp;cutoff,&nbsp;normalize])</td>
<td>Construct an MPS from a single tensor <cite>psi</cite> with one leg per physical site.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.from_infiniteT" title="tenpy.networks.purification_mps.PurificationMPS.from_infiniteT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_infiniteT</span></code></a>(sites[,&nbsp;bc,&nbsp;form])</td>
<td>Initial state corresponding to infinite-Temperature ensemble.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.from_product_state" title="tenpy.networks.purification_mps.PurificationMPS.from_product_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_product_state</span></code></a>(sites,&nbsp;p_state[,&nbsp;bc,&nbsp;…])</td>
<td>Construct a matrix product state from a given product state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.from_singlets" title="tenpy.networks.purification_mps.PurificationMPS.from_singlets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_singlets</span></code></a>(site,&nbsp;L,&nbsp;pairs[,&nbsp;up,&nbsp;down,&nbsp;…])</td>
<td>Create an MPS of entangled singlets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.gauge_total_charge" title="tenpy.networks.purification_mps.PurificationMPS.gauge_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_total_charge</span></code></a>([qtotal,&nbsp;vL_leg,&nbsp;vR_leg])</td>
<td>Gauge the legcharges of the virtual bonds such that the MPS has a total <cite>qtotal</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_B" title="tenpy.networks.purification_mps.PurificationMPS.get_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_B</span></code></a>(i[,&nbsp;form,&nbsp;copy,&nbsp;cutoff,&nbsp;label_p])</td>
<td>Return (view of) <cite>B</cite> at site <cite>i</cite> in canonical form.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_SL" title="tenpy.networks.purification_mps.PurificationMPS.get_SL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_SL</span></code></a>(i)</td>
<td>Return singular values on the left of site <cite>i</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_SR" title="tenpy.networks.purification_mps.PurificationMPS.get_SR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_SR</span></code></a>(i)</td>
<td>Return singular values on the right of site <cite>i</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_grouped_mps" title="tenpy.networks.purification_mps.PurificationMPS.get_grouped_mps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_grouped_mps</span></code></a>(blocklen)</td>
<td>contract blocklen subsequent tensors into a single one and return result as a new MPS.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_op" title="tenpy.networks.purification_mps.PurificationMPS.get_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_op</span></code></a>(op_list,&nbsp;i)</td>
<td>Given a list of operators, select the one corresponding to site <cite>i</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_rho_segment" title="tenpy.networks.purification_mps.PurificationMPS.get_rho_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_rho_segment</span></code></a>(segment)</td>
<td>Return reduced density matrix for a segment.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_theta" title="tenpy.networks.purification_mps.PurificationMPS.get_theta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_theta</span></code></a>(i[,&nbsp;n,&nbsp;cutoff,&nbsp;formL,&nbsp;formR])</td>
<td>Calculates the <cite>n</cite>-site wavefunction on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_total_charge" title="tenpy.networks.purification_mps.PurificationMPS.get_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_total_charge</span></code></a>()</td>
<td>Calculate and return the <cite>qtotal</cite> of the whole MPS (when contracted).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.group_sites" title="tenpy.networks.purification_mps.PurificationMPS.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> inplace to group sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.group_split" title="tenpy.networks.purification_mps.PurificationMPS.group_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_split</span></code></a>([trunc_par])</td>
<td>Modify <cite>self</cite> inplace to split previously grouped sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.init_LP" title="tenpy.networks.purification_mps.PurificationMPS.init_LP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_LP</span></code></a>(i[,&nbsp;bra,&nbsp;mpo])</td>
<td>Build initial left part <code class="docutils literal notranslate"><span class="pre">LP</span></code> for an MPS/MPOEnvironment.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.init_RP" title="tenpy.networks.purification_mps.PurificationMPS.init_RP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_RP</span></code></a>(i[,&nbsp;bra,&nbsp;mpo])</td>
<td>Build initial right part <code class="docutils literal notranslate"><span class="pre">RP</span></code> for an MPS/MPOEnvironment.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.mutinf_two_site" title="tenpy.networks.purification_mps.PurificationMPS.mutinf_two_site"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutinf_two_site</span></code></a>([max_range,&nbsp;n,&nbsp;legs])</td>
<td>Calculate the two-site mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.norm_test" title="tenpy.networks.purification_mps.PurificationMPS.norm_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_test</span></code></a>()</td>
<td>Check that self is in canonical form.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.overlap" title="tenpy.networks.purification_mps.PurificationMPS.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code></a>(other[,&nbsp;charge_sector,&nbsp;ignore_form])</td>
<td>Compute overlap <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.permute_sites" title="tenpy.networks.purification_mps.PurificationMPS.permute_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute_sites</span></code></a>(perm[,&nbsp;swap_op,&nbsp;trunc_par,&nbsp;…])</td>
<td>Applies the permutation perm to the state (inplace).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.probability_per_charge" title="tenpy.networks.purification_mps.PurificationMPS.probability_per_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">probability_per_charge</span></code></a>([bond])</td>
<td>Return probabilites of charge value on the left of a given bond.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.set_B" title="tenpy.networks.purification_mps.PurificationMPS.set_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_B</span></code></a>(i,&nbsp;B[,&nbsp;form])</td>
<td>Set <cite>B</cite> at site <cite>i</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.set_SL" title="tenpy.networks.purification_mps.PurificationMPS.set_SL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_SL</span></code></a>(i,&nbsp;S)</td>
<td>Set singular values on the left of site <cite>i</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.set_SR" title="tenpy.networks.purification_mps.PurificationMPS.set_SR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_SR</span></code></a>(i,&nbsp;S)</td>
<td>Set singular values on the right of site <cite>i</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.swap_sites" title="tenpy.networks.purification_mps.PurificationMPS.swap_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_sites</span></code></a>(i[,&nbsp;swapOP,&nbsp;trunc_par])</td>
<td>Swap the two neighboring sites <cite>i</cite> and <cite>i+1</cite> (inplace).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.test_sanity" title="tenpy.networks.purification_mps.PurificationMPS.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises Errors if something is wrong.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of <cite>self</cite>.</p>
<p>The copy still shares the sites, chinfo, and LegCharges of the _B,
but the values of B and S are deeply copied.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.purification_mps.PurificationMPS.from_infiniteT">
<em class="property">classmethod </em><code class="descname">from_infiniteT</code><span class="sig-paren">(</span><em>sites</em>, <em>bc='finite'</em>, <em>form='B'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS.from_infiniteT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.from_infiniteT" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial state corresponding to infinite-Temperature ensemble.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘finite’, ‘segment’, ‘infinite’}</span></dt>
<dd><p class="first last">MPS boundary conditions as described in <a class="reference internal" href="tenpy.networks.mps.MPS.html#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">The canonical form of the stored ‘matrices’, see table in <a class="reference internal" href="tenpy.networks.mps.html#module-tenpy.networks.mps" title="tenpy.networks.mps"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mps</span></code></a>.
A single choice holds for all of the entries.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>infiniteT_MPS</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS" title="tenpy.networks.purification_mps.PurificationMPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">PurificationMPS</span></code></a></span></dt>
<dd><p class="first last">Describes the infinite-temperature (grand canonical) ensemble,
i.e. expectation values give a trace over all basis states.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy_segment">
<code class="descname">entanglement_entropy_segment</code><span class="sig-paren">(</span><em>segment=[0], first_site=None, n=1, legs='p'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS.entanglement_entropy_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate entanglement entropy for general geometry of the bipartition.</p>
<p>This function is similar as <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy" title="tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">entanglement_entropy()</span></code></a>,
but for more general geometry of the region <cite>A</cite> to be a segment of a <em>few</em> sites.</p>
<p>This is acchieved by explicitly calculating the reduced density matrix of <cite>A</cite>
and thus works only for small segments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>segment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">Given a first site <cite>i</cite>, the region <code class="docutils literal notranslate"><span class="pre">A_i</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">[i+j</span> <span class="pre">for</span> <span class="pre">j</span> <span class="pre">in</span> <span class="pre">segment]</span></code>.</p>
</dd>
<dt><strong>first_site</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | (iterable of) int</span></dt>
<dd><p class="first last">Calculate the entropy for segments starting at these sites.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">range(L-segment[-1])</span></code> for finite
or <cite>range(L)</cite> for infinite boundary conditions.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | float</span></dt>
<dd><p class="first last">Selects which entropy to calculate;
<cite>n=1</cite> (default) is the ususal von-Neumann entanglement entropy,
otherwise the <cite>n</cite>-th Renyi entropy.</p>
</dd>
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘p’, ‘q’, ‘pq’</span></dt>
<dd><p class="first last">Whether we look at the entanglement entropy in both (<cite>pq</cite>) or
only one of auxiliar (<cite>q</cite>) and physical (<cite>p</cite>) space.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>entropies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">entropies[i]</span></code> contains the entropy for the the region <code class="docutils literal notranslate"><span class="pre">A_i</span></code> defined above.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.mutinf_two_site">
<code class="descname">mutinf_two_site</code><span class="sig-paren">(</span><em>max_range=None</em>, <em>n=1</em>, <em>legs='p'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS.mutinf_two_site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.mutinf_two_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-site mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span>.</p>
<p>Calculates <span class="math notranslate nohighlight">\(I(i:j) = S(i) + S(j) - S(i,j)\)</span>,
where <span class="math notranslate nohighlight">\(S(i)\)</span> is the single site entropy on site <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(S(i,j)\)</span> the two-site entropy on sites <span class="math notranslate nohighlight">\(i,j\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>max_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximal distance <code class="docutils literal notranslate"><span class="pre">|i-j|</span></code> for which the mutual information should be calculated.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <cite>L-1</cite>.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Selects the entropy to use, see <a class="reference internal" href="tenpy.tools.math.entropy.html#tenpy.tools.math.entropy" title="tenpy.tools.math.entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy()</span></code></a>.</p>
</dd>
<dt><strong>leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘p’, ‘q’, ‘pq’</span></dt>
<dd><p class="first last">Whether we look at the entanglement entropy in both (<cite>pq</cite>) or
only one of auxiliar (<cite>q</cite>) and physical (<cite>p</cite>) space.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Coordinates for the mutinf array.</p>
</dd>
<dt><strong>mutinf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">mutinf[k]</span></code> is the mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span> between the
sites <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">coords[k]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.swap_sites">
<code class="descname">swap_sites</code><span class="sig-paren">(</span><em>i</em>, <em>swapOP='auto'</em>, <em>trunc_par={}</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/purification_mps.html#PurificationMPS.swap_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.swap_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the two neighboring sites <cite>i</cite> and <cite>i+1</cite> (inplace).</p>
<p>Exchange two neighboring sites: form theta, ‘swap’ the physical legs and split
with an svd. While the ‘swap’ is just a transposition/relabeling for bosons, one needs to
be careful about the sign for fermions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Swap the two sites at positions <cite>i</cite> and <cite>i+1</cite>.</p>
</dd>
<dt><strong>swap_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The operator used to swap the phyiscal legs of the two-site wave function <cite>theta</cite>.
For <code class="docutils literal notranslate"><span class="pre">None</span></code>, just transpose/relabel the legs, for <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> also take care of
fermionic signs. Alternative give an npc <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>
which represents the full operator used for the swap.
Should have legs <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p1',</span> <span class="pre">'p0*',</span> <span class="pre">'p1*']</span></code> whith <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1*'</span></code> contractible.</p>
</dd>
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error of the represented state introduced by the truncation after the swap.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.purification_mps.PurificationMPS.L">
<code class="descname">L</code><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of physical sites. For an iMPS the len of the MPS unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>other</em>, <em>alpha</em>, <em>beta</em>, <em>cutoff=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an MPS which represents <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</p>
<p>Works only for <code class="docutils literal notranslate"><span class="pre">'finite',</span> <span class="pre">'segment'</span></code> boundary conditions.
For <cite>segment</cite> boundary conditions, the virtual legs on the very left/right are
assumed to correspond to each other (i.e. self and other have the same state outside of
the considered segment).
Takes into account <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">Another MPS of the same length to be added with self.</p>
</dd>
<dt><strong>alpha, beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex float</span></dt>
<dd><p class="first last">Prefactors for self and other. We calculate
<code class="docutils literal notranslate"><span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">|other&gt;</span></code></p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Cutoff of singular values used in the SVDs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sum</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">An MPS representing <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|other&gt;</span></code>.
Has same total charge as <cite>self</cite>.</p>
</dd>
<dt><strong>U_L, V_R</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Only returned for <code class="docutils literal notranslate"><span class="pre">'segment'</span></code> boundary conditions.
The unitaries defining the new left and right Schmidt states in terms of the old ones,
with legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.apply_local_op">
<code class="descname">apply_local_op</code><span class="sig-paren">(</span><em>i</em>, <em>op</em>, <em>unitary=None</em>, <em>renormalize=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.apply_local_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a local operator to <cite>self</cite>.</p>
<p>Note that this destroys the canonical form if the local operator is non-unitary.
Therefore, this function calls <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> if necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index of the site on which the operator should act.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | npc.Array</span></dt>
<dd><p class="first last">A physical operator acting on site <cite>i</cite>, with legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'p*'</span></code>.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>unitary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | bool</span></dt>
<dd><p class="first last">Whether <cite>op</cite> is unitary, i.e., whether the canonical form is preserved (<code class="docutils literal notranslate"><span class="pre">True</span></code>)
or whether we should call <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">False</span></code>).
<code class="docutils literal notranslate"><span class="pre">None</span></code> checks whether <code class="docutils literal notranslate"><span class="pre">norm(op</span> <span class="pre">dagger(op)</span> <span class="pre">-</span> <span class="pre">identity)</span></code> is small.</p>
</dd>
<dt><strong>renormalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the final state should keep track of the norm (False, default) or be
renormalized to have norm 1 (True).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.average_charge">
<code class="descname">average_charge</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.average_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average charge for the block on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
Then this function returns <span class="math notranslate nohighlight">\(&lt;\psi| N_b |\psi&gt;\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The bond to be considered.
The returned charges are summed over the sites left of <cite>bond</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>average_charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">For each type of charge in <code class="xref py py-attr docutils literal notranslate"><span class="pre">chinfo</span></code>
the average value when summing the charge values over sites left of the given bond.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.canonical_form">
<code class="descname">canonical_form</code><span class="sig-paren">(</span><em>renormalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.canonical_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring self into canonical ‘B’ form, (re-)calculate singular values.</p>
<p>Simply calls <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form_finite" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form_finite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form_finite()</span></code></a> or <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form_infinite" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form_infinite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form_infinite()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.canonical_form_finite">
<code class="descname">canonical_form_finite</code><span class="sig-paren">(</span><em>renormalize=True</em>, <em>cutoff=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.canonical_form_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring a finite (or segment) MPS into canonical form (in place).</p>
<p>If any site is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>, it does <em>not</em> use any of the singular values <cite>S</cite>
(for ‘finite’ boundary conditions, or only the very left <cite>S</cite> for ‘segment’ b.c.).
If all sites have a <cite>form</cite>, it respects the <cite>form</cite> to ensure
that one <cite>S</cite> is included per bond.
The final state is always in right-canonical ‘B’ form.</p>
<p>Performs one sweep left to right doing QR decompositions, and one sweep right to left
doing SVDs calculating the singular values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>renormalize: bool</strong></dt>
<dd><p class="first last">Whether a change in the norm should be discarded or used to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Cutoff of singular values used in the SVDs.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_L, V_R</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Only returned for <code class="docutils literal notranslate"><span class="pre">'segment'</span></code> boundary conditions.
The unitaries defining the new left and right Schmidt states in terms of the old ones,
with legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.canonical_form_infinite">
<code class="descname">canonical_form_infinite</code><span class="sig-paren">(</span><em>renormalize=True</em>, <em>tol_xi=1000000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.canonical_form_infinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring an infinite MPS into canonical form (in place).</p>
<p>If any site is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>, it does <em>not</em> use any of the singular values <cite>S</cite>.
If all sites have a <cite>form</cite>, it respects the <cite>form</cite> to ensure
that one <cite>S</cite> is included per bond.
The final state is always in right-canonical ‘B’ form.</p>
<p>Proceeds in three steps, namely 1) diagonalize right and left transfermatrix on a given
bond to bring that bond into canonical form, and then
2) sweep right to left, and 3) left to right to bringing other bonds into canonical form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>renormalize: bool</strong></dt>
<dd><p class="first last">Whether a change in the norm should be discarded or used to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd>
<dt><strong>tol_xi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Raise an error if the correlation length is larger than that
(which indicates a degenerate “cat” state, e.g., for spontaneous symmetry breaking).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.charge_variance">
<code class="descname">charge_variance</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.charge_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the charge variance on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
Then this function returns <span class="math notranslate nohighlight">\(&lt;\psi| N_b^2 |\psi&gt; - (&lt;\psi| N_b |\psi&gt;)^2\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The bond to be considered.
The returned charges are summed over the sites left of <cite>bond</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>average_charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">For each type of charge in <code class="xref py py-attr docutils literal notranslate"><span class="pre">chinfo</span></code>
the variance of of the charge values left of the given bond.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.purification_mps.PurificationMPS.chi">
<code class="descname">chi</code><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimensions of the (nontrivial) virtual bonds.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.compute_K">
<code class="descname">compute_K</code><span class="sig-paren">(</span><em>perm</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em>, <em>canonicalize=1e-06</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.compute_K" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</p>
<p>Works for an infinite MPS living on a cylinder, infinitely long in <cite>x</cite> direction and with
periodic boundary conditions in <cite>y</cite> directions.
If the state is invariant under ‘rotations’ around the cylinder axis, one can find the
momentum quantum numbers of it. (The rotation is nothing more than a translation in <cite>y</cite>.)
This function permutes some sites (on a copy of <cite>self</cite>) to enact the rotation, and then
finds the dominant eigenvector of the mixed transfer matrix to get the quantum numbers,
along the lines of <a class="reference internal" href="../literature.html#pollmannturner2012" id="id5">[PollmannTurner2012]</a>, see also (the appendix and Fig. 11 in the arXiv
version of) <a class="reference internal" href="../literature.html#cinciovidal2013" id="id6">[CincioVidal2013]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray | <code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></span></dt>
<dd><p class="first last">Permuation to be applied to the physical indices, see <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.permute_sites" title="tenpy.networks.purification_mps.PurificationMPS.permute_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permute_sites()</span></code></a>.
If a lattice is given, we use it to read out the lattice structure and shift
each site by one lattice-vector in y-direction (assuming periodic boundary conditions).
(If you have a <code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code>,
give its <cite>lat</cite> attribute for this argument)</p>
</dd>
<dt><strong>swap_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The operator used to swap the phyiscal legs of a two-site wave function <cite>theta</cite>,
see <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.swap_sites" title="tenpy.networks.purification_mps.PurificationMPS.swap_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swap_sites()</span></code></a>.</p>
</dd>
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation during permutation,
see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
<dt><strong>canonicalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Check that <cite>self</cite> is in canonical form; call <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a>
if <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.norm_test" title="tenpy.networks.purification_mps.PurificationMPS.norm_test"><code class="xref py py-meth docutils literal notranslate"><span class="pre">norm_test()</span></code></a> yields <code class="docutils literal notranslate"><span class="pre">np.linalg.norm(self.norm_test())</span> <span class="pre">&gt;</span> <span class="pre">canonicalize</span></code>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Level of verbosity, print status messages if verbose &gt; 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Unitary representation of the applied permutation on left Schmidt states.</p>
</dd>
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">1D array of the form <code class="docutils literal notranslate"><span class="pre">S**2</span> <span class="pre">exp(i</span> <span class="pre">K)</span></code>, where <cite>S</cite> are the Schmidt values
on the left bond. You can use <code class="xref py py-func docutils literal notranslate"><span class="pre">np.abs()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">np.angle()</span></code> to extract the
Schmidt values <cite>S</cite> and momenta <cite>K</cite> from <cite>W</cite>.</p>
</dd>
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt>
<dd><p class="first last">LegCharge corresponding to <cite>W</cite>.</p>
</dd>
<dt><strong>ov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex</span></dt>
<dd><p class="first last">The eigenvalue of the mixed transfer matrix <cite>&lt;psi|T|psi&gt;</cite> per <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.L" title="tenpy.networks.purification_mps.PurificationMPS.L"><code class="xref py py-attr docutils literal notranslate"><span class="pre">L</span></code></a> sites.
An absolute value different smaller than 1 indicates that the state is not invariant
under the permutation or that the truncation error <cite>trunc_err</cite> was too large!</p>
</dd>
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error of the represented state introduced by the truncation after swaps when
performing the truncation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.convert_form">
<code class="descname">convert_form</code><span class="sig-paren">(</span><em>new_form='B'</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.convert_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Tranform self into different canonical form (by scaling the legs with singular values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>new_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">The form the stored ‘matrices’. The table in module doc-string.
A single choice holds for all of the entries.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if trying to convert from a <code class="docutils literal notranslate"><span class="pre">None</span></code> form. Use <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.canonical_form" title="tenpy.networks.purification_mps.PurificationMPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> instead!</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.correlation_function">
<code class="descname">correlation_function</code><span class="sig-paren">(</span><em>ops1</em>, <em>ops2</em>, <em>sites1=None</em>, <em>sites2=None</em>, <em>opstr=None</em>, <em>str_on_first=True</em>, <em>hermitian=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.correlation_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlation function  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op1_i</span> <span class="pre">op2_j|psi&gt;/&lt;psi|psi&gt;</span></code> of single site operators.</p>
<p>Given the MPS in canonical form, it calculates n-site expectation values.
For examples the contraction for a two-site operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...--</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="n">op2</span>    <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">op1</span>   <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>Onsite terms are taken in the order <code class="docutils literal notranslate"><span class="pre">&lt;psi</span> <span class="pre">|</span> <span class="pre">op1</span> <span class="pre">op2</span> <span class="pre">|</span> <span class="pre">psi&gt;</span></code>.</p>
<p>If <cite>opstr</cite> is given and <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code>, it calculates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>           <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span>                               <span class="k">for</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span>
<span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...-</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---.</span>     <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...-</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">opstr</span>  <span class="n">opstr</span>        <span class="n">op2</span>    <span class="o">|</span>     <span class="o">|</span>     <span class="n">op2</span>    <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">op1</span>    <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="n">opstr</span>  <span class="n">opstr</span>        <span class="n">op1</span>    <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...-</span> <span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--.</span>     <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...-</span> <span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">i==j</span></code>, no <cite>opstr</cite> is included.
For <code class="docutils literal notranslate"><span class="pre">str_on_first=False</span></code>, the <cite>opstr</cite> on site <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">j)</span></code> is always left out.</p>
<p>Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) in the operator lists are translated into single-site
operators defined by the <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> on which they act.
Each operator should have the two legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'p*'</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ops1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">First operator of the correlation function (acting after ops2).
<code class="docutils literal notranslate"><span class="pre">ops1[x]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">sites1[x]</span></code>.
If less than <code class="docutils literal notranslate"><span class="pre">len(sites1)</span></code> operators are given, we repeat them periodically.</p>
</dd>
<dt><strong>ops2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">Second operator of the correlation function (acting before ops1).
<code class="docutils literal notranslate"><span class="pre">ops2[y]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">sites2[y]</span></code>.
If less than <code class="docutils literal notranslate"><span class="pre">len(sites2)</span></code> operators are given, we repeat them periodically.</p>
</dd>
<dt><strong>sites1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | int | list of int</span></dt>
<dd><p class="first last">List of site indices; a single <cite>int</cite> is translated to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">sites1)</span></code>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to all sites <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L)</span></code>.
Is sorted before use, i.e. the order is ignored.</p>
</dd>
<dt><strong>sites2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | int | list of int</span></dt>
<dd><p class="first last">List of site indices; a single <cite>int</cite> is translated to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">sites2)</span></code>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to all sites <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L)</span></code>.
Is sorted before use, i.e. the order is ignored.</p>
</dd>
<dt><strong>opstr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">Ignored by default (<code class="docutils literal notranslate"><span class="pre">None</span></code>).
Operator(s) to be inserted between <code class="docutils literal notranslate"><span class="pre">ops1</span></code> and <code class="docutils literal notranslate"><span class="pre">ops2</span></code>.
If given as a list, <code class="docutils literal notranslate"><span class="pre">opstr[r]</span></code> is inserted at site <cite>r</cite> (independent of <cite>sites1</cite> and
<cite>sites2</cite>).</p>
</dd>
<dt><strong>str_on_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the <cite>opstr</cite> is included on the site <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">j)</span></code>.
Note the order, which is chosen that way to handle fermionic Jordan-Wigner strings
correctly. (In other words: choose <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code> for fermions!)</p>
</dd>
<dt><strong>hermitian</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Optimization flag: if <code class="docutils literal notranslate"><span class="pre">sites1</span> <span class="pre">==</span> <span class="pre">sites2</span></code> and <code class="docutils literal notranslate"><span class="pre">Ops1[i]^\dagger</span> <span class="pre">==</span> <span class="pre">Ops2[i]</span></code>
(which is not checked explicitly!), the resulting <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span></code> will be hermitian.
We can use that to avoid calculations, so <code class="docutils literal notranslate"><span class="pre">hermitian=True</span></code> will run faster.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>C</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span></dt>
<dd><p class="first">The correlation function <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">ops1[i]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">i=sites1[x]</span></code> and <code class="docutils literal notranslate"><span class="pre">ops2[j]</span></code> on site <code class="docutils literal notranslate"><span class="pre">j=sites2[y]</span></code>.
If <cite>opstr</cite> is given, it gives (for <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code>):</p>
<ul class="simple">
<li>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">prod_{i</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">j}</span> <span class="pre">opstr[r]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|prod_{j</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">i}</span> <span class="pre">opstr[r]</span> <span class="pre">ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</li>
</ul>
<p class="last">The condition <code class="docutils literal notranslate"><span class="pre">&lt;=</span> <span class="pre">r</span></code> is replaced by a strict <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">r</span></code>, if <code class="docutils literal notranslate"><span class="pre">str_on_first=False</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.correlation_length">
<code class="descname">correlation_length</code><span class="sig-paren">(</span><em>target=1</em>, <em>tol_ev0=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation length by diagonalizing the transfer matrix.</p>
<p>Assumes that <cite>self</cite> is in canonical form.</p>
<p>Works only for infinite MPS, where the transfer matrix is a useful concept.
Assuming a single-site unit cell, any correlation function splits into
<span class="math notranslate nohighlight">\(C(A_i, B_j) = A'_i T^{j-i-1} B'_j\)</span>
with some parts left and right and the <span class="math notranslate nohighlight">\(j-i-1\)</span>-th power of the transfer matrix in
between. The largest eigenvalue is 1 (if self is properly normalized)
and gives the dominant contribution of
<span class="math notranslate nohighlight">\(A'_i E_1 * 1^{j-i-1} * E_1^T B'_j = &lt;A&gt; &lt;B&gt;\)</span>,
and the second largest one gives a contribution <span class="math notranslate nohighlight">\(\propto \lambda_2^{j-i-1}\)</span>.
Thus <span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{1}{\xi})\)</span>.</p>
<p>More general for a <cite>L</cite>-site unit cell we get <span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{L}{\xi})\)</span>,
where the <cite>xi</cite> is given in units of 1 lattice spacing in the MPS.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For a higher-dimensional lattice (which the MPS class doesn’t know about),
the correct unit is the lattice spacing in x-direction, and the correct formula is
<span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{L_x}{\xi})\)</span>,
where <cite>L_x</cite> is the number of lattice spacings in the infinite direction within the
MPS unit cell, e.g. the number of “rings” of a cylinder in the MPS unit cell.
To get to these units, divide the returned <cite>xi</cite> by the number of sites within a “ring”,
for a lattice given in <code class="xref py py-attr docutils literal notranslate"><span class="pre">N_sites_per_ring</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">We look for the <cite>target</cite> + 1 largest eigenvalues.</p>
</dd>
<dt><strong>tol_ev0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Print warning if largest eigenvalue deviates from 1 by more than <cite>tol_ev0</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>xi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | 1D array</span></dt>
<dd><p class="first last">If <cite>target`=1, return just the correlation length,
otherwise an array of the `target</cite> largest correlation lengths.
It is measured in units of a single lattice spacing in the MPS language,
see the warning above.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.purification_mps.PurificationMPS.dim">
<code class="descname">dim</code><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>List of local physical dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy">
<code class="descname">entanglement_entropy</code><span class="sig-paren">(</span><em>n=1</em>, <em>bonds=None</em>, <em>for_matrix_S=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.entanglement_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</p>
<p>Consider a bipartition of the sytem into <span class="math notranslate nohighlight">\(A = \{ j: j &lt;= i_b \}\)</span> and
<span class="math notranslate nohighlight">\(B = \{ j: j &gt; i_b\}\)</span> and the reduced density matrix <span class="math notranslate nohighlight">\(\rho_A = tr_B(\rho)\)</span>.
The von-Neumann entanglement entropy is defined as
<span class="math notranslate nohighlight">\(S(A, n=1) = -tr(\rho_A \log(\rho_A)) = S(B, n=1)\)</span>.
The generalization for <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">!=</span> <span class="pre">1,</span> <span class="pre">n&gt;0</span></code> are the Renyi entropies:
<span class="math notranslate nohighlight">\(S(A, n) = \frac{1}{1-n} \log(tr(\rho_A^2)) = S(B, n=1)\)</span></p>
<p>This function calculates the entropy for a cut at different bonds <cite>i</cite>, for which the
the eigenvalues of the reduced density matrix <span class="math notranslate nohighlight">\(\rho_A\)</span> and <span class="math notranslate nohighlight">\(\rho_B\)</span> is given
by the squared schmidt values <cite>S</cite> of the bond.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/float</span></dt>
<dd><p class="first last">Selects which entropy to calculate;
<cite>n=1</cite> (default) is the ususal von-Neumann entanglement entropy.</p>
</dd>
<dt><strong>bonds</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | (iterable of) int</span></dt>
<dd><p class="first last">Selects the bonds at which the entropy should be calculated.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L+1)[self.nontrivial_bonds]</span></code>.</p>
</dd>
<dt><strong>for_matrix_S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Switch calculate the entanglement entropy even if the <cite>_S</cite> are matrices.
Since <span class="math notranslate nohighlight">\(O(\chi^3)\)</span> is expensive compared to the ususal <span class="math notranslate nohighlight">\(O(\chi)\)</span>,
we raise an error by default.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>entropies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">Entanglement entropies for half-cuts.
<cite>entropies[j]</cite> contains the entropy for a cut at bond <code class="docutils literal notranslate"><span class="pre">bonds[j]</span></code>
(i.e. left to site <code class="docutils literal notranslate"><span class="pre">bonds[j]</span></code>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.entanglement_spectrum">
<code class="descname">entanglement_spectrum</code><span class="sig-paren">(</span><em>by_charge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.entanglement_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>return entanglement energy spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>by_charge</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter we should sort the spectrum on each bond by the possible charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ent_spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">For each (non-trivial) bond the entanglement spectrum.
If <cite>by_charge</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, return (for each bond) a sorted 1D ndarray
with the convention <span class="math notranslate nohighlight">\(S_i^2 = e^{-\xi_i}\)</span>, where <span class="math notranslate nohighlight">\(S_i\)</span> labels a Schmidt
value and <span class="math notranslate nohighlight">\(\xi_i\)</span> labels the entanglement ‘energy’ in the returned spectrum.
If <cite>by_charge</cite> is True, return a a list of tuples <code class="docutils literal notranslate"><span class="pre">(charge,</span> <span class="pre">sub_spectrum)</span></code>
for each possible charge on that bond.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.expectation_value">
<code class="descname">expectation_value</code><span class="sig-paren">(</span><em>ops</em>, <em>sites=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.expectation_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;</span></code> of (n-site) operator(s).</p>
<p>Given the MPS in canonical form, it calculates n-site expectation values.
For example the contraction for a two-site (<cite>n</cite> = 2) operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span> <span class="n">op</span>  <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">The operators, for wich the expectation value should be taken,
All operators should all have the same number of legs (namely <cite>2 n</cite>).
If less than <cite>self.L</cite> operators are given, we repeat them periodically.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of int</span></dt>
<dd><p class="first last">List of site indices. Expectation values are evaluated there.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the entire chain is taken (clipping for finite b.c.)</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | (list of str, list of str)</span></dt>
<dd><p class="first last">Two lists of each <cite>n</cite> leg labels giving the physical legs of the operator used for
contraction. The first <cite>n</cite> legs are contracted with conjugated <cite>B</cite>,
the second <cite>n</cite> legs with the non-conjugated <cite>B</cite>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">(['p'],</span> <span class="pre">['p*'])</span></code> for single site operators (<cite>n</cite> = 1), or
<code class="docutils literal notranslate"><span class="pre">(['p0',</span> <span class="pre">'p1',</span> <span class="pre">...</span> <span class="pre">'p{n-1}'],</span> <span class="pre">['p0*',</span> <span class="pre">'p1*',</span> <span class="pre">....</span> <span class="pre">'p{n-1}*'])</span></code> for <cite>n</cite> &gt; 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_vals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">Expectation values, <code class="docutils literal notranslate"><span class="pre">exp_vals[i]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops[i]|psi&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">ops[i]</span></code> acts on
site(s) <code class="docutils literal notranslate"><span class="pre">j,</span> <span class="pre">j+1,</span> <span class="pre">...,</span> <span class="pre">j+{n-1}</span></code> with <code class="docutils literal notranslate"><span class="pre">j=sites[i]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>One site examples (n=1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="go">[Sz0, Sz1, ..., Sz{L-1}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Sx&#39;</span><span class="p">])</span>
<span class="go">[Sz0, Sx1, Sz2, Sx3, ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[Sz0, Sz3, Sz4]</span>
</pre></div>
</div>
<p>Two site example (n=2), assuming homogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                     psi.sites[1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx</span><span class="p">)</span>
<span class="go">[Sz0Sx1, Sz1Sx2, Sz2Sx3, ... ]   # with len L-1 for finite bc, or L for infinite</span>
</pre></div>
</div>
<p>Example measuring &lt;psi|SzSx|psi2&gt; on each second site, for inhomogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                           psi.sites[i+1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="go">                 for i in range(0, psi.L-1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx_list</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[Sz0Sx1, Sz2Sx3, Sz4Sx5, ...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.expectation_value_multi_sites">
<code class="descname">expectation_value_multi_sites</code><span class="sig-paren">(</span><em>operators</em>, <em>i0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.expectation_value_multi_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p>
<p>Calculates the expectation value of a tensor product of single-site operators
acting on different sites next to each other.
In other words, evaluate the expectation value of a term
<code class="docutils literal notranslate"><span class="pre">op0_i0</span> <span class="pre">op1_{i0+1}</span> <span class="pre">op2_{i0+2}</span> <span class="pre">...</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>operators</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt>
<dd><p class="first last">List of one-site operators. This method calculates the
expectation value of the n-sites operator given by their tensor
product.</p>
</dd>
<dt><strong>i0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The left most index on which an operator acts, i.e.,
<code class="docutils literal notranslate"><span class="pre">operators[i]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">i0</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">The expectation value of the tensorproduct of the given onsite operators,
<code class="docutils literal notranslate"><span class="pre">&lt;psi|operators[0]_{i0}</span> <span class="pre">operators[1]_{i0+1}</span> <span class="pre">...</span> <span class="pre">|psi&gt;/&lt;psi|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> is the represented MPS.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.expectation_value_term">
<code class="descname">expectation_value_term</code><span class="sig-paren">(</span><em>term</em>, <em>autoJW=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.expectation_value_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p>
<p>Calculates the expectation value of a tensor product of single-site operators
acting on different sites <cite>i0</cite>, <cite>i1</cite>, … (not necessarily next to each other).
In other words, evaluate the expectation value of a term <code class="docutils literal notranslate"><span class="pre">op0_i0</span> <span class="pre">op1_i1</span> <span class="pre">op2_i2</span> <span class="pre">...</span></code>.</p>
<p>For example the contraction of three one-site operators on sites <cite>i0</cite>,
<cite>i1=i0+1</cite>, <cite>i2=i0+3</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>    <span class="n">op1</span>     <span class="n">op2</span>       <span class="o">|</span>       <span class="n">op3</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>term</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (str, int)</span></dt>
<dd><p class="first last">List of tuples <code class="docutils literal notranslate"><span class="pre">op,</span> <span class="pre">i</span></code> where <cite>i</cite> is the MPS index of the site the operator
named <cite>op</cite> acts on.
The order inside <cite>term</cite> determines the order in which they act
(in the mathematical convention: the last operator in <cite>term</cite> is right-most,
so it acts first on a Ket).</p>
</dd>
<dt><strong>autoJW</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True (default), automatically insert Jordan Wigner strings for Fermions as needed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>exp_val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">The expectation value of the tensorproduct of the given onsite operators,
<code class="docutils literal notranslate"><span class="pre">&lt;psi|op_i0</span> <span class="pre">op_i1</span> <span class="pre">...</span> <span class="pre">op_iN</span> <span class="pre">|psi&gt;/&lt;psi|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> is the represented MPS.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">([(</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">([(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_multi_sites</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">],</span> <span class="n">i0</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.expectation_value_terms_sum">
<code class="descname">expectation_value_terms_sum</code><span class="sig-paren">(</span><em>term_list</em>, <em>prefactors</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.expectation_value_terms_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate expectation values for a bunch of terms and sum them up.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>term_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of terms</span></dt>
<dd><p class="first last">Each <cite>term</cite> should have the form <code class="docutils literal notranslate"><span class="pre">[(Op1,</span> <span class="pre">site1),</span> <span class="pre">(Op2,</span> <span class="pre">site2),</span> <span class="pre">...]</span></code>.</p>
</dd>
<dt><strong>prefactors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (complex) floats</span></dt>
<dd><p class="first last">Prefactors for the <code class="docutils literal notranslate"><span class="pre">term_sum</span></code> to be evaluated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>terms_sum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (complex) float</span></dt>
<dd><p class="first last">Equivalent to the expression
<code class="docutils literal notranslate"><span class="pre">sum([self.expectation_value_term(t)*f</span> <span class="pre">for</span> <span class="pre">t,</span> <span class="pre">f</span> <span class="pre">in</span> <span class="pre">zip(terms_list,</span> <span class="pre">prefactors)])</span></code>.</p>
</dd>
<dt><strong>cache :</strong></dt>
<dd><p class="first last">Intermediate results. Currently the values for each of the term, but this might be
changed soon.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.expectation_value_term" title="tenpy.networks.purification_mps.PurificationMPS.expectation_value_term"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expectation_value_term()</span></code></a></dt>
<dd>evaluates a single <cite>term</cite>.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"></code></dt>
<dd>This is a naive implementation. For efficiency a caching is necessary: We need to evaluate the expectation values of terms starting with the same operator(s) from the left at the same time to avoid doing the same work many times.</dd>
</dl>
</div>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.purification_mps.PurificationMPS.finite">
<code class="descname">finite</code><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Distinguish MPS (<code class="docutils literal notranslate"><span class="pre">True;</span> <span class="pre">bc='finite',</span> <span class="pre">'segment'</span></code> ) vs. iMPS (<code class="docutils literal notranslate"><span class="pre">False;</span> <span class="pre">bc='infinite'</span></code>)</p>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.purification_mps.PurificationMPS.from_Bflat">
<em class="property">classmethod </em><code class="descname">from_Bflat</code><span class="sig-paren">(</span><em>sites</em>, <em>Bflat</em>, <em>SVs=None</em>, <em>bc='finite'</em>, <em>dtype=None</em>, <em>permute=True</em>, <em>form='B'</em>, <em>legL=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.from_Bflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix product state from a set of numpy arrays <cite>Bflat</cite> and singular vals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>Bflat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of numpy ndarrays</span></dt>
<dd><p class="first last">The matrix defining the MPS on each site, with legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'vL',</span> <span class="pre">'vR'</span></code>
(physical, virtual left/right).</p>
</dd>
<dt><strong>SVs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of 1D array | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">The singular values on <em>each</em> bond. Should always have length <cite>L+1</cite>.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), set all singular values to the same value.
Entries out of <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.nontrivial_bonds" title="tenpy.networks.purification_mps.PurificationMPS.nontrivial_bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a> are ignored.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt>
<dd><p class="first last">MPS boundary conditions. See docstring of <code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code>.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type or string</span></dt>
<dd><p class="first last">The data type of the array entries. Defaults to the common dtype of <cite>Bflat</cite>.</p>
</dd>
<dt><strong>permute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">The <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> might permute the local basis states if charge
conservation gets enabled.
If <cite>permute</cite> is True (default), we permute the given <cite>Bflat</cite> locally according to
each site’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">perm</span></code>.
The <cite>p_state</cite> argument should then always be given as if <cite>conserve=None</cite> in the Site.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">Defines the canonical form of <cite>Bflat</cite>. See module doc-string.
A single choice holds for all of the entries.</p>
</dd>
<dt><strong>leg_L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">LegCharge | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt>
<dd><p class="first last">Leg charges at bond 0, which are purely conventional.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use trivial charges.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">An MPS with the matrices <cite>Bflat</cite> converted to npc arrays.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.purification_mps.PurificationMPS.from_full">
<em class="property">classmethod </em><code class="descname">from_full</code><span class="sig-paren">(</span><em>sites</em>, <em>psi</em>, <em>form='B'</em>, <em>cutoff=1e-16</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.from_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an MPS from a single tensor <cite>psi</cite> with one leg per physical site.</p>
<p>Performs a sequence of SVDs of psi to split off the <cite>B</cite> matrices and obtain the singular
values, the result will be in canonical form.
Obviously, this is only well-defined for <cite>finite</cite> boundary conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>psi</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The full wave function to be represented as an MPS.
Should have labels <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1',</span> <span class="pre">...,</span>&#160; <span class="pre">'p{L-1}'</span></code>.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span></code></span></dt>
<dd><p class="first last">The canonical form of the resulting MPS, see module doc-string.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Cutoff of singular values used in the SVDs.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether the resulting MPS should have ‘norm’ 1.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>psi_mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">MPS representation of <cite>psi</cite>, in canonical form and possibly normalized.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.purification_mps.PurificationMPS.from_product_state">
<em class="property">classmethod </em><code class="descname">from_product_state</code><span class="sig-paren">(</span><em>sites</em>, <em>p_state</em>, <em>bc='finite'</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>permute=True</em>, <em>form='B'</em>, <em>chargeL=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.from_product_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix product state from a given product state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>p_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of {int | str | 1D array}</span></dt>
<dd><p class="first last">Defines the product state to be represented.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is str, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> is in state
<code class="docutils literal notranslate"><span class="pre">self.sites[i].state_labels(p_state[i])</span></code>.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is int, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> is in state <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code>.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is an array, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> wavefunction is <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code>.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt>
<dd><p class="first last">MPS boundary conditions. See docstring of <code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code>.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type or string</span></dt>
<dd><p class="first last">The data type of the array entries.</p>
</dd>
<dt><strong>permute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">The <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> might permute the local basis states if charge
conservation gets enabled.
If <cite>permute</cite> is True (default), we permute the given <cite>p_state</cite> locally according to
each site’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">perm</span></code>.
The <cite>p_state</cite> argument should then always be given as if <cite>conserve=None</cite> in the Site.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt>
<dd><p class="first last">Defines the canonical form. See module doc-string.
A single choice holds for all of the entries.</p>
</dd>
<dt><strong>chargeL</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last">Leg charge at bond 0, which are purely conventional.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>product_mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">An MPS representing the specified product state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>To get a Neel state:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">SpinChain</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_state</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># repeats entries L/2 times</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">MPS</span><span class="o">.</span><span class="n">from_product_state</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">(),</span> <span class="n">p_state</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span><span class="p">)</span>
</pre></div>
</div>
<p>For Spin S=1/2, you could get a state with all sites pointing in negative x-direction with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">neg_x_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">neg_x_state</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">neg_x_state</span><span class="p">)]</span><span class="o">*</span><span class="n">L</span>  <span class="c1"># other parameters as above</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.purification_mps.PurificationMPS.from_singlets">
<em class="property">classmethod </em><code class="descname">from_singlets</code><span class="sig-paren">(</span><em>site</em>, <em>L</em>, <em>pairs</em>, <em>up='up'</em>, <em>down='down'</em>, <em>lonely=[]</em>, <em>lonely_state='up'</em>, <em>bc='finite'</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.from_singlets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an MPS of entangled singlets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>site</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The <cite>site</cite> defining the local Hilbert space, taken uniformly for all sites.</p>
</dd>
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of sites.</p>
</dd>
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (int, int)</span></dt>
<dd><p class="first last">Pairs of sites to be entangled; the returned MPS will have a singlet
for each pair in <cite>pairs</cite>.</p>
</dd>
<dt><strong>up, down</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">A singlet is defined as <code class="docutils literal notranslate"><span class="pre">(|up</span> <span class="pre">down&gt;</span> <span class="pre">-</span> <span class="pre">|down</span> <span class="pre">up&gt;)/2**0.5</span></code>,
<code class="docutils literal notranslate"><span class="pre">up</span></code> and <code class="docutils literal notranslate"><span class="pre">down</span></code> give state indices or labels defined on the corresponding site.</p>
</dd>
<dt><strong>lonely</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">Sites which are not included into a singlet pair.</p>
</dd>
<dt><strong>lonely_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">The state for the lonely sites.</p>
</dd>
<dt><strong>bc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt>
<dd><p class="first last">MPS boundary conditions. See docstring of <code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>singlet_mps</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">An MPS representing singlets on the specified pairs of sites.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.gauge_total_charge">
<code class="descname">gauge_total_charge</code><span class="sig-paren">(</span><em>qtotal=None</em>, <em>vL_leg=None</em>, <em>vR_leg=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.gauge_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Gauge the legcharges of the virtual bonds such that the MPS has a total <cite>qtotal</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) charges</span></dt>
<dd><p class="first last">If a single set of charges is given, it is the desired total charge of the MPS
(which <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.get_total_charge" title="tenpy.networks.purification_mps.PurificationMPS.get_total_charge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_total_charge()</span></code></a> will return afterwards).
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), use 0 charges, unless vL_leg and vR_leg are specified, in which
case we adjust the total charge to match these legs.</p>
</dd>
<dt><strong>vL_leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | LegCharge</span></dt>
<dd><p class="first last">Desired new virtual leg on the very left. Needs to have the same block strucuture as
current leg, but can have shifted charge entries.</p>
</dd>
<dt><strong>vR_leg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | LegCharge</span></dt>
<dd><p class="first last">Desired new virtual leg on the very rigth. Needs to have the same block strucuture as
current leg, but can have shifted charge entries.
Should be <cite>vL_leg.conj()</cite> for infinite MPS, if <cite>qtotal</cite> is not given.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><em>i</em>, <em>form='B'</em>, <em>copy=False</em>, <em>cutoff=1e-16</em>, <em>label_p=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (view of) <cite>B</cite> at site <cite>i</cite> in canonical form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index choosing the site.</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt>
<dd><p class="first last">The (canonical) form of the returned B.
For <code class="docutils literal notranslate"><span class="pre">None</span></code>, return the matrix in whatever form it is.
If any of the tuple entry is None, also don’t scale on the corresponding axis.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to return a copy even if <cite>form</cite> matches the current form.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">During DMRG with a mixer, <cite>S</cite> may be a matrix for which we need the inverse.
This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
singular values.</p>
</dd>
<dt><strong>label_p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">Ignored by default (<code class="docutils literal notranslate"><span class="pre">None</span></code>).
Otherwise replace the physical label <code class="docutils literal notranslate"><span class="pre">'p'</span></code> with <code class="docutils literal notranslate"><span class="pre">'p'+label_p'</span></code>.
(For derived classes with more than one “physical” leg, replace all the physical leg
labels accordingly.)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The MPS ‘matrix’ <cite>B</cite> at site <cite>i</cite> with leg labels <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'p',</span> <span class="pre">'vR'</span></code>.
May be a view of the matrix (if <code class="docutils literal notranslate"><span class="pre">copy=False</span></code>),
or a copy (if the form changed or <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if self is not in canoncial form and <cite>form</cite> is not None.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_SL">
<code class="descname">get_SL</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_SL" title="Permalink to this definition">¶</a></dt>
<dd><p>Return singular values on the left of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_SR">
<code class="descname">get_SR</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_SR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return singular values on the right of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_grouped_mps">
<code class="descname">get_grouped_mps</code><span class="sig-paren">(</span><em>blocklen</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_grouped_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>contract blocklen subsequent tensors into a single one and return result as a new MPS.</p>
<p>blocklen = number of subsequent sites to be combined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>new MPS object with bunched sites.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_op">
<code class="descname">get_op</code><span class="sig-paren">(</span><em>op_list</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of operators, select the one corresponding to site <cite>i</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>op_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) {str | npc.array}</span></dt>
<dd><p class="first last">List of operators from which we choose. We assume that <code class="docutils literal notranslate"><span class="pre">op_list[j]</span></code> acts on site
<code class="docutils literal notranslate"><span class="pre">j</span></code>. If the length is shorter than <cite>L</cite>, we repeat it periodically.
Strings are translated using <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site.get_op" title="tenpy.networks.site.Site.get_op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_op()</span></code></a> of site <cite>i</cite>.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index of the site on which the operator acts.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">npc.array</span></dt>
<dd><p class="first last">One of the entries in <cite>op_list</cite>, not copied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_rho_segment">
<code class="descname">get_rho_segment</code><span class="sig-paren">(</span><em>segment</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_rho_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reduced density matrix for a segment.</p>
<p>Note that the dimension of rho_A scales exponentially in the length of the segment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>segment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Sites for which the reduced density matrix is to be calculated.
Assumed to be sorted.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Reduced density matrix of the segment sites.
Labels <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1',</span> <span class="pre">...,</span> <span class="pre">'pk',</span> <span class="pre">'p0*',</span> <span class="pre">'p1*',</span> <span class="pre">...,</span> <span class="pre">'pk*'</span></code> with <code class="docutils literal notranslate"><span class="pre">k=len(segment)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_theta">
<code class="descname">get_theta</code><span class="sig-paren">(</span><em>i</em>, <em>n=2</em>, <em>cutoff=1e-16</em>, <em>formL=1.0</em>, <em>formR=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>n</cite>-site wavefunction on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Site index.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites. The result lives on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p>
</dd>
<dt><strong>cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">During DMRG with a mixer, <cite>S</cite> may be a matrix for which we need the inverse.
This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
singular values.</p>
</dd>
<dt><strong>formL</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Exponent for the singular values to the left.</p>
</dd>
<dt><strong>formR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Exponent for the singular values to the right.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The n-site wave function with leg labels <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">p0,</span> <span class="pre">p1,</span> <span class="pre">....</span> <span class="pre">p{n-1},</span> <span class="pre">vR</span></code>.
In Vidal’s notation (with s=lambda, G=Gamma):
<code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">=</span> <span class="pre">s**form_L</span> <span class="pre">G_i</span> <span class="pre">s</span> <span class="pre">G_{i+1}</span> <span class="pre">s</span> <span class="pre">...</span> <span class="pre">G_{i+n-1}</span> <span class="pre">s**form_R</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.get_total_charge">
<code class="descname">get_total_charge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.get_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and return the <cite>qtotal</cite> of the whole MPS (when contracted).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qtotal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">charges</span></dt>
<dd><p class="first last">The sum of the <cite>qtotal</cite> of the individual <cite>B</cite> tensors.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> inplace to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.group_split" title="tenpy.networks.purification_mps.PurificationMPS.group_split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group_split()</span></code></a></dt>
<dd>Reverts the grouping.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.group_split">
<code class="descname">group_split</code><span class="sig-paren">(</span><em>trunc_par={}</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.group_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> inplace to split previously grouped sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error introduced by the truncation for the splitting.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.group_sites" title="tenpy.networks.purification_mps.PurificationMPS.group_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group_sites()</span></code></a></dt>
<dd>Should have been used before to combine sites.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.init_LP">
<code class="descname">init_LP</code><span class="sig-paren">(</span><em>i</em>, <em>bra=None</em>, <em>mpo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.init_LP" title="Permalink to this definition">¶</a></dt>
<dd><p>Build initial left part <code class="docutils literal notranslate"><span class="pre">LP</span></code> for an MPS/MPOEnvironment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Build <code class="docutils literal notranslate"><span class="pre">LP</span></code> left of site <cite>i</cite>.</p>
</dd>
<dt><strong>bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">Check leg compatiblity with a <cite>bra</cite>. Note that the returned <cite>init_LP</cite> will
only be the contraction for the <code class="docutils literal notranslate"><span class="pre">LP</span></code> of  <code class="docutils literal notranslate"><span class="pre">&lt;bra|self&gt;</span></code> on the left most site <cite>i</cite> = 0
of a finite MPS.</p>
</dd>
<dt><strong>mpo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | <a class="reference internal" href="tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">If given, add a leg for the MPO. Requires the <cite>MPO.IdL</cite> on site <cite>i</cite> to be set.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>init_LP</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Identity contractible with the <cite>vL</cite> leg of <code class="docutils literal notranslate"><span class="pre">self.get_B(i)</span></code>, labels <code class="docutils literal notranslate"><span class="pre">'vR*',</span> <span class="pre">'vR'</span></code>.
If <cite>mpo</cite> is given, multiplied with a unit vector nonzero in <code class="docutils literal notranslate"><span class="pre">mpo.IdL[i]</span></code>,
with labels <code class="docutils literal notranslate"><span class="pre">'vR*',</span> <span class="pre">'wR',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.init_RP">
<code class="descname">init_RP</code><span class="sig-paren">(</span><em>i</em>, <em>bra=None</em>, <em>mpo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.init_RP" title="Permalink to this definition">¶</a></dt>
<dd><p>Build initial right part <code class="docutils literal notranslate"><span class="pre">RP</span></code> for an MPS/MPOEnvironment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Build <code class="docutils literal notranslate"><span class="pre">RP</span></code> rigth of site <cite>i</cite>.</p>
</dd>
<dt><strong>bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">Check leg compatiblity with a <cite>bra</cite>. Note that the returned <cite>init_RP</cite> will
only be the contraction for the <code class="docutils literal notranslate"><span class="pre">RP</span></code> of  <code class="docutils literal notranslate"><span class="pre">&lt;bra|self&gt;</span></code> on the right most site
<cite>i</cite> = L - 1 of a finite MPS.</p>
</dd>
<dt><strong>mpo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | <a class="reference internal" href="tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">If given, add a leg for the MPO. Requires the <cite>MPO.IdR</cite> on site <cite>i</cite> to be set.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>init_RP</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Identity contractible with the <cite>vR</cite> leg of <code class="docutils literal notranslate"><span class="pre">self.get_B(i)</span></code>, labels <code class="docutils literal notranslate"><span class="pre">'vL*',</span> <span class="pre">'vL'</span></code>.
If <cite>mpo</cite> is given, multiplied with a unit vector nonzero in <code class="docutils literal notranslate"><span class="pre">mpo.IdR[i]</span></code>,
with labels <code class="docutils literal notranslate"><span class="pre">'vL*',</span> <span class="pre">'wL',</span> <span class="pre">'vL'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.purification_mps.PurificationMPS.nontrivial_bonds">
<code class="descname">nontrivial_bonds</code><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.nontrivial_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice of the non-trivial bond indices, depending on <code class="docutils literal notranslate"><span class="pre">self.bc</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.norm_test">
<code class="descname">norm_test</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.norm_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that self is in canonical form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>norm_error: array, shape (L, 2)</strong></dt>
<dd><p class="first">For each site the norm error to the left and right.
The error <code class="docutils literal notranslate"><span class="pre">norm_error[i,</span> <span class="pre">0]</span></code> is defined as the norm-difference between
the following networks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">--</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---.</span>       <span class="o">--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>    <span class="n">vs</span>         <span class="o">|</span>
<span class="o">|</span>   <span class="o">--</span><span class="n">theta</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>       <span class="o">--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">norm_errror[i,</span> <span class="pre">1]</span></code> is the norm-difference of:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">.--</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span>         <span class="o">.--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span>
<span class="o">|</span>   <span class="o">|</span>    <span class="o">|</span>          <span class="n">vs</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="o">.--</span><span class="n">theta</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span>         <span class="o">.--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span>
</pre></div>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.overlap">
<code class="descname">overlap</code><span class="sig-paren">(</span><em>other</em>, <em>charge_sector=0</em>, <em>ignore_form=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute overlap <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></span></dt>
<dd><p class="first last">An MPS with the same physical sites.</p>
</dd>
<dt><strong>charge_sector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | charges | <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt>
<dd><p class="first last">Selects the charge sector in which the dominant eigenvector of the TransferMatrix is.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for <em>all</em> sectors, <code class="docutils literal notranslate"><span class="pre">0</span></code> stands for the zero-charge sector.
Defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>, i.e., <em>assumes</em> the dominant eigenvector is in charge sector 0.</p>
</dd>
<dt><strong>ignore_form</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), take into account the canonical form <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> at each site.
If <code class="docutils literal notranslate"><span class="pre">True</span></code>, we ignore the canonical form (i.e., whether the MPS is in left, right,
mixed or no canonical form) and just contract all the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_B</span></code> as they are.
(This can give different results!)</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Further keyword arguments given to <code class="xref py py-meth docutils literal notranslate"><span class="pre">TransferMatrix.eigenvectors()</span></code>;
only used for infinite boundary conditions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dtype.type</span></dt>
<dd><p class="first last">The contraction <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span> <span class="pre">*</span> <span class="pre">self.norm</span> <span class="pre">*</span> <span class="pre">other.norm</span></code>
(i.e., taking into account the <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code> of both MPS).
For an infinite MPS, <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code> is the overlap per unit cell, i.e.,
the largest eigenvalue of the TransferMatrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.permute_sites">
<code class="descname">permute_sites</code><span class="sig-paren">(</span><em>perm</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.permute_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the permutation perm to the state (inplace).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray[ndim=1, int]</span></dt>
<dd><p class="first last">The applied permutation, such that <code class="docutils literal notranslate"><span class="pre">psi.permute_sites(perm)[i]</span> <span class="pre">=</span> <span class="pre">psi[perm[i]]</span></code>
(where <code class="docutils literal notranslate"><span class="pre">[i]</span></code> indicates the <cite>i</cite>-th site).</p>
</dd>
<dt><strong>swap_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The operator used to swap the phyiscal legs of a two-site wave function <cite>theta</cite>,
see <a class="reference internal" href="tenpy.networks.purification_mps.PurificationMPS.html#tenpy.networks.purification_mps.PurificationMPS.swap_sites" title="tenpy.networks.purification_mps.PurificationMPS.swap_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swap_sites()</span></code></a>.</p>
</dd>
<dt><strong>trunc_par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Level of verbosity, print status messages if verbose &gt; 0.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trunc_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt>
<dd><p class="first last">The error of the represented state introduced by the truncation after the swaps.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.probability_per_charge">
<code class="descname">probability_per_charge</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.probability_per_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return probabilites of charge value on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
This function returns the possible values of <cite>N_b</cite> as rows of <cite>charge_values</cite>,
and for each row the probabilty that this combination occurs in the given state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The bond to be considered. The returned charges are summed on the left of this bond.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>charge_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Columns correspond to the different charges in <cite>self.chinfo</cite>.
Rows are the different charge fluctuations at this bond</p>
</dd>
<dt><strong>probabilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd><p class="first last">For each row of <cite>charge_values</cite> the probablity for these values of charge fluctuations.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.set_B">
<code class="descname">set_B</code><span class="sig-paren">(</span><em>i</em>, <em>B</em>, <em>form='B'</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.set_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <cite>B</cite> at site <cite>i</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Index choosing the site.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The ‘matrix’ at site <cite>i</cite>. No copy is made!
Should have leg labels <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'p',</span> <span class="pre">'vR'</span></code> (not necessarily in that order).</p>
</dd>
<dt><strong>form</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt>
<dd><p class="first last">The (canonical) form of the <cite>B</cite> to set.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for non-canonical form.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.set_SL">
<code class="descname">set_SL</code><span class="sig-paren">(</span><em>i</em>, <em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.set_SL" title="Permalink to this definition">¶</a></dt>
<dd><p>Set singular values on the left of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.purification_mps.PurificationMPS.set_SR">
<code class="descname">set_SR</code><span class="sig-paren">(</span><em>i</em>, <em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.networks.purification_mps.PurificationMPS.set_SR" title="Permalink to this definition">¶</a></dt>
<dd><p>Set singular values on the right of site <cite>i</cite></p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.networks.mpo.grid_insert_ops.html"
                        title="previous chapter">grid_insert_ops</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.networks.purification_mps.PurificationMPS.html"
                        title="next chapter">PurificationMPS</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference.html">Tenpy Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tenpy.algorithms.html">algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.linalg.html">linalg</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.models.html">models</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.networks.html">networks</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.site.html">site</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.mps.html">mps</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.mpo.html">mpo</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">purification_mps</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.tools.html">tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.version.html">version</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.purification_mps.PurificationMPS.html" title="PurificationMPS"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mpo.grid_insert_ops.html" title="grid_insert_ops"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.networks.html" >networks</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 29, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>