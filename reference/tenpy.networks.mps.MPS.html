
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>MPS &#8212; TeNPy 0.4.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="MPSEnvironment" href="tenpy.networks.mps.MPSEnvironment.html" />
    <link rel="prev" title="mps" href="tenpy.networks.mps.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mps.MPSEnvironment.html" title="MPSEnvironment"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mps.html" title="mps"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.networks.html" >networks</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="tenpy.networks.mps.html" accesskey="U">mps</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="mps">
<h1>MPS<a class="headerlink" href="#mps" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>full name: tenpy.networks.mps.MPS</p></li>
<li><p>parent module: <a class="reference internal" href="tenpy.networks.mps.html#module-tenpy.networks.mps" title="tenpy.networks.mps"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.networks.mps</span></code></a></p></li>
<li><p>type: class</p></li>
</ul>
<dl class="class">
<dt id="tenpy.networks.mps.MPS">
<em class="property">class </em><code class="descclassname">tenpy.networks.mps.</code><code class="descname">MPS</code><span class="sig-paren">(</span><em>sites</em>, <em>Bs</em>, <em>SVs</em>, <em>bc='finite'</em>, <em>form='B'</em>, <em>norm=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A Matrix Product State, finite (MPS) or infinite (iMPS).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>sites</strong><span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt><dd><p>Defines the local Hilbert space for each site.</p>
</dd>
<dt><strong>Bs</strong><span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The ‘matrices’ of the MPS. Labels are <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p</span></code> (in any order).</p>
</dd>
<dt><strong>SVs</strong><span class="classifier">list of 1D array</span></dt><dd><p>The singular values on <em>each</em> bond. Should always have length <cite>L+1</cite>.
Entries out of <a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a> are ignored.</p>
</dd>
<dt><strong>bc</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">'finite'</span> <span class="pre">|</span> <span class="pre">'segment'</span> <span class="pre">|</span> <span class="pre">'infinite'</span></code></span></dt><dd><p>Boundary conditions as described in the tabel of the module doc-string.</p>
</dd>
<dt><strong>form</strong><span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt><dd><p>The form of the stored ‘matrices’, see table in module doc-string.
A single choice holds for all of the entries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.L" title="tenpy.networks.mps.MPS.L"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L</span></code></a></dt><dd><p>Number of physical sites.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.chi" title="tenpy.networks.mps.MPS.chi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi</span></code></a></dt><dd><p>Dimensions of the (nontrivial) virtual bonds.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.finite" title="tenpy.networks.mps.MPS.finite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finite</span></code></a></dt><dd><p>Distinguish MPS (<code class="docutils literal notranslate"><span class="pre">True;</span> <span class="pre">bc='finite',</span> <span class="pre">'segment'</span></code> ) vs.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a></dt><dd><p>Slice of the non-trivial bond indices, depending on <code class="docutils literal notranslate"><span class="pre">self.bc</span></code>.</p>
</dd>
<dt><strong>sites</strong><span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt><dd><p>Defines the local Hilbert space for each site.</p>
</dd>
<dt><strong>bc</strong><span class="classifier">{‘finite’, ‘segment’, ‘infinite’}</span></dt><dd><p>Boundary conditions as described in above table.</p>
</dd>
<dt><strong>form</strong><span class="classifier">list of {<code class="docutils literal notranslate"><span class="pre">None</span></code> | tuple(float, float)}</span></dt><dd><p>Describes the canonical form on each site.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means non-canonical form.
For <code class="docutils literal notranslate"><span class="pre">form</span> <span class="pre">=</span> <span class="pre">(nuL,</span> <span class="pre">nuR)</span></code>, the stored <code class="docutils literal notranslate"><span class="pre">_B[i]</span></code> are
<code class="docutils literal notranslate"><span class="pre">s**form[0]</span> <span class="pre">--</span> <span class="pre">Gamma</span> <span class="pre">--</span> <span class="pre">s**form[1]</span></code> (in Vidal’s notation).</p>
</dd>
<dt><strong>chinfo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></span></dt><dd><p>The nature of the charge.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type</span></dt><dd><p>The data type of the <code class="docutils literal notranslate"><span class="pre">_B</span></code>.</p>
</dd>
<dt><strong>norm</strong><span class="classifier">float</span></dt><dd><p>The norm of the state, i.e. <code class="docutils literal notranslate"><span class="pre">sqrt(&lt;psi|psi&gt;)</span></code>.
Ignored for (normalized) <a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value" title="tenpy.networks.mps.MPS.expectation_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expectation_value()</span></code></a>, but important for <a class="reference internal" href="#tenpy.networks.mps.MPS.overlap" title="tenpy.networks.mps.MPS.overlap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">overlap()</span></code></a>.</p>
</dd>
<dt><strong>grouped</strong><span class="classifier">int</span></dt><dd><p>Number of sites grouped together, see <a class="reference internal" href="#tenpy.networks.mps.MPS.group_sites" title="tenpy.networks.mps.MPS.group_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group_sites()</span></code></a>.</p>
</dd>
<dt><strong>_B</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">npc.Array</span></code></span></dt><dd><p>The ‘matrices’ of the MPS. Labels are <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">vR,</span> <span class="pre">p</span></code> (in any order).
We recommend using <a class="reference internal" href="#tenpy.networks.mps.MPS.get_B" title="tenpy.networks.mps.MPS.get_B"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_B()</span></code></a> and <a class="reference internal" href="#tenpy.networks.mps.MPS.set_B" title="tenpy.networks.mps.MPS.set_B"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_B()</span></code></a>, which will take care of the different
canonical forms.</p>
</dd>
<dt><strong>_S</strong><span class="classifier">list of (<code class="docutils literal notranslate"><span class="pre">None</span></code> | 1D array)</span></dt><dd><p>The singular values on each virtual bond, length <code class="docutils literal notranslate"><span class="pre">L+1</span></code>.
May be <code class="docutils literal notranslate"><span class="pre">None</span></code> if the MPS is not in canonical form.
Otherwise, <code class="docutils literal notranslate"><span class="pre">_S[i]</span></code> is to the left of <code class="docutils literal notranslate"><span class="pre">_B[i]</span></code>.
We recommend using <a class="reference internal" href="#tenpy.networks.mps.MPS.get_SL" title="tenpy.networks.mps.MPS.get_SL"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_SL()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.get_SR" title="tenpy.networks.mps.MPS.get_SR"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_SR()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.set_SL" title="tenpy.networks.mps.MPS.set_SL"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_SL()</span></code></a>, <a class="reference internal" href="#tenpy.networks.mps.MPS.set_SR" title="tenpy.networks.mps.MPS.set_SR"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_SR()</span></code></a>, which
takes proper care of the boundary conditions.</p>
</dd>
<dt><strong>_valid_forms</strong><span class="classifier">dict</span></dt><dd><p>Mapping for canonical forms to a tuple <code class="docutils literal notranslate"><span class="pre">(nuL,</span> <span class="pre">nuR)</span></code> indicating that
<code class="docutils literal notranslate"><span class="pre">self._Bs[i]</span> <span class="pre">=</span> <span class="pre">s[i]**nuL</span> <span class="pre">--</span> <span class="pre">Gamma[i]</span> <span class="pre">--</span> <span class="pre">s[i]**nuR</span></code> is saved.</p>
</dd>
<dt><strong>_valid_bc</strong><span class="classifier">tuple of str</span></dt><dd><p>Valid boundary conditions.</p>
</dd>
<dt><strong>_transfermatrix_keep</strong><span class="classifier">int</span></dt><dd><p>How many states to keep at least when diagonalizing a <a class="reference internal" href="tenpy.networks.mps.TransferMatrix.html#tenpy.networks.mps.TransferMatrix" title="tenpy.networks.mps.TransferMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferMatrix</span></code></a>.
Important if the state develops a near-degeneracy.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.add" title="tenpy.networks.mps.MPS.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(other, alpha, beta[, cutoff])</p></td>
<td><p>Return an MPS which represents <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.apply_local_op" title="tenpy.networks.mps.MPS.apply_local_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_local_op</span></code></a>(i, op[, unitary, …])</p></td>
<td><p>Apply a local (one or multi-site) operator to <cite>self</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.average_charge" title="tenpy.networks.mps.MPS.average_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_charge</span></code></a>([bond])</p></td>
<td><p>Return the average charge for the block on the left of a given bond.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form</span></code></a>([renormalize])</p></td>
<td><p>Bring self into canonical ‘B’ form, (re-)calculate singular values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_finite" title="tenpy.networks.mps.MPS.canonical_form_finite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form_finite</span></code></a>([renormalize, cutoff])</p></td>
<td><p>Bring a finite (or segment) MPS into canonical form (in place).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_infinite" title="tenpy.networks.mps.MPS.canonical_form_infinite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_form_infinite</span></code></a>([renormalize, tol_xi])</p></td>
<td><p>Bring an infinite MPS into canonical form (in place).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.charge_variance" title="tenpy.networks.mps.MPS.charge_variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">charge_variance</span></code></a>([bond])</p></td>
<td><p>Return the charge variance on the left of a given bond.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.compute_K" title="tenpy.networks.mps.MPS.compute_K"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_K</span></code></a>(perm[, swap_op, trunc_par, …])</p></td>
<td><p>Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.convert_form" title="tenpy.networks.mps.MPS.convert_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_form</span></code></a>([new_form])</p></td>
<td><p>Tranform self into different canonical form (by scaling the legs with singular values).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.copy" title="tenpy.networks.mps.MPS.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Returns a copy of <cite>self</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.correlation_function" title="tenpy.networks.mps.MPS.correlation_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_function</span></code></a>(ops1, ops2[, sites1, …])</p></td>
<td><p>Correlation function  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op1_i</span> <span class="pre">op2_j|psi&gt;/&lt;psi|psi&gt;</span></code> of single site operators.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.correlation_length" title="tenpy.networks.mps.MPS.correlation_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_length</span></code></a>([target, tol_ev0, …])</p></td>
<td><p>Calculate the correlation length by diagonalizing the transfer matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_entropy" title="tenpy.networks.mps.MPS.entanglement_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_entropy</span></code></a>([n, bonds, for_matrix_S])</p></td>
<td><p>Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_entropy_segment" title="tenpy.networks.mps.MPS.entanglement_entropy_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_entropy_segment</span></code></a>([segment, …])</p></td>
<td><p>Calculate entanglement entropy for general geometry of the bipartition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_spectrum" title="tenpy.networks.mps.MPS.entanglement_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">entanglement_spectrum</span></code></a>([by_charge])</p></td>
<td><p>return entanglement energy spectrum.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value" title="tenpy.networks.mps.MPS.expectation_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value</span></code></a>(ops[, sites, axes])</p></td>
<td><p>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;</span></code> of (n-site) operator(s).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_multi_sites" title="tenpy.networks.mps.MPS.expectation_value_multi_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_multi_sites</span></code></a>(operators, i0)</p></td>
<td><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_term" title="tenpy.networks.mps.MPS.expectation_value_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_term</span></code></a>(term[, autoJW])</p></td>
<td><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_terms_sum" title="tenpy.networks.mps.MPS.expectation_value_terms_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_terms_sum</span></code></a>(term_list[, …])</p></td>
<td><p>Calculate expectation values for a bunch of terms and sum them up.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.from_Bflat" title="tenpy.networks.mps.MPS.from_Bflat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_Bflat</span></code></a>(sites, Bflat[, SVs, bc, dtype, …])</p></td>
<td><p>Construct a matrix product state from a set of numpy arrays <cite>Bflat</cite> and singular vals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.from_full" title="tenpy.networks.mps.MPS.from_full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_full</span></code></a>(sites, psi[, form, cutoff, …])</p></td>
<td><p>Construct an MPS from a single tensor <cite>psi</cite> with one leg per physical site.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.from_product_state" title="tenpy.networks.mps.MPS.from_product_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_product_state</span></code></a>(sites, p_state[, bc, …])</p></td>
<td><p>Construct a matrix product state from a given product state.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.from_singlets" title="tenpy.networks.mps.MPS.from_singlets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_singlets</span></code></a>(site, L, pairs[, up, down, …])</p></td>
<td><p>Create an MPS of entangled singlets.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.gauge_total_charge" title="tenpy.networks.mps.MPS.gauge_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_total_charge</span></code></a>([qtotal, vL_leg, vR_leg])</p></td>
<td><p>Gauge the legcharges of the virtual bonds such that the MPS has a total <cite>qtotal</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_B" title="tenpy.networks.mps.MPS.get_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_B</span></code></a>(i[, form, copy, cutoff, label_p])</p></td>
<td><p>Return (view of) <cite>B</cite> at site <cite>i</cite> in canonical form.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_SL" title="tenpy.networks.mps.MPS.get_SL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_SL</span></code></a>(i)</p></td>
<td><p>Return singular values on the left of site <cite>i</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_SR" title="tenpy.networks.mps.MPS.get_SR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_SR</span></code></a>(i)</p></td>
<td><p>Return singular values on the right of site <cite>i</cite></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_grouped_mps" title="tenpy.networks.mps.MPS.get_grouped_mps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_grouped_mps</span></code></a>(blocklen)</p></td>
<td><p>contract blocklen subsequent tensors into a single one and return result as a new MPS.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_op" title="tenpy.networks.mps.MPS.get_op"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_op</span></code></a>(op_list, i)</p></td>
<td><p>Given a list of operators, select the one corresponding to site <cite>i</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_rho_segment" title="tenpy.networks.mps.MPS.get_rho_segment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_rho_segment</span></code></a>(segment)</p></td>
<td><p>Return reduced density matrix for a segment.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_theta" title="tenpy.networks.mps.MPS.get_theta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_theta</span></code></a>(i[, n, cutoff, formL, formR])</p></td>
<td><p>Calculates the <cite>n</cite>-site wavefunction on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.get_total_charge" title="tenpy.networks.mps.MPS.get_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_total_charge</span></code></a>()</p></td>
<td><p>Calculate and return the <cite>qtotal</cite> of the whole MPS (when contracted).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.group_sites" title="tenpy.networks.mps.MPS.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n, grouped_sites])</p></td>
<td><p>Modify <cite>self</cite> inplace to group sites.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.group_split" title="tenpy.networks.mps.MPS.group_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_split</span></code></a>([trunc_par])</p></td>
<td><p>Modify <cite>self</cite> inplace to split previously grouped sites.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.init_LP" title="tenpy.networks.mps.MPS.init_LP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_LP</span></code></a>(i[, bra, mpo])</p></td>
<td><p>Build initial left part <code class="docutils literal notranslate"><span class="pre">LP</span></code> for an MPS/MPOEnvironment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.init_RP" title="tenpy.networks.mps.MPS.init_RP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_RP</span></code></a>(i[, bra, mpo])</p></td>
<td><p>Build initial right part <code class="docutils literal notranslate"><span class="pre">RP</span></code> for an MPS/MPOEnvironment.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.mutinf_two_site" title="tenpy.networks.mps.MPS.mutinf_two_site"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mutinf_two_site</span></code></a>([max_range, n])</p></td>
<td><p>Calculate the two-site mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.norm_test" title="tenpy.networks.mps.MPS.norm_test"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_test</span></code></a>()</p></td>
<td><p>Check that self is in canonical form.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.overlap" title="tenpy.networks.mps.MPS.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code></a>(other[, charge_sector, ignore_form])</p></td>
<td><p>Compute overlap <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.permute_sites" title="tenpy.networks.mps.MPS.permute_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute_sites</span></code></a>(perm[, swap_op, trunc_par, …])</p></td>
<td><p>Applies the permutation perm to the state (inplace).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.probability_per_charge" title="tenpy.networks.mps.MPS.probability_per_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">probability_per_charge</span></code></a>([bond])</p></td>
<td><p>Return probabilites of charge value on the left of a given bond.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.set_B" title="tenpy.networks.mps.MPS.set_B"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_B</span></code></a>(i, B[, form])</p></td>
<td><p>Set <cite>B</cite> at site <cite>i</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.set_SL" title="tenpy.networks.mps.MPS.set_SL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_SL</span></code></a>(i, S)</p></td>
<td><p>Set singular values on the left of site <cite>i</cite></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.set_SR" title="tenpy.networks.mps.MPS.set_SR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_SR</span></code></a>(i, S)</p></td>
<td><p>Set singular values on the right of site <cite>i</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.swap_sites" title="tenpy.networks.mps.MPS.swap_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_sites</span></code></a>(i[, swap_op, trunc_par])</p></td>
<td><p>Swap the two neighboring sites <cite>i</cite> and <cite>i+1</cite> (inplace).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.networks.mps.MPS.test_sanity" title="tenpy.networks.mps.MPS.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</p></td>
<td><p>Sanity check.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.networks.mps.MPS.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises Errors if something is wrong.</p>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_product_state">
<em class="property">classmethod </em><code class="descname">from_product_state</code><span class="sig-paren">(</span><em>sites</em>, <em>p_state</em>, <em>bc='finite'</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>permute=True</em>, <em>form='B'</em>, <em>chargeL=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_product_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_product_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix product state from a given product state.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>sites</strong><span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt><dd><p>The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>p_state</strong><span class="classifier">iterable of {int | str | 1D array}</span></dt><dd><p>Defines the product state to be represented.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is str, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> is in state
<code class="docutils literal notranslate"><span class="pre">self.sites[i].state_labels(p_state[i])</span></code>.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is int, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> is in state <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code>.
If <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code> is an array, then site <code class="docutils literal notranslate"><span class="pre">i</span></code> wavefunction is <code class="docutils literal notranslate"><span class="pre">p_state[i]</span></code>.</p>
</dd>
<dt><strong>bc</strong><span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt><dd><p>MPS boundary conditions. See docstring of <a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or string</span></dt><dd><p>The data type of the array entries.</p>
</dd>
<dt><strong>permute</strong><span class="classifier">bool</span></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> might permute the local basis states if charge
conservation gets enabled.
If <cite>permute</cite> is True (default), we permute the given <cite>p_state</cite> locally according to
each site’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">perm</span></code>.
The <cite>p_state</cite> argument should then always be given as if <cite>conserve=None</cite> in the Site.</p>
</dd>
<dt><strong>form</strong><span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt><dd><p>Defines the canonical form. See module doc-string.
A single choice holds for all of the entries.</p>
</dd>
<dt><strong>chargeL</strong><span class="classifier">charges</span></dt><dd><p>Leg charge at bond 0, which are purely conventional.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>product_mps</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>An MPS representing the specified product state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>To get a Neel state:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">SpinChain</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_state</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># repeats entries L/2 times</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span> <span class="o">=</span> <span class="n">MPS</span><span class="o">.</span><span class="n">from_product_state</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mps_sites</span><span class="p">(),</span> <span class="n">p_state</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">bc_MPS</span><span class="p">)</span>
</pre></div>
</div>
<p>For Spin S=1/2, you could get a state with all sites pointing in negative x-direction with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">neg_x_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_state</span> <span class="o">=</span> <span class="p">[</span><span class="n">neg_x_state</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">neg_x_state</span><span class="p">)]</span><span class="o">*</span><span class="n">L</span>  <span class="c1"># other parameters as above</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_Bflat">
<em class="property">classmethod </em><code class="descname">from_Bflat</code><span class="sig-paren">(</span><em>sites</em>, <em>Bflat</em>, <em>SVs=None</em>, <em>bc='finite'</em>, <em>dtype=None</em>, <em>permute=True</em>, <em>form='B'</em>, <em>legL=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_Bflat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_Bflat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix product state from a set of numpy arrays <cite>Bflat</cite> and singular vals.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>sites</strong><span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt><dd><p>The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>Bflat</strong><span class="classifier">iterable of numpy ndarrays</span></dt><dd><p>The matrix defining the MPS on each site, with legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'vL',</span> <span class="pre">'vR'</span></code>
(physical, virtual left/right).</p>
</dd>
<dt><strong>SVs</strong><span class="classifier">list of 1D array | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>The singular values on <em>each</em> bond. Should always have length <cite>L+1</cite>.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), set all singular values to the same value.
Entries out of <a class="reference internal" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="tenpy.networks.mps.MPS.nontrivial_bonds"><code class="xref py py-attr docutils literal notranslate"><span class="pre">nontrivial_bonds</span></code></a> are ignored.</p>
</dd>
<dt><strong>bc</strong><span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt><dd><p>MPS boundary conditions. See docstring of <a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or string</span></dt><dd><p>The data type of the array entries. Defaults to the common dtype of <cite>Bflat</cite>.</p>
</dd>
<dt><strong>permute</strong><span class="classifier">bool</span></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> might permute the local basis states if charge
conservation gets enabled.
If <cite>permute</cite> is True (default), we permute the given <cite>Bflat</cite> locally according to
each site’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">perm</span></code>.
The <cite>p_state</cite> argument should then always be given as if <cite>conserve=None</cite> in the Site.</p>
</dd>
<dt><strong>form</strong><span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt><dd><p>Defines the canonical form of <cite>Bflat</cite>. See module doc-string.
A single choice holds for all of the entries.</p>
</dd>
<dt><strong>leg_L</strong><span class="classifier">LegCharge | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>Leg charges at bond 0, which are purely conventional.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use trivial charges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>mps</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>An MPS with the matrices <cite>Bflat</cite> converted to npc arrays.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_full">
<em class="property">classmethod </em><code class="descname">from_full</code><span class="sig-paren">(</span><em>sites</em>, <em>psi</em>, <em>form=None</em>, <em>cutoff=1e-16</em>, <em>normalize=True</em>, <em>bc='finite'</em>, <em>outer_S=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an MPS from a single tensor <cite>psi</cite> with one leg per physical site.</p>
<p>Performs a sequence of SVDs of psi to split off the <cite>B</cite> matrices and obtain the singular
values, the result will be in canonical form.
Obviously, this is only well-defined for <cite>finite</cite> or <cite>segment</cite> boundary conditions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>sites</strong><span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt><dd><p>The sites defining the local Hilbert space.</p>
</dd>
<dt><strong>psi</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The full wave function to be represented as an MPS.
Should have labels <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1',</span> <span class="pre">...,</span>&#160; <span class="pre">'p{L-1}'</span></code>.
Additionally, it may have (or must have for ‘segment’ <cite>bc</cite>) the legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR'</span></code>,
which are trivial for ‘finite’ <cite>bc</cite>.</p>
</dd>
<dt><strong>form</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">None</span></code></span></dt><dd><p>The canonical form of the resulting MPS, see module doc-string.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to ‘A’ form on the first site and ‘B’ form on all following sites.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>Cutoff of singular values used in the SVDs.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool</span></dt><dd><p>Whether the resulting MPS should have ‘norm’ 1.</p>
</dd>
<dt><strong>bc</strong><span class="classifier">‘finite’ | ‘segment’</span></dt><dd><p>Boundary conditions.</p>
</dd>
<dt><strong>outer_S</strong><span class="classifier">None | (array, array)</span></dt><dd><p>For ‘semgent’ <cite>bc</cite> the singular values on the left and right of the considered segment,
<cite>None</cite> for ‘finite’ boundary conditions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>psi_mps</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>MPS representation of <cite>psi</cite>, in canonical form and possibly normalized.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="tenpy.networks.mps.MPS.from_singlets">
<em class="property">classmethod </em><code class="descname">from_singlets</code><span class="sig-paren">(</span><em>site</em>, <em>L</em>, <em>pairs</em>, <em>up='up'</em>, <em>down='down'</em>, <em>lonely=[]</em>, <em>lonely_state='up'</em>, <em>bc='finite'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.from_singlets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.from_singlets" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an MPS of entangled singlets.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>site</strong><span class="classifier"><a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt><dd><p>The <cite>site</cite> defining the local Hilbert space, taken uniformly for all sites.</p>
</dd>
<dt><strong>L</strong><span class="classifier">int</span></dt><dd><p>The number of sites.</p>
</dd>
<dt><strong>pairs</strong><span class="classifier">list of (int, int)</span></dt><dd><p>Pairs of sites to be entangled; the returned MPS will have a singlet
for each pair in <cite>pairs</cite>.</p>
</dd>
<dt><strong>up, down</strong><span class="classifier">int | str</span></dt><dd><p>A singlet is defined as <code class="docutils literal notranslate"><span class="pre">(|up</span> <span class="pre">down&gt;</span> <span class="pre">-</span> <span class="pre">|down</span> <span class="pre">up&gt;)/2**0.5</span></code>,
<code class="docutils literal notranslate"><span class="pre">up</span></code> and <code class="docutils literal notranslate"><span class="pre">down</span></code> give state indices or labels defined on the corresponding site.</p>
</dd>
<dt><strong>lonely</strong><span class="classifier">list of int</span></dt><dd><p>Sites which are not included into a singlet pair.</p>
</dd>
<dt><strong>lonely_state</strong><span class="classifier">int | str</span></dt><dd><p>The state for the lonely sites.</p>
</dd>
<dt><strong>bc</strong><span class="classifier">{‘infinite’, ‘finite’, ‘segmemt’}</span></dt><dd><p>MPS boundary conditions. See docstring of <a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>singlet_mps</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>An MPS representing singlets on the specified pairs of sites.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of <cite>self</cite>.</p>
<p>The copy still shares the sites, chinfo, and LegCharges of the B tensors,
but the values of B and S are deeply copied.</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.L">
<code class="descname">L</code><a class="headerlink" href="#tenpy.networks.mps.MPS.L" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of physical sites. For an iMPS the len of the MPS unit cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.dim">
<code class="descname">dim</code><a class="headerlink" href="#tenpy.networks.mps.MPS.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>List of local physical dimensions.</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.finite">
<code class="descname">finite</code><a class="headerlink" href="#tenpy.networks.mps.MPS.finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Distinguish MPS (<code class="docutils literal notranslate"><span class="pre">True;</span> <span class="pre">bc='finite',</span> <span class="pre">'segment'</span></code> ) vs. iMPS (<code class="docutils literal notranslate"><span class="pre">False;</span> <span class="pre">bc='infinite'</span></code>)</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.chi">
<code class="descname">chi</code><a class="headerlink" href="#tenpy.networks.mps.MPS.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimensions of the (nontrivial) virtual bonds.</p>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.networks.mps.MPS.nontrivial_bonds">
<code class="descname">nontrivial_bonds</code><a class="headerlink" href="#tenpy.networks.mps.MPS.nontrivial_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice of the non-trivial bond indices, depending on <code class="docutils literal notranslate"><span class="pre">self.bc</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_B">
<code class="descname">get_B</code><span class="sig-paren">(</span><em>i</em>, <em>form='B'</em>, <em>copy=False</em>, <em>cutoff=1e-16</em>, <em>label_p=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (view of) <cite>B</cite> at site <cite>i</cite> in canonical form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Index choosing the site.</p>
</dd>
<dt><strong>form</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt><dd><p>The (canonical) form of the returned B.
For <code class="docutils literal notranslate"><span class="pre">None</span></code>, return the matrix in whatever form it is.
If any of the tuple entry is None, also don’t scale on the corresponding axis.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool</span></dt><dd><p>Whether to return a copy even if <cite>form</cite> matches the current form.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>During DMRG with a mixer, <cite>S</cite> may be a matrix for which we need the inverse.
This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
singular values.</p>
</dd>
<dt><strong>label_p</strong><span class="classifier">None | str</span></dt><dd><p>Ignored by default (<code class="docutils literal notranslate"><span class="pre">None</span></code>).
Otherwise replace the physical label <code class="docutils literal notranslate"><span class="pre">'p'</span></code> with <code class="docutils literal notranslate"><span class="pre">'p'+label_p'</span></code>.
(For derived classes with more than one “physical” leg, replace all the physical leg
labels accordingly.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>B</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The MPS ‘matrix’ <cite>B</cite> at site <cite>i</cite> with leg labels <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'p',</span> <span class="pre">'vR'</span></code>.
May be a view of the matrix (if <code class="docutils literal notranslate"><span class="pre">copy=False</span></code>),
or a copy (if the form changed or <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl>
<dt><strong>ValueError</strong><span class="classifier">if self is not in canoncial form and <cite>form</cite> is not None.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.set_B">
<code class="descname">set_B</code><span class="sig-paren">(</span><em>i</em>, <em>B</em>, <em>form='B'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.set_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.set_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <cite>B</cite> at site <cite>i</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Index choosing the site.</p>
</dd>
<dt><strong>B</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The ‘matrix’ at site <cite>i</cite>. No copy is made!
Should have leg labels <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'p',</span> <span class="pre">'vR'</span></code> (not necessarily in that order).</p>
</dd>
<dt><strong>form</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)</span></dt><dd><p>The (canonical) form of the <cite>B</cite> to set.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for non-canonical form.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_SL">
<code class="descname">get_SL</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_SL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_SL" title="Permalink to this definition">¶</a></dt>
<dd><p>Return singular values on the left of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_SR">
<code class="descname">get_SR</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_SR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_SR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return singular values on the right of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.set_SL">
<code class="descname">set_SL</code><span class="sig-paren">(</span><em>i</em>, <em>S</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.set_SL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.set_SL" title="Permalink to this definition">¶</a></dt>
<dd><p>Set singular values on the left of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.set_SR">
<code class="descname">set_SR</code><span class="sig-paren">(</span><em>i</em>, <em>S</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.set_SR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.set_SR" title="Permalink to this definition">¶</a></dt>
<dd><p>Set singular values on the right of site <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_op">
<code class="descname">get_op</code><span class="sig-paren">(</span><em>op_list</em>, <em>i</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of operators, select the one corresponding to site <cite>i</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op_list</strong><span class="classifier">(list of) {str | npc.array}</span></dt><dd><p>List of operators from which we choose. We assume that <code class="docutils literal notranslate"><span class="pre">op_list[j]</span></code> acts on site
<code class="docutils literal notranslate"><span class="pre">j</span></code>. If the length is shorter than <cite>L</cite>, we repeat it periodically.
Strings are translated using <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site.get_op" title="tenpy.networks.site.Site.get_op"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_op()</span></code></a> of site <cite>i</cite>.</p>
</dd>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Index of the site on which the operator acts.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>op</strong><span class="classifier">npc.array</span></dt><dd><p>One of the entries in <cite>op_list</cite>, not copied.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_theta">
<code class="descname">get_theta</code><span class="sig-paren">(</span><em>i</em>, <em>n=2</em>, <em>cutoff=1e-16</em>, <em>formL=1.0</em>, <em>formR=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_theta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>n</cite>-site wavefunction on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Site index.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of sites. The result lives on <code class="docutils literal notranslate"><span class="pre">sites[i:i+n]</span></code>.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>During DMRG with a mixer, <cite>S</cite> may be a matrix for which we need the inverse.
This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
singular values.</p>
</dd>
<dt><strong>formL</strong><span class="classifier">float</span></dt><dd><p>Exponent for the singular values to the left.</p>
</dd>
<dt><strong>formR</strong><span class="classifier">float</span></dt><dd><p>Exponent for the singular values to the right.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>theta</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The n-site wave function with leg labels <code class="docutils literal notranslate"><span class="pre">vL,</span> <span class="pre">p0,</span> <span class="pre">p1,</span> <span class="pre">....</span> <span class="pre">p{n-1},</span> <span class="pre">vR</span></code>.
In Vidal’s notation (with s=lambda, G=Gamma):
<code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">=</span> <span class="pre">s**form_L</span> <span class="pre">G_i</span> <span class="pre">s</span> <span class="pre">G_{i+1}</span> <span class="pre">s</span> <span class="pre">...</span> <span class="pre">G_{i+n-1}</span> <span class="pre">s**form_R</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.convert_form">
<code class="descname">convert_form</code><span class="sig-paren">(</span><em>new_form='B'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.convert_form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.convert_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Tranform self into different canonical form (by scaling the legs with singular values).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>new_form</strong><span class="classifier">(list of) {<code class="docutils literal notranslate"><span class="pre">'B'</span> <span class="pre">|</span> <span class="pre">'A'</span> <span class="pre">|</span> <span class="pre">'C'</span> <span class="pre">|</span> <span class="pre">'G'</span> <span class="pre">|</span> <span class="pre">'Th'</span> <span class="pre">|</span> <span class="pre">None</span></code> | tuple(float, float)}</span></dt><dd><p>The form the stored ‘matrices’. The table in module doc-string.
A single choice holds for all of the entries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl>
<dt><strong>ValueError</strong><span class="classifier">if trying to convert from a <code class="docutils literal notranslate"><span class="pre">None</span></code> form. Use <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> instead!</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.init_LP">
<code class="descname">init_LP</code><span class="sig-paren">(</span><em>i</em>, <em>bra=None</em>, <em>mpo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.init_LP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.init_LP" title="Permalink to this definition">¶</a></dt>
<dd><p>Build initial left part <code class="docutils literal notranslate"><span class="pre">LP</span></code> for an MPS/MPOEnvironment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Build <code class="docutils literal notranslate"><span class="pre">LP</span></code> left of site <cite>i</cite>.</p>
</dd>
<dt><strong>bra</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>Check leg compatiblity with a <cite>bra</cite>. Note that the returned <cite>init_LP</cite> will
only be the contraction for the <code class="docutils literal notranslate"><span class="pre">LP</span></code> of  <code class="docutils literal notranslate"><span class="pre">&lt;bra|self&gt;</span></code> on the left most site <cite>i</cite> = 0
of a finite MPS.</p>
</dd>
<dt><strong>mpo</strong><span class="classifier">None | <a class="reference internal" href="tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt><dd><p>If given, add a leg for the MPO. Requires the <cite>MPO.IdL</cite> on site <cite>i</cite> to be set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>init_LP</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Identity contractible with the <cite>vL</cite> leg of <code class="docutils literal notranslate"><span class="pre">self.get_B(i)</span></code>, labels <code class="docutils literal notranslate"><span class="pre">'vR*',</span> <span class="pre">'vR'</span></code>.
If <cite>mpo</cite> is given, multiplied with a unit vector nonzero in <code class="docutils literal notranslate"><span class="pre">mpo.IdL[i]</span></code>,
with labels <code class="docutils literal notranslate"><span class="pre">'vR*',</span> <span class="pre">'wR',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.init_RP">
<code class="descname">init_RP</code><span class="sig-paren">(</span><em>i</em>, <em>bra=None</em>, <em>mpo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.init_RP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.init_RP" title="Permalink to this definition">¶</a></dt>
<dd><p>Build initial right part <code class="docutils literal notranslate"><span class="pre">RP</span></code> for an MPS/MPOEnvironment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Build <code class="docutils literal notranslate"><span class="pre">RP</span></code> right of site <cite>i</cite>.</p>
</dd>
<dt><strong>bra</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>Check leg compatiblity with a <cite>bra</cite>. Note that the returned <cite>init_RP</cite> will
only be the contraction for the <code class="docutils literal notranslate"><span class="pre">RP</span></code> of  <code class="docutils literal notranslate"><span class="pre">&lt;bra|self&gt;</span></code> on the right most site
<cite>i</cite> = L - 1 of a finite MPS.</p>
</dd>
<dt><strong>mpo</strong><span class="classifier">None | <a class="reference internal" href="tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt><dd><p>If given, add a leg for the MPO. Requires the <cite>MPO.IdR</cite> on site <cite>i</cite> to be set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>init_RP</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Identity contractible with the <cite>vR</cite> leg of <code class="docutils literal notranslate"><span class="pre">self.get_B(i)</span></code>, labels <code class="docutils literal notranslate"><span class="pre">'vL*',</span> <span class="pre">'vL'</span></code>.
If <cite>mpo</cite> is given, multiplied with a unit vector nonzero in <code class="docutils literal notranslate"><span class="pre">mpo.IdR[i]</span></code>,
with labels <code class="docutils literal notranslate"><span class="pre">'vL*',</span> <span class="pre">'wL',</span> <span class="pre">'vL'</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.group_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> inplace to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong><span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt><dd><p>The sites grouped together.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.group_split" title="tenpy.networks.mps.MPS.group_split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_split</span></code></a></dt><dd><p>Reverts the grouping.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.group_split">
<code class="descname">group_split</code><span class="sig-paren">(</span><em>trunc_par={}</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.group_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.group_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> inplace to split previously grouped sites.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trunc_par</strong><span class="classifier">dict</span></dt><dd><p>Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.
<cite>chi_max</cite> defaults to <code class="docutils literal notranslate"><span class="pre">max(self.chi)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>trunc_err</strong><span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt><dd><p>The error introduced by the truncation for the splitting.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.group_sites" title="tenpy.networks.mps.MPS.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a></dt><dd><p>Should have been used before to combine sites.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_grouped_mps">
<code class="descname">get_grouped_mps</code><span class="sig-paren">(</span><em>blocklen</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_grouped_mps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_grouped_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>contract blocklen subsequent tensors into a single one and return result as a new MPS.</p>
<p>blocklen = number of subsequent sites to be combined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new MPS object with bunched sites.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_total_charge">
<code class="descname">get_total_charge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_total_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and return the <cite>qtotal</cite> of the whole MPS (when contracted).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qtotal</strong><span class="classifier">charges</span></dt><dd><p>The sum of the <cite>qtotal</cite> of the individual <cite>B</cite> tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.gauge_total_charge">
<code class="descname">gauge_total_charge</code><span class="sig-paren">(</span><em>qtotal=None</em>, <em>vL_leg=None</em>, <em>vR_leg=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.gauge_total_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.gauge_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Gauge the legcharges of the virtual bonds such that the MPS has a total <cite>qtotal</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qtotal</strong><span class="classifier">(list of) charges</span></dt><dd><p>If a single set of charges is given, it is the desired total charge of the MPS
(which <a class="reference internal" href="#tenpy.networks.mps.MPS.get_total_charge" title="tenpy.networks.mps.MPS.get_total_charge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_total_charge()</span></code></a> will return afterwards).
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), use 0 charges, unless vL_leg and vR_leg are specified, in which
case we adjust the total charge to match these legs.</p>
</dd>
<dt><strong>vL_leg</strong><span class="classifier">None | LegCharge</span></dt><dd><p>Desired new virtual leg on the very left. Needs to have the same block strucuture as
current leg, but can have shifted charge entries.</p>
</dd>
<dt><strong>vR_leg</strong><span class="classifier">None | LegCharge</span></dt><dd><p>Desired new virtual leg on the very right. Needs to have the same block strucuture as
current leg, but can have shifted charge entries.
Should be <cite>vL_leg.conj()</cite> for infinite MPS, if <cite>qtotal</cite> is not given.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.entanglement_entropy">
<code class="descname">entanglement_entropy</code><span class="sig-paren">(</span><em>n=1</em>, <em>bonds=None</em>, <em>for_matrix_S=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.entanglement_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.entanglement_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the (half-chain) entanglement entropy for all nontrivial bonds.</p>
<p>Consider a bipartition of the sytem into <span class="math notranslate nohighlight">\(A = \{ j: j &lt;= i_b \}\)</span> and
<span class="math notranslate nohighlight">\(B = \{ j: j &gt; i_b\}\)</span> and the reduced density matrix <span class="math notranslate nohighlight">\(\rho_A = tr_B(\rho)\)</span>.
The von-Neumann entanglement entropy is defined as
<span class="math notranslate nohighlight">\(S(A, n=1) = -tr(\rho_A \log(\rho_A)) = S(B, n=1)\)</span>.
The generalization for <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">!=</span> <span class="pre">1,</span> <span class="pre">n&gt;0</span></code> are the Renyi entropies:
<span class="math notranslate nohighlight">\(S(A, n) = \frac{1}{1-n} \log(tr(\rho_A^2)) = S(B, n=1)\)</span></p>
<p>This function calculates the entropy for a cut at different bonds <cite>i</cite>, for which the
the eigenvalues of the reduced density matrix <span class="math notranslate nohighlight">\(\rho_A\)</span> and <span class="math notranslate nohighlight">\(\rho_B\)</span> is given
by the squared schmidt values <cite>S</cite> of the bond.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int/float</span></dt><dd><p>Selects which entropy to calculate;
<cite>n=1</cite> (default) is the ususal von-Neumann entanglement entropy.</p>
</dd>
<dt><strong>bonds</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | (iterable of) int</span></dt><dd><p>Selects the bonds at which the entropy should be calculated.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L+1)[self.nontrivial_bonds]</span></code>.</p>
</dd>
<dt><strong>for_matrix_S</strong><span class="classifier">bool</span></dt><dd><p>Switch calculate the entanglement entropy even if the <cite>_S</cite> are matrices.
Since <span class="math notranslate nohighlight">\(O(\chi^3)\)</span> is expensive compared to the ususal <span class="math notranslate nohighlight">\(O(\chi)\)</span>,
we raise an error by default.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropies</strong><span class="classifier">1D ndarray</span></dt><dd><p>Entanglement entropies for half-cuts.
<cite>entropies[j]</cite> contains the entropy for a cut at bond <code class="docutils literal notranslate"><span class="pre">bonds[j]</span></code>
(i.e. left to site <code class="docutils literal notranslate"><span class="pre">bonds[j]</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.entanglement_entropy_segment">
<code class="descname">entanglement_entropy_segment</code><span class="sig-paren">(</span><em>segment=[0], first_site=None, n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.entanglement_entropy_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.entanglement_entropy_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate entanglement entropy for general geometry of the bipartition.</p>
<p>This function is similar as <a class="reference internal" href="#tenpy.networks.mps.MPS.entanglement_entropy" title="tenpy.networks.mps.MPS.entanglement_entropy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">entanglement_entropy()</span></code></a>,
but for more general geometry of the region <cite>A</cite> to be a segment of a <em>few</em> sites.</p>
<p>This is acchieved by explicitly calculating the reduced density matrix of <cite>A</cite>
and thus works only for small segments.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>segment</strong><span class="classifier">list of int</span></dt><dd><p>Given a first site <cite>i</cite>, the region <code class="docutils literal notranslate"><span class="pre">A_i</span></code> is defined to be <code class="docutils literal notranslate"><span class="pre">[i+j</span> <span class="pre">for</span> <span class="pre">j</span> <span class="pre">in</span> <span class="pre">segment]</span></code>.</p>
</dd>
<dt><strong>first_site</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | (iterable of) int</span></dt><dd><p>Calculate the entropy for segments starting at these sites.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">range(L-segment[-1])</span></code> for finite
or <cite>range(L)</cite> for infinite boundary conditions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int | float</span></dt><dd><p>Selects which entropy to calculate;
<cite>n=1</cite> (default) is the ususal von-Neumann entanglement entropy,
otherwise the <cite>n</cite>-th Renyi entropy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropies</strong><span class="classifier">1D ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">entropies[i]</span></code> contains the entropy for the the region <code class="docutils literal notranslate"><span class="pre">A_i</span></code> defined above.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.entanglement_spectrum">
<code class="descname">entanglement_spectrum</code><span class="sig-paren">(</span><em>by_charge=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.entanglement_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.entanglement_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>return entanglement energy spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by_charge</strong><span class="classifier">bool</span></dt><dd><p>Wheter we should sort the spectrum on each bond by the possible charges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ent_spectrum</strong><span class="classifier">list</span></dt><dd><p>For each (non-trivial) bond the entanglement spectrum.
If <cite>by_charge</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, return (for each bond) a sorted 1D ndarray
with the convention <span class="math notranslate nohighlight">\(S_i^2 = e^{-\xi_i}\)</span>, where <span class="math notranslate nohighlight">\(S_i\)</span> labels a Schmidt
value and <span class="math notranslate nohighlight">\(\xi_i\)</span> labels the entanglement ‘energy’ in the returned spectrum.
If <cite>by_charge</cite> is True, return a a list of tuples <code class="docutils literal notranslate"><span class="pre">(charge,</span> <span class="pre">sub_spectrum)</span></code>
for each possible charge on that bond.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.get_rho_segment">
<code class="descname">get_rho_segment</code><span class="sig-paren">(</span><em>segment</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.get_rho_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.get_rho_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return reduced density matrix for a segment.</p>
<p>Note that the dimension of rho_A scales exponentially in the length of the segment.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>segment</strong><span class="classifier">iterable of int</span></dt><dd><p>Sites for which the reduced density matrix is to be calculated.
Assumed to be sorted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Reduced density matrix of the segment sites.
Labels <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1',</span> <span class="pre">...,</span> <span class="pre">'pk',</span> <span class="pre">'p0*',</span> <span class="pre">'p1*',</span> <span class="pre">...,</span> <span class="pre">'pk*'</span></code> with <code class="docutils literal notranslate"><span class="pre">k=len(segment)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.probability_per_charge">
<code class="descname">probability_per_charge</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.probability_per_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.probability_per_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return probabilites of charge value on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
This function returns the possible values of <cite>N_b</cite> as rows of <cite>charge_values</cite>,
and for each row the probabilty that this combination occurs in the given state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bond</strong><span class="classifier">int</span></dt><dd><p>The bond to be considered. The returned charges are summed on the left of this bond.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>charge_values</strong><span class="classifier">2D array</span></dt><dd><p>Columns correspond to the different charges in <cite>self.chinfo</cite>.
Rows are the different charge fluctuations at this bond</p>
</dd>
<dt><strong>probabilities</strong><span class="classifier">1D array</span></dt><dd><p>For each row of <cite>charge_values</cite> the probablity for these values of charge fluctuations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.average_charge">
<code class="descname">average_charge</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.average_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.average_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average charge for the block on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
Then this function returns <span class="math notranslate nohighlight">\(&lt;\psi| N_b |\psi&gt;\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bond</strong><span class="classifier">int</span></dt><dd><p>The bond to be considered.
The returned charges are summed over the sites left of <cite>bond</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>average_charge</strong><span class="classifier">1D array</span></dt><dd><p>For each type of charge in <code class="xref py py-attr docutils literal notranslate"><span class="pre">chinfo</span></code>
the average value when summing the charge values over sites left of the given bond.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.charge_variance">
<code class="descname">charge_variance</code><span class="sig-paren">(</span><em>bond=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.charge_variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.charge_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the charge variance on the left of a given bond.</p>
<p>For example for particle number conservation, define
<span class="math notranslate nohighlight">\(N_b = sum_{i&lt;b} n_i\)</span> for a given bond <cite>b</cite>.
Then this function returns <span class="math notranslate nohighlight">\(&lt;\psi| N_b^2 |\psi&gt; - (&lt;\psi| N_b |\psi&gt;)^2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bond</strong><span class="classifier">int</span></dt><dd><p>The bond to be considered.
The returned charges are summed over the sites left of <cite>bond</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>average_charge</strong><span class="classifier">1D array</span></dt><dd><p>For each type of charge in <code class="xref py py-attr docutils literal notranslate"><span class="pre">chinfo</span></code>
the variance of of the charge values left of the given bond.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.mutinf_two_site">
<code class="descname">mutinf_two_site</code><span class="sig-paren">(</span><em>max_range=None</em>, <em>n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.mutinf_two_site"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.mutinf_two_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-site mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span>.</p>
<p>Calculates <span class="math notranslate nohighlight">\(I(i:j) = S(i) + S(j) - S(i,j)\)</span>,
where <span class="math notranslate nohighlight">\(S(i)\)</span> is the single site entropy on site <span class="math notranslate nohighlight">\(i\)</span>
and <span class="math notranslate nohighlight">\(S(i,j)\)</span> the two-site entropy on sites <span class="math notranslate nohighlight">\(i,j\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_range</strong><span class="classifier">int</span></dt><dd><p>Maximal distance <code class="docutils literal notranslate"><span class="pre">|i-j|</span></code> for which the mutual information should be calculated.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <cite>L-1</cite>.</p>
</dd>
<dt><strong>n</strong><span class="classifier">float</span></dt><dd><p>Selects the entropy to use, see <a class="reference internal" href="tenpy.tools.math.entropy.html#tenpy.tools.math.entropy" title="tenpy.tools.math.entropy"><code class="xref py py-func docutils literal notranslate"><span class="pre">entropy()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">2D array</span></dt><dd><p>Coordinates for the mutinf array.</p>
</dd>
<dt><strong>mutinf</strong><span class="classifier">1D array</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">mutinf[k]</span></code> is the mutual information <span class="math notranslate nohighlight">\(I(i:j)\)</span> between the
sites <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">coords[k]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.overlap">
<code class="descname">overlap</code><span class="sig-paren">(</span><em>other</em>, <em>charge_sector=0</em>, <em>ignore_form=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute overlap <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>An MPS with the same physical sites.</p>
</dd>
<dt><strong>charge_sector</strong><span class="classifier">None | charges | <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt><dd><p>Selects the charge sector in which the dominant eigenvector of the TransferMatrix is.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for <em>all</em> sectors, <code class="docutils literal notranslate"><span class="pre">0</span></code> stands for the zero-charge sector.
Defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>, i.e., <em>assumes</em> the dominant eigenvector is in charge sector 0.</p>
</dd>
<dt><strong>ignore_form</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), take into account the canonical form <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> at each site.
If <code class="docutils literal notranslate"><span class="pre">True</span></code>, we ignore the canonical form (i.e., whether the MPS is in left, right,
mixed or no canonical form) and just contract all the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_B</span></code> as they are.
(This can give different results!)</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Further keyword arguments given to <a class="reference internal" href="tenpy.networks.mps.TransferMatrix.html#tenpy.networks.mps.TransferMatrix.eigenvectors" title="tenpy.networks.mps.TransferMatrix.eigenvectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TransferMatrix.eigenvectors()</span></code></a>;
only used for infinite boundary conditions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>overlap</strong><span class="classifier">dtype.type</span></dt><dd><p>The contraction <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span> <span class="pre">*</span> <span class="pre">self.norm</span> <span class="pre">*</span> <span class="pre">other.norm</span></code>
(i.e., taking into account the <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code> of both MPS).
For an infinite MPS, <code class="docutils literal notranslate"><span class="pre">&lt;self|other&gt;</span></code> is the overlap per unit cell, i.e.,
the largest eigenvalue of the TransferMatrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value">
<code class="descname">expectation_value</code><span class="sig-paren">(</span><em>ops</em>, <em>sites=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value <code class="docutils literal notranslate"><span class="pre">&lt;psi|ops|psi&gt;/&lt;psi|psi&gt;</span></code> of (n-site) operator(s).</p>
<p>Given the MPS in canonical form, it calculates n-site expectation values.
For example the contraction for a two-site (<cite>n</cite> = 2) operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span> <span class="n">op</span>  <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|-----|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ops</strong><span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt><dd><p>The operators, for wich the expectation value should be taken,
All operators should all have the same number of legs (namely <cite>2 n</cite>).
If less than <cite>self.L</cite> operators are given, we repeat them periodically.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>sites</strong><span class="classifier">None | list of int</span></dt><dd><p>List of site indices. Expectation values are evaluated there.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the entire chain is taken (clipping for finite b.c.)</p>
</dd>
<dt><strong>axes</strong><span class="classifier">None | (list of str, list of str)</span></dt><dd><p>Two lists of each <cite>n</cite> leg labels giving the physical legs of the operator used for
contraction. The first <cite>n</cite> legs are contracted with conjugated <cite>B</cite>,
the second <cite>n</cite> legs with the non-conjugated <cite>B</cite>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">(['p'],</span> <span class="pre">['p*'])</span></code> for single site operators (<cite>n</cite> = 1), or
<code class="docutils literal notranslate"><span class="pre">(['p0',</span> <span class="pre">'p1',</span> <span class="pre">...</span> <span class="pre">'p{n-1}'],</span> <span class="pre">['p0*',</span> <span class="pre">'p1*',</span> <span class="pre">....</span> <span class="pre">'p{n-1}*'])</span></code> for <cite>n</cite> &gt; 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exp_vals</strong><span class="classifier">1D ndarray</span></dt><dd><p>Expectation values, <code class="docutils literal notranslate"><span class="pre">exp_vals[i]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops[i]|psi&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">ops[i]</span></code> acts on
site(s) <code class="docutils literal notranslate"><span class="pre">j,</span> <span class="pre">j+1,</span> <span class="pre">...,</span> <span class="pre">j+{n-1}</span></code> with <code class="docutils literal notranslate"><span class="pre">j=sites[i]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>One site examples (n=1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="go">[Sz0, Sz1, ..., Sz{L-1}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Sx&#39;</span><span class="p">])</span>
<span class="go">[Sz0, Sx1, Sz2, Sx3, ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[Sz0, Sz3, Sz4]</span>
</pre></div>
</div>
<p>Two site example (n=2), assuming homogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx</span> <span class="o">=</span> <span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                     psi.sites[1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx</span><span class="p">)</span>
<span class="go">[Sz0Sx1, Sz1Sx2, Sz2Sx3, ... ]   # with len L-1 for finite bc, or L for infinite</span>
</pre></div>
</div>
<p>Example measuring &lt;psi|SzSx|psi2&gt; on each second site, for inhomogeneous sites:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SzSx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">npc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">psi</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Sz</span><span class="o">.</span><span class="n">replace_labels</span><span class="p">([</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;p*&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;p0*&#39;</span><span class="p">]),</span>
<span class="go">                           psi.sites[i+1].Sx.replace_labels([&#39;p&#39;, &#39;p*&#39;], [&#39;p1&#39;, &#39;p1*&#39;]))</span>
<span class="go">                 for i in range(0, psi.L-1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi</span><span class="o">.</span><span class="n">expectation_value</span><span class="p">(</span><span class="n">SzSx_list</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">psi</span><span class="o">.</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[Sz0Sx1, Sz2Sx3, Sz4Sx5, ...]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value_term">
<code class="descname">expectation_value_term</code><span class="sig-paren">(</span><em>term</em>, <em>autoJW=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op_{i0}op_{i1}...op_{iN}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p>
<p>Calculates the expectation value of a tensor product of single-site operators
acting on different sites <cite>i0</cite>, <cite>i1</cite>, … (not necessarily next to each other).
In other words, evaluate the expectation value of a term <code class="docutils literal notranslate"><span class="pre">op0_i0</span> <span class="pre">op1_i1</span> <span class="pre">op2_i2</span> <span class="pre">...</span></code>.</p>
<p>For example the contraction of three one-site operators on sites <cite>i0</cite>,
<cite>i1=i0+1</cite>, <cite>i2=i0+3</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>    <span class="n">op1</span>     <span class="n">op2</span>       <span class="o">|</span>       <span class="n">op3</span>       <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">-.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>term</strong><span class="classifier">list of (str, int)</span></dt><dd><p>List of tuples <code class="docutils literal notranslate"><span class="pre">op,</span> <span class="pre">i</span></code> where <cite>i</cite> is the MPS index of the site the operator
named <cite>op</cite> acts on.
The order inside <cite>term</cite> determines the order in which they act
(in the mathematical convention: the last operator in <cite>term</cite> is right-most,
so it acts first on a Ket).</p>
</dd>
<dt><strong>autoJW</strong><span class="classifier">bool</span></dt><dd><p>If True (default), automatically insert Jordan Wigner strings for Fermions as needed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exp_val</strong><span class="classifier">float/complex</span></dt><dd><p>The expectation value of the tensorproduct of the given onsite operators,
<code class="docutils literal notranslate"><span class="pre">&lt;psi|op_i0</span> <span class="pre">op_i1</span> <span class="pre">...</span> <span class="pre">op_iN</span> <span class="pre">|psi&gt;/&lt;psi|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> is the represented MPS.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.correlation_function" title="tenpy.networks.mps.MPS.correlation_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correlation_function</span></code></a></dt><dd><p>efficient way to evaluate many correlation functions.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">([(</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">([(</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Sx&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">expectation_value_multi_sites</span><span class="p">([</span><span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="s1">&#39;Id&#39;</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">],</span> <span class="n">i0</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value_multi_sites">
<code class="descname">expectation_value_multi_sites</code><span class="sig-paren">(</span><em>operators</em>, <em>i0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value_multi_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value_multi_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation value  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op0_{i0}op1_{i0+1}...opN_{i0+N}|psi&gt;/&lt;psi|psi&gt;</span></code>.</p>
<p>Calculates the expectation value of a tensor product of single-site operators
acting on different sites next to each other.
In other words, evaluate the expectation value of a term
<code class="docutils literal notranslate"><span class="pre">op0_i0</span> <span class="pre">op1_{i0+1}</span> <span class="pre">op2_{i0+2}</span> <span class="pre">...</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>operators</strong><span class="classifier">List of { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt><dd><p>List of one-site operators. This method calculates the
expectation value of the n-sites operator given by their tensor
product.</p>
</dd>
<dt><strong>i0</strong><span class="classifier">int</span></dt><dd><p>The left most index on which an operator acts, i.e.,
<code class="docutils literal notranslate"><span class="pre">operators[i]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">i0</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exp_val</strong><span class="classifier">float/complex</span></dt><dd><p>The expectation value of the tensorproduct of the given onsite operators,
<code class="docutils literal notranslate"><span class="pre">&lt;psi|operators[0]_{i0}</span> <span class="pre">operators[1]_{i0+1}</span> <span class="pre">...</span> <span class="pre">|psi&gt;/&lt;psi|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> is the represented MPS.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.expectation_value_terms_sum">
<code class="descname">expectation_value_terms_sum</code><span class="sig-paren">(</span><em>term_list</em>, <em>prefactors=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.expectation_value_terms_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.expectation_value_terms_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate expectation values for a bunch of terms and sum them up.</p>
<p>This is equivalent to the following expression:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">expectation_value_term</span><span class="p">(</span><span class="n">term</span><span class="p">)</span><span class="o">*</span><span class="n">strength</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">strength</span> <span class="ow">in</span> <span class="n">term_list</span><span class="p">])</span>
</pre></div>
</div>
<p>However, for effiency, the term_list is converted to an MPO and the expectation value
of the MPO is evaluated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Due to the way MPO expectation values are evaluated for infinite systems,
it works only if all terms in the <cite>term_list</cite> start within the MPS unit cell.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.4.0: </span><cite>prefactor</cite> will be removed in version 1.0.0.
Instead, directly give just <code class="docutils literal notranslate"><span class="pre">TermList(term_list,</span> <span class="pre">prefactors)</span></code> as argument.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>term_list</strong><span class="classifier"><a class="reference internal" href="tenpy.networks.terms.TermList.html#tenpy.networks.terms.TermList" title="tenpy.networks.terms.TermList"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermList</span></code></a></span></dt><dd><p>The terms and prefactors (<cite>strength</cite>) to be summed up.</p>
</dd>
<dt><strong>prefactors :</strong></dt><dd><p>Instead of specifying a <a class="reference internal" href="tenpy.networks.terms.TermList.html#tenpy.networks.terms.TermList" title="tenpy.networks.terms.TermList"><code class="xref py py-class docutils literal notranslate"><span class="pre">TermList</span></code></a>,
one can also specify the term_list and strength separately.
This is deprecated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>terms_sum</strong><span class="classifier">list of (complex) float</span></dt><dd><p>Equivalent to the expression
<code class="docutils literal notranslate"><span class="pre">sum([self.expectation_value_term(term)*strength</span> <span class="pre">for</span> <span class="pre">term,</span> <span class="pre">strength</span> <span class="pre">in</span> <span class="pre">term_list])</span></code>.</p>
</dd>
<dt><strong>_mpo :</strong></dt><dd><p>Intermediate results: the generated MPO.
For a finite MPS, <code class="docutils literal notranslate"><span class="pre">terms_sum</span> <span class="pre">=</span> <span class="pre">_mpo.expectation_value(self)</span></code>, for an infinite MPS
<code class="docutils literal notranslate"><span class="pre">terms_sum</span> <span class="pre">=</span> <span class="pre">_mpo.expectation_value(self)</span> <span class="pre">*</span> <span class="pre">self.L</span></code></p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.networks.mps.MPS.expectation_value_term" title="tenpy.networks.mps.MPS.expectation_value_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation_value_term</span></code></a></dt><dd><p>evaluates a single <cite>term</cite>.</p>
</dd>
<dt><a class="reference internal" href="tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO.expectation_value" title="tenpy.networks.mpo.MPO.expectation_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tenpy.networks.mpo.MPO.expectation_value</span></code></a></dt><dd><p>expectation value density of an MPO.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.correlation_function">
<code class="descname">correlation_function</code><span class="sig-paren">(</span><em>ops1</em>, <em>ops2</em>, <em>sites1=None</em>, <em>sites2=None</em>, <em>opstr=None</em>, <em>str_on_first=True</em>, <em>hermitian=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.correlation_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.correlation_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlation function  <code class="docutils literal notranslate"><span class="pre">&lt;psi|op1_i</span> <span class="pre">op2_j|psi&gt;/&lt;psi|psi&gt;</span></code> of single site operators.</p>
<p>Given the MPS in canonical form, it calculates 2-site correlation functions.
For examples the contraction for a two-site operator on site <cite>i</cite> would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...--</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="n">op2</span>    <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">op1</span>   <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>Onsite terms are taken in the order <code class="docutils literal notranslate"><span class="pre">&lt;psi</span> <span class="pre">|</span> <span class="pre">op1</span> <span class="pre">op2</span> <span class="pre">|</span> <span class="pre">psi&gt;</span></code>.</p>
<p>If <cite>opstr</cite> is given and <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code>, it calculates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>           <span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span>                               <span class="k">for</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span>
<span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...-</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---.</span>     <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">---</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--...-</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---.</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">opstr</span>  <span class="n">opstr</span>        <span class="n">op2</span>    <span class="o">|</span>     <span class="o">|</span>     <span class="n">op2</span>    <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="n">op1</span>    <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="n">opstr</span>  <span class="n">opstr</span>        <span class="n">op1</span>    <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>      <span class="o">|</span>            <span class="o">|</span>      <span class="o">|</span>
<span class="o">|</span>          <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...-</span> <span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--.</span>     <span class="o">.--</span><span class="n">S</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--</span><span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-...-</span> <span class="n">B</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">i==j</span></code>, no <cite>opstr</cite> is included.
For <code class="docutils literal notranslate"><span class="pre">str_on_first=False</span></code>, the <cite>opstr</cite> on site <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">j)</span></code> is always left out.</p>
<p>Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) in the arguments are translated into single-site
operators defined by the <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> on which they act.
Each operator should have the two legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'p*'</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ops1</strong><span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt><dd><p>First operator of the correlation function (acting after ops2).
<code class="docutils literal notranslate"><span class="pre">ops1[x]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">sites1[x]</span></code>.
If less than <code class="docutils literal notranslate"><span class="pre">len(sites1)</span></code> operators are given, we repeat them periodically.</p>
</dd>
<dt><strong>ops2</strong><span class="classifier">(list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt><dd><p>Second operator of the correlation function (acting before ops1).
<code class="docutils literal notranslate"><span class="pre">ops2[y]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">sites2[y]</span></code>.
If less than <code class="docutils literal notranslate"><span class="pre">len(sites2)</span></code> operators are given, we repeat them periodically.</p>
</dd>
<dt><strong>sites1</strong><span class="classifier">None | int | list of int</span></dt><dd><p>List of site indices; a single <cite>int</cite> is translated to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">sites1)</span></code>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to all sites <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L)</span></code>.
Is sorted before use, i.e. the order is ignored.</p>
</dd>
<dt><strong>sites2</strong><span class="classifier">None | int | list of int</span></dt><dd><p>List of site indices; a single <cite>int</cite> is translated to <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">sites2)</span></code>.
<code class="docutils literal notranslate"><span class="pre">None</span></code> defaults to all sites <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">L)</span></code>.
Is sorted before use, i.e. the order is ignored.</p>
</dd>
<dt><strong>opstr</strong><span class="classifier">None | (list of) { <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> | str }</span></dt><dd><p>Ignored by default (<code class="docutils literal notranslate"><span class="pre">None</span></code>).
Operator(s) to be inserted between <code class="docutils literal notranslate"><span class="pre">ops1</span></code> and <code class="docutils literal notranslate"><span class="pre">ops2</span></code>.
If less than <a class="reference internal" href="#tenpy.networks.mps.MPS.L" title="tenpy.networks.mps.MPS.L"><code class="xref py py-attr docutils literal notranslate"><span class="pre">L</span></code></a> operators are given, we repeat them periodically.
If given as a list, <code class="docutils literal notranslate"><span class="pre">opstr[r]</span></code> is inserted at site <cite>r</cite> (independent of <cite>sites1</cite> and
<cite>sites2</cite>).</p>
</dd>
<dt><strong>str_on_first</strong><span class="classifier">bool</span></dt><dd><p>Whether the <cite>opstr</cite> is included on the site <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">j)</span></code>.
Note the order, which is chosen that way to handle fermionic Jordan-Wigner strings
correctly. (In other words: choose <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code> for fermions!)</p>
</dd>
<dt><strong>hermitian</strong><span class="classifier">bool</span></dt><dd><p>Optimization flag: if <code class="docutils literal notranslate"><span class="pre">sites1</span> <span class="pre">==</span> <span class="pre">sites2</span></code> and <code class="docutils literal notranslate"><span class="pre">Ops1[i]^\dagger</span> <span class="pre">==</span> <span class="pre">Ops2[i]</span></code>
(which is not checked explicitly!), the resulting <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span></code> will be hermitian.
We can use that to avoid calculations, so <code class="docutils literal notranslate"><span class="pre">hermitian=True</span></code> will run faster.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>C</strong><span class="classifier">2D ndarray</span></dt><dd><p>The correlation function <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>,
where <code class="docutils literal notranslate"><span class="pre">ops1[i]</span></code> acts on site <code class="docutils literal notranslate"><span class="pre">i=sites1[x]</span></code> and <code class="docutils literal notranslate"><span class="pre">ops2[j]</span></code> on site <code class="docutils literal notranslate"><span class="pre">j=sites2[y]</span></code>.
If <cite>opstr</cite> is given, it gives (for <code class="docutils literal notranslate"><span class="pre">str_on_first=True</span></code>):</p>
<ul class="simple">
<li><p>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">prod_{i</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">j}</span> <span class="pre">opstr[r]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|prod_{j</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">i}</span> <span class="pre">opstr[r]</span> <span class="pre">ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</p></li>
<li><p>For <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">j</span></code>: <code class="docutils literal notranslate"><span class="pre">C[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">&lt;psi|ops1[i]</span> <span class="pre">ops2[j]|psi&gt;</span></code>.</p></li>
</ul>
<p>The condition <code class="docutils literal notranslate"><span class="pre">&lt;=</span> <span class="pre">r</span></code> is replaced by a strict <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">r</span></code>, if <code class="docutils literal notranslate"><span class="pre">str_on_first=False</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.norm_test">
<code class="descname">norm_test</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.norm_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.norm_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that self is in canonical form.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>norm_error: array, shape (L, 2)</strong></dt><dd><p>For each site the norm error to the left and right.
The error <code class="docutils literal notranslate"><span class="pre">norm_error[i,</span> <span class="pre">0]</span></code> is defined as the norm-difference between
the following networks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">--</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---.</span>       <span class="o">--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
<span class="o">|</span>       <span class="o">|</span>        <span class="o">|</span>    <span class="n">vs</span>         <span class="o">|</span>
<span class="o">|</span>   <span class="o">--</span><span class="n">theta</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>       <span class="o">--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--.</span>
</pre></div>
</div>
<p>Similarly, <code class="docutils literal notranslate"><span class="pre">norm_errror[i,</span> <span class="pre">1]</span></code> is the norm-difference of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>   <span class="o">.--</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">---</span>         <span class="o">.--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span>
<span class="o">|</span>   <span class="o">|</span>    <span class="o">|</span>          <span class="n">vs</span>     <span class="o">|</span>
<span class="o">|</span>   <span class="o">.--</span><span class="n">theta</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span>         <span class="o">.--</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.canonical_form">
<code class="descname">canonical_form</code><span class="sig-paren">(</span><em>renormalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.canonical_form"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.canonical_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring self into canonical ‘B’ form, (re-)calculate singular values.</p>
<p>Simply calls <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_finite" title="tenpy.networks.mps.MPS.canonical_form_finite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form_finite()</span></code></a> or <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form_infinite" title="tenpy.networks.mps.MPS.canonical_form_infinite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form_infinite()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.canonical_form_finite">
<code class="descname">canonical_form_finite</code><span class="sig-paren">(</span><em>renormalize=True</em>, <em>cutoff=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.canonical_form_finite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.canonical_form_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring a finite (or segment) MPS into canonical form (in place).</p>
<p>If any site is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>, it does <em>not</em> use any of the singular values <cite>S</cite>
(for ‘finite’ boundary conditions, or only the very left <cite>S</cite> for ‘segment’ b.c.).
If all sites have a <cite>form</cite>, it respects the <cite>form</cite> to ensure
that one <cite>S</cite> is included per bond.
The final state is always in right-canonical ‘B’ form.</p>
<p>Performs one sweep left to right doing QR decompositions, and one sweep right to left
doing SVDs calculating the singular values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>renormalize: bool</strong></dt><dd><p>Whether a change in the norm should be discarded or used to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float | None</span></dt><dd><p>Cutoff of singular values used in the SVDs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>U_L, V_R</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Only returned for <code class="docutils literal notranslate"><span class="pre">'segment'</span></code> boundary conditions.
The unitaries defining the new left and right Schmidt states in terms of the old ones,
with legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.canonical_form_infinite">
<code class="descname">canonical_form_infinite</code><span class="sig-paren">(</span><em>renormalize=True</em>, <em>tol_xi=1000000.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.canonical_form_infinite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.canonical_form_infinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring an infinite MPS into canonical form (in place).</p>
<p>If any site is in <code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>, it does <em>not</em> use any of the singular values <cite>S</cite>.
If all sites have a <cite>form</cite>, it respects the <cite>form</cite> to ensure
that one <cite>S</cite> is included per bond.
The final state is always in right-canonical ‘B’ form.</p>
<p>Proceeds in three steps, namely 1) diagonalize right and left transfermatrix on a given
bond to bring that bond into canonical form, and then
2) sweep right to left, and 3) left to right to bringing other bonds into canonical form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>renormalize: bool</strong></dt><dd><p>Whether a change in the norm should be discarded or used to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
</dd>
<dt><strong>tol_xi</strong><span class="classifier">float</span></dt><dd><p>Raise an error if the correlation length is larger than that
(which indicates a degenerate “cat” state, e.g., for spontaneous symmetry breaking).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.correlation_length">
<code class="descname">correlation_length</code><span class="sig-paren">(</span><em>target=1</em>, <em>tol_ev0=1e-08</em>, <em>charge_sector=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.correlation_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation length by diagonalizing the transfer matrix.</p>
<p>Assumes that <cite>self</cite> is in canonical form.</p>
<p>Works only for infinite MPS, where the transfer matrix is a useful concept.
Assuming a single-site unit cell, any correlation function splits into
<span class="math notranslate nohighlight">\(C(A_i, B_j) = A'_i T^{j-i-1} B'_j\)</span>
with some parts left and right and the <span class="math notranslate nohighlight">\(j-i-1\)</span>-th power of the transfer matrix in
between. The largest eigenvalue is 1 (if self is properly normalized)
and gives the dominant contribution of
<span class="math notranslate nohighlight">\(A'_i E_1 * 1^{j-i-1} * E_1^T B'_j = &lt;A&gt; &lt;B&gt;\)</span>,
and the second largest one gives a contribution <span class="math notranslate nohighlight">\(\propto \lambda_2^{j-i-1}\)</span>.
Thus <span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{1}{\xi})\)</span>.</p>
<p>More general for a <cite>L</cite>-site unit cell we get <span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{L}{\xi})\)</span>,
where the <cite>xi</cite> is given in units of 1 lattice spacing in the MPS.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For a higher-dimensional lattice (which the MPS class doesn’t know about),
the correct unit is the lattice spacing in x-direction, and the correct formula is
<span class="math notranslate nohighlight">\(\lambda_2 = \exp(-\frac{L_x}{\xi})\)</span>,
where <cite>L_x</cite> is the number of lattice spacings in the infinite direction within the
MPS unit cell, e.g. the number of “rings” of a cylinder in the MPS unit cell.
To get to these units, divide the returned <cite>xi</cite> by the number of sites within a “ring”,
for a lattice given in <code class="xref py py-attr docutils literal notranslate"><span class="pre">N_sites_per_ring</span></code>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>target</strong><span class="classifier">int</span></dt><dd><p>We look for the <cite>target</cite> + 1 largest eigenvalues.</p>
</dd>
<dt><strong>tol_ev0</strong><span class="classifier">float</span></dt><dd><p>Print warning if largest eigenvalue deviates from 1 by more than <cite>tol_ev0</cite>.</p>
</dd>
<dt><strong>charge_sector</strong><span class="classifier">None | charges | <code class="docutils literal notranslate"><span class="pre">0</span></code></span></dt><dd><p>Selects the charge sector in which the dominant eigenvector of the TransferMatrix is.
<code class="docutils literal notranslate"><span class="pre">None</span></code> stands for <em>all</em> sectors, <code class="docutils literal notranslate"><span class="pre">0</span></code> stands for the zero-charge sector.
Defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>, i.e., <em>assumes</em> the dominant eigenvector is in charge sector 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xi</strong><span class="classifier">float | 1D array</span></dt><dd><p>If <cite>target`=1, return just the correlation length,
otherwise an array of the `target</cite> largest correlation lengths.
It is measured in units of a single lattice spacing in the MPS language,
see the warning above.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>other</em>, <em>alpha</em>, <em>beta</em>, <em>cutoff=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an MPS which represents <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|others&gt;</span></code>.</p>
<p>Works only for ‘finite’, ‘segment’ boundary conditions.
For ‘segment’ boundary conditions, the virtual legs on the very left/right are
assumed to correspond to each other (i.e. self and other have the same state outside of
the considered segment).
Takes into account <code class="xref py py-attr docutils literal notranslate"><span class="pre">norm</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>Another MPS of the same length to be added with self.</p>
</dd>
<dt><strong>alpha, beta</strong><span class="classifier">complex float</span></dt><dd><p>Prefactors for self and other. We calculate
<code class="docutils literal notranslate"><span class="pre">alpha</span> <span class="pre">*</span> <span class="pre">|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">*</span> <span class="pre">|other&gt;</span></code></p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float | None</span></dt><dd><p>Cutoff of singular values used in the SVDs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>sum</strong><span class="classifier"><a class="reference internal" href="#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt><dd><p>An MPS representing <code class="docutils literal notranslate"><span class="pre">alpha|self&gt;</span> <span class="pre">+</span> <span class="pre">beta</span> <span class="pre">|other&gt;</span></code>.
Has same total charge as <cite>self</cite>.</p>
</dd>
<dt><strong>U_L, V_R</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Only returned for <code class="docutils literal notranslate"><span class="pre">'segment'</span></code> boundary conditions.
The unitaries defining the new left and right Schmidt states in terms of the old ones,
with legs <code class="docutils literal notranslate"><span class="pre">'vL',</span> <span class="pre">'vR'</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.apply_local_op">
<code class="descname">apply_local_op</code><span class="sig-paren">(</span><em>i</em>, <em>op</em>, <em>unitary=None</em>, <em>renormalize=False</em>, <em>cutoff=1e-13</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.apply_local_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.apply_local_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a local (one or multi-site) operator to <cite>self</cite>.</p>
<p>Note that this destroys the canonical form if the local operator is non-unitary.
Therefore, this function calls <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> if necessary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>(Left-most) index of the site(s) on which the operator should act.</p>
</dd>
<dt><strong>op</strong><span class="classifier">str | npc.Array</span></dt><dd><p>A physical operator acting on site <cite>i</cite>, with legs <code class="docutils literal notranslate"><span class="pre">'p',</span> <span class="pre">'p*'</span></code> for a single-site
operator or with legs <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p1',</span> <span class="pre">...],</span> <span class="pre">['p0*',</span> <span class="pre">'p1*',</span> <span class="pre">...]</span></code> for an operator
acting on <cite>n</cite>&gt;=2 sites.
Strings (like <code class="docutils literal notranslate"><span class="pre">'Id',</span> <span class="pre">'Sz'</span></code>) are translated into single-site operators defined by
<code class="xref py py-attr docutils literal notranslate"><span class="pre">sites</span></code>.</p>
</dd>
<dt><strong>unitary</strong><span class="classifier">None | bool</span></dt><dd><p>Whether <cite>op</cite> is unitary, i.e., whether the canonical form is preserved (<code class="docutils literal notranslate"><span class="pre">True</span></code>)
or whether we should call <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">False</span></code>).
<code class="docutils literal notranslate"><span class="pre">None</span></code> checks whether <code class="docutils literal notranslate"><span class="pre">norm(op</span> <span class="pre">dagger(op)</span> <span class="pre">-</span> <span class="pre">identity)</span></code> is smaller than <cite>cutoff</cite>.</p>
</dd>
<dt><strong>renormalize</strong><span class="classifier">bool</span></dt><dd><p>Whether the final state should keep track of the norm (False, default) or be
renormalized to have norm 1 (True).</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>Cutoff for singular values if <cite>op</cite> acts on more than one site (see <a class="reference internal" href="#tenpy.networks.mps.MPS.from_full" title="tenpy.networks.mps.MPS.from_full"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_full()</span></code></a>).
(And used as cutoff for a unspecified <cite>unitary</cite>.)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.swap_sites">
<code class="descname">swap_sites</code><span class="sig-paren">(</span><em>i</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.swap_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.swap_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the two neighboring sites <cite>i</cite> and <cite>i+1</cite> (inplace).</p>
<p>Exchange two neighboring sites: form theta, ‘swap’ the physical legs and split
with an svd. While the ‘swap’ is just a transposition/relabeling for bosons, one needs to
be careful about the sign for fermions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Swap the two sites at positions <cite>i</cite> and <cite>i+1</cite>.</p>
</dd>
<dt><strong>swap_op</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The operator used to swap the phyiscal legs of the two-site wave function <cite>theta</cite>.
For <code class="docutils literal notranslate"><span class="pre">None</span></code>, just transpose/relabel the legs, for <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> also take care of
fermionic signs. Alternative give an npc <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>
which represents the full operator used for the swap.
Should have legs <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p1',</span> <span class="pre">'p0*',</span> <span class="pre">'p1*']</span></code> whith <code class="docutils literal notranslate"><span class="pre">'p0',</span> <span class="pre">'p1*'</span></code> contractible.</p>
</dd>
<dt><strong>trunc_par</strong><span class="classifier">dict</span></dt><dd><p>Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.
<cite>chi_max</cite> defaults to <code class="docutils literal notranslate"><span class="pre">max(self.chi)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>trunc_err</strong><span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt><dd><p>The error of the represented state introduced by the truncation after the swap.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.permute_sites">
<code class="descname">permute_sites</code><span class="sig-paren">(</span><em>perm</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.permute_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.permute_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the permutation perm to the state (inplace).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>perm</strong><span class="classifier">ndarray[ndim=1, int]</span></dt><dd><p>The applied permutation, such that <code class="docutils literal notranslate"><span class="pre">psi.permute_sites(perm)[i]</span> <span class="pre">=</span> <span class="pre">psi[perm[i]]</span></code>
(where <code class="docutils literal notranslate"><span class="pre">[i]</span></code> indicates the <cite>i</cite>-th site).</p>
</dd>
<dt><strong>swap_op</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The operator used to swap the phyiscal legs of a two-site wave function <cite>theta</cite>,
see <a class="reference internal" href="#tenpy.networks.mps.MPS.swap_sites" title="tenpy.networks.mps.MPS.swap_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swap_sites()</span></code></a>.</p>
</dd>
<dt><strong>trunc_par</strong><span class="classifier">dict</span></dt><dd><p>Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.
<cite>chi_max</cite> defaults to <code class="docutils literal notranslate"><span class="pre">max(self.chi)</span></code>.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">float</span></dt><dd><p>Level of verbosity, print status messages if verbose &gt; 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>trunc_err</strong><span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt><dd><p>The error of the represented state introduced by the truncation after the swaps.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.networks.mps.MPS.compute_K">
<code class="descname">compute_K</code><span class="sig-paren">(</span><em>perm</em>, <em>swap_op='auto'</em>, <em>trunc_par={}</em>, <em>canonicalize=1e-06</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/networks/mps.html#MPS.compute_K"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.networks.mps.MPS.compute_K" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the momentum quantum numbers of the entanglement spectrum for 2D states.</p>
<p>Works for an infinite MPS living on a cylinder, infinitely long in <cite>x</cite> direction and with
periodic boundary conditions in <cite>y</cite> directions.
If the state is invariant under ‘rotations’ around the cylinder axis, one can find the
momentum quantum numbers of it. (The rotation is nothing more than a translation in <cite>y</cite>.)
This function permutes some sites (on a copy of <cite>self</cite>) to enact the rotation, and then
finds the dominant eigenvector of the mixed transfer matrix to get the quantum numbers,
along the lines of <a class="reference internal" href="../literature.html#pollmannturner2012" id="id1"><span>[PollmannTurner2012]</span></a>, see also (the appendix and Fig. 11 in the arXiv
version of) <a class="reference internal" href="../literature.html#cinciovidal2013" id="id2"><span>[CincioVidal2013]</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>perm</strong><span class="classifier">1D ndarray | <a class="reference internal" href="tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a></span></dt><dd><p>Permuation to be applied to the physical indices, see <a class="reference internal" href="#tenpy.networks.mps.MPS.permute_sites" title="tenpy.networks.mps.MPS.permute_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permute_sites()</span></code></a>.
If a lattice is given, we use it to read out the lattice structure and shift
each site by one lattice-vector in y-direction (assuming periodic boundary conditions).
(If you have a <a class="reference internal" href="tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a>,
give its <cite>lat</cite> attribute for this argument)</p>
</dd>
<dt><strong>swap_op</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | <code class="docutils literal notranslate"><span class="pre">'auto'</span></code> | <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>The operator used to swap the phyiscal legs of a two-site wave function <cite>theta</cite>,
see <a class="reference internal" href="#tenpy.networks.mps.MPS.swap_sites" title="tenpy.networks.mps.MPS.swap_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swap_sites()</span></code></a>.</p>
</dd>
<dt><strong>trunc_par</strong><span class="classifier">dict</span></dt><dd><p>Parameters for truncation, see <a class="reference internal" href="tenpy.algorithms.truncation.truncate.html#tenpy.algorithms.truncation.truncate" title="tenpy.algorithms.truncation.truncate"><code class="xref py py-func docutils literal notranslate"><span class="pre">truncate()</span></code></a>.
<cite>chi_max</cite> defaults to <code class="docutils literal notranslate"><span class="pre">max(self.chi)</span></code>.</p>
</dd>
<dt><strong>canonicalize</strong><span class="classifier">float</span></dt><dd><p>Check that <cite>self</cite> is in canonical form; call <a class="reference internal" href="#tenpy.networks.mps.MPS.canonical_form" title="tenpy.networks.mps.MPS.canonical_form"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical_form()</span></code></a>
if <a class="reference internal" href="#tenpy.networks.mps.MPS.norm_test" title="tenpy.networks.mps.MPS.norm_test"><code class="xref py py-meth docutils literal notranslate"><span class="pre">norm_test()</span></code></a> yields <code class="docutils literal notranslate"><span class="pre">np.linalg.norm(self.norm_test())</span> <span class="pre">&gt;</span> <span class="pre">canonicalize</span></code>.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">float</span></dt><dd><p>Level of verbosity, print status messages if verbose &gt; 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>U</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Unitary representation of the applied permutation on left Schmidt states.</p>
</dd>
<dt><strong>W</strong><span class="classifier">ndarray</span></dt><dd><p>1D array of the form <code class="docutils literal notranslate"><span class="pre">S**2</span> <span class="pre">exp(i</span> <span class="pre">K)</span></code>, where <cite>S</cite> are the Schmidt values
on the left bond. You can use <code class="xref py py-func docutils literal notranslate"><span class="pre">np.abs()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">np.angle()</span></code> to extract the
Schmidt values <cite>S</cite> and momenta <cite>K</cite> from <cite>W</cite>.</p>
</dd>
<dt><strong>q</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt><dd><p>LegCharge corresponding to <cite>W</cite>.</p>
</dd>
<dt><strong>ov</strong><span class="classifier">complex</span></dt><dd><p>The eigenvalue of the mixed transfer matrix <cite>&lt;psi|T|psi&gt;</cite> per <a class="reference internal" href="#tenpy.networks.mps.MPS.L" title="tenpy.networks.mps.MPS.L"><code class="xref py py-attr docutils literal notranslate"><span class="pre">L</span></code></a> sites.
An absolute value different smaller than 1 indicates that the state is not invariant
under the permutation or that the truncation error <cite>trunc_err</cite> was too large!</p>
</dd>
<dt><strong>trunc_err</strong><span class="classifier"><a class="reference internal" href="tenpy.algorithms.truncation.TruncationError.html#tenpy.algorithms.truncation.TruncationError" title="tenpy.algorithms.truncation.TruncationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TruncationError</span></code></a></span></dt><dd><p>The error of the represented state introduced by the truncation after swaps when
performing the truncation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.networks.mps.html"
                        title="previous chapter">mps</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.networks.mps.MPSEnvironment.html"
                        title="next chapter">MPSEnvironment</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference.html">Tenpy Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tenpy.algorithms.html">algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.linalg.html">linalg</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.models.html">models</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.networks.html">networks</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.site.html">site</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.networks.mps.html">mps</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.mpo.html">mpo</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.terms.html">terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.purification_mps.html">purification_mps</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.tools.html">tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.version.html">version</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mps.MPSEnvironment.html" title="MPSEnvironment"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.networks.mps.html" title="mps"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.4.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.networks.html" >networks</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="tenpy.networks.mps.html" >mps</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Aug 10, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.0.
    </div>
  </body>
</html>