
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Array &#8212; TeNPy 0.4.1 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="concatenate" href="tenpy.linalg.np_conserved.concatenate.html" />
    <link rel="prev" title="np_conserved" href="tenpy.linalg.np_conserved.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.np_conserved.concatenate.html" title="concatenate"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.np_conserved.html" title="np_conserved"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.linalg.html" >linalg</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="tenpy.linalg.np_conserved.html" accesskey="U">np_conserved</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="array">
<h1>Array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>full name: tenpy.linalg.np_conserved.Array</p></li>
<li><p>parent module: <a class="reference internal" href="tenpy.linalg.np_conserved.html#module-tenpy.linalg.np_conserved" title="tenpy.linalg.np_conserved"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.linalg.np_conserved</span></code></a></p></li>
<li><p>type: class</p></li>
</ul>
<dl class="class">
<dt id="tenpy.linalg.np_conserved.Array">
<em class="property">class </em><code class="sig-prename descclassname">tenpy.linalg.np_conserved.</code><code class="sig-name descname">Array</code><span class="sig-paren">(</span><em class="sig-param">legcharges</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em>, <em class="sig-param">qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A multidimensional array (=tensor) for using charge conservation.</p>
<p>An <cite>Array</cite> represents a multi-dimensional tensor,
together with the charge structure of its legs (for abelian charges).
Further information can be found in <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
<p>The default <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> (i.e. <code class="docutils literal notranslate"><span class="pre">Array(...)</span></code>) does not insert any data,
and thus yields an Array ‘full’ of zeros, equivalent to <a class="reference internal" href="tenpy.linalg.np_conserved.zeros.html#tenpy.linalg.np_conserved.zeros" title="tenpy.linalg.np_conserved.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>.
Further, new arrays can be created with one of <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="tenpy.linalg.np_conserved.Array.from_ndarray_trivial"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ndarray_trivial()</span></code></a>,
<a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ndarray()</span></code></a>, or <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func" title="tenpy.linalg.np_conserved.Array.from_func"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_func()</span></code></a>, and of course by copying/tensordot/svd etc.</p>
<p>In-place methods are indicated by a name starting with <code class="docutils literal notranslate"><span class="pre">i</span></code>.
(But <cite>is_completely_blocked</cite> is not inplace…)</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>legcharges</strong><span class="classifier">list of <a class="reference internal" href="tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt><dd><p>The leg charges for each of the legs. The <code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is read out from it.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type or string</span></dt><dd><p>The data type of the array entries. Defaults to np.float64.</p>
</dd>
<dt><strong>qtotal</strong><span class="classifier">1D array of QTYPE</span></dt><dd><p>The total charge of the array. Defaults to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.size" title="tenpy.linalg.np_conserved.Array.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></dt><dd><p>The number of dtype-objects stored.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.stored_blocks" title="tenpy.linalg.np_conserved.Array.stored_blocks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stored_blocks</span></code></a></dt><dd><p>The number of (non-zero) blocks stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">_data</span></code>.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank or “number of dimensions”, equivalent to <code class="docutils literal notranslate"><span class="pre">len(shape)</span></code>.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple(int)</span></dt><dd><p>The number of indices for each of the legs.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype</span></dt><dd><p>The data type of the entries.</p>
</dd>
<dt><strong>chinfo</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.ChargeInfo.html#tenpy.linalg.charges.ChargeInfo" title="tenpy.linalg.charges.ChargeInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></a></span></dt><dd><p>The nature of the charge.</p>
</dd>
<dt><strong>qtotal</strong><span class="classifier">1D array</span></dt><dd><p>The total charge of the tensor.</p>
</dd>
<dt><strong>legs</strong><span class="classifier">list of <a class="reference internal" href="tenpy.linalg.charges.LegCharge.html#tenpy.linalg.charges.LegCharge" title="tenpy.linalg.charges.LegCharge"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></a></span></dt><dd><p>The leg charges for each of the legs.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">dict (string -&gt; int)</span></dt><dd><p>Labels for the different legs.</p>
</dd>
<dt><strong>_data</strong><span class="classifier">list of arrays</span></dt><dd><p>The actual entries of the tensor.</p>
</dd>
<dt><strong>_qdata</strong><span class="classifier">2D array (len(_data), rank), dtype np.intp</span></dt><dd><p>For each of the _data entries the qindices of the different legs.</p>
</dd>
<dt><strong>_qdata_sorted</strong><span class="classifier">Bool</span></dt><dd><p>Whether self._qdata is lexsorted. Defaults to <cite>True</cite>,
but <em>must</em> be set to <cite>False</cite> by algorithms changing _qdata.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_charge" title="tenpy.linalg.np_conserved.Array.add_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_charge</span></code></a>(add_legs[, chinfo, qtotal])</p></td>
<td><p>Add charges.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_leg" title="tenpy.linalg.np_conserved.Array.add_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_leg</span></code></a>(leg, i[, axis, label])</p></td>
<td><p>Add a leg to <cite>self</cite>, setting the current array as slice for a given index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_trivial_leg" title="tenpy.linalg.np_conserved.Array.add_trivial_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_trivial_leg</span></code></a>([axis, label, qconj])</p></td>
<td><p>Add a trivial leg (with just one entry) to <cite>self</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.as_completely_blocked" title="tenpy.linalg.np_conserved.Array.as_completely_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_completely_blocked</span></code></a>()</p></td>
<td><p>Gives a version of self which is completely blocked by charges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.astype" title="tenpy.linalg.np_conserved.Array.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(dtype[, copy])</p></td>
<td><p>Return copy with new dtype, upcasting all blocks in <code class="docutils literal notranslate"><span class="pre">_data</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.binary_blockwise" title="tenpy.linalg.np_conserved.Array.binary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_blockwise</span></code></a>(func, other, *args, **kwargs)</p></td>
<td><p>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.change_charge" title="tenpy.linalg.np_conserved.Array.change_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">change_charge</span></code></a>(charge, new_qmod[, new_name, …])</p></td>
<td><p>Change the <cite>qmod</cite> of one charge in <cite>chinfo</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_legs</span></code></a>(combine_legs[, new_axes, …])</p></td>
<td><p>Reshape: combine multiple legs into multiple pipes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.complex_conj" title="tenpy.linalg.np_conserved.Array.complex_conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_conj</span></code></a>()</p></td>
<td><p>Return copy which is complex conjugated <em>without</em> conjugating the charge data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.conj" title="tenpy.linalg.np_conserved.Array.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a>([complex_conj, inplace])</p></td>
<td><p>Conjugate: complex conjugate data, conjugate charge data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.copy" title="tenpy.linalg.np_conserved.Array.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([deep])</p></td>
<td><p>Return a (deep or shallow) copy of self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.drop_charge" title="tenpy.linalg.np_conserved.Array.drop_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_charge</span></code></a>([charge, chinfo])</p></td>
<td><p>Drop (one of) the charges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.extend" title="tenpy.linalg.np_conserved.Array.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(axis, extra)</p></td>
<td><p>Increase the dimension of a given axis, filling the values with zeros.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func" title="tenpy.linalg.np_conserved.Array.from_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_func</span></code></a>(func, legcharges[, dtype, qtotal, …])</p></td>
<td><p>Create an Array from a numpy func.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_func_square" title="tenpy.linalg.np_conserved.Array.from_func_square"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_func_square</span></code></a>(func, leg[, dtype, …])</p></td>
<td><p>Create an Array from a (numpy) function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_ndarray</span></code></a>(data_flat, legcharges[, dtype, …])</p></td>
<td><p>convert a flat (numpy) ndarray to an Array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="tenpy.linalg.np_conserved.Array.from_ndarray_trivial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_ndarray_trivial</span></code></a>(data_flat[, dtype])</p></td>
<td><p>convert a flat numpy ndarray to an Array with trivial charge conservation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.gauge_total_charge" title="tenpy.linalg.np_conserved.Array.gauge_total_charge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_total_charge</span></code></a>(axis[, newqtotal, new_qconj])</p></td>
<td><p>Changes the total charge by adjusting the charge on a certain leg.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg" title="tenpy.linalg.np_conserved.Array.get_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg</span></code></a>(label)</p></td>
<td><p>Return <code class="docutils literal notranslate"><span class="pre">self.legs[self.get_leg_index(label)]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_index" title="tenpy.linalg.np_conserved.Array.get_leg_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_index</span></code></a>(label)</p></td>
<td><p>translate a leg-index or leg-label to a leg-index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_indices" title="tenpy.linalg.np_conserved.Array.get_leg_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_indices</span></code></a>(labels)</p></td>
<td><p>Translate a list of leg-indices or leg-labels to leg indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_labels" title="tenpy.linalg.np_conserved.Array.get_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_labels</span></code></a>()</p></td>
<td><p>Return list of the leg labels, with <cite>None</cite> for anonymous legs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.has_label" title="tenpy.linalg.np_conserved.Array.has_label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_label</span></code></a>(label)</p></td>
<td><p>Check whether a given label exists.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iadd_prefactor_other" title="tenpy.linalg.np_conserved.Array.iadd_prefactor_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iadd_prefactor_other</span></code></a>(prefactor, other)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">+=</span> <span class="pre">prefactor</span> <span class="pre">*</span> <span class="pre">other</span></code> for scalar <cite>prefactor</cite> and <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> <cite>other</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ibinary_blockwise" title="tenpy.linalg.np_conserved.Array.ibinary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ibinary_blockwise</span></code></a>(func, other, *args, **kwargs)</p></td>
<td><p>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iconj" title="tenpy.linalg.np_conserved.Array.iconj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iconj</span></code></a>([complex_conj])</p></td>
<td><p>Wraper around <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.conj()</span></code> with <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.idrop_labels" title="tenpy.linalg.np_conserved.Array.idrop_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">idrop_labels</span></code></a>([old_labels])</p></td>
<td><p>Remove leg labels from self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iproject" title="tenpy.linalg.np_conserved.Array.iproject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iproject</span></code></a>(mask, axes)</p></td>
<td><p>Applying masks to one or multiple axes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ipurge_zeros" title="tenpy.linalg.np_conserved.Array.ipurge_zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ipurge_zeros</span></code></a>([cutoff, norm_order])</p></td>
<td><p>Removes <code class="docutils literal notranslate"><span class="pre">self._data</span></code> blocks with <em>norm</em> less than cutoff.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ireplace_label" title="tenpy.linalg.np_conserved.Array.ireplace_label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ireplace_label</span></code></a>(old_label, new_label)</p></td>
<td><p>Replace the leg label <cite>old_label</cite> with <cite>new_label</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ireplace_labels" title="tenpy.linalg.np_conserved.Array.ireplace_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ireplace_labels</span></code></a>(old_labels, new_labels)</p></td>
<td><p>Replace leg label <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> with <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.is_completely_blocked" title="tenpy.linalg.np_conserved.Array.is_completely_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_completely_blocked</span></code></a>()</p></td>
<td><p>Return bool whether all legs are blocked by charge.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="tenpy.linalg.np_conserved.Array.iscale_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscale_axis</span></code></a>(s[, axis])</p></td>
<td><p>Scale with varying values along an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_prefactor" title="tenpy.linalg.np_conserved.Array.iscale_prefactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscale_prefactor</span></code></a>(prefactor)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*=</span> <span class="pre">prefactor</span></code> for scalar <cite>prefactor</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="tenpy.linalg.np_conserved.Array.iset_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iset_leg_labels</span></code></a>(labels)</p></td>
<td><p>Set labels for the different axes/legs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.isort_qdata" title="tenpy.linalg.np_conserved.Array.isort_qdata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isort_qdata</span></code></a>()</p></td>
<td><p>(Lexiographically) sort <code class="docutils literal notranslate"><span class="pre">self._qdata</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iswapaxes" title="tenpy.linalg.np_conserved.Array.iswapaxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iswapaxes</span></code></a>(axis1, axis2)</p></td>
<td><p>Similar as <code class="docutils literal notranslate"><span class="pre">np.swapaxes</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.itranspose" title="tenpy.linalg.np_conserved.Array.itranspose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itranspose</span></code></a>([axes])</p></td>
<td><p>Transpose axes like <cite>np.transpose</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iunary_blockwise" title="tenpy.linalg.np_conserved.Array.iunary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iunary_blockwise</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">f(self)</span></code>, block-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.make_pipe" title="tenpy.linalg.np_conserved.Array.make_pipe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_pipe</span></code></a>(axes, **kwargs)</p></td>
<td><p>Generates a <a class="reference internal" href="tenpy.linalg.charges.LegPipe.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> for specified axes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.matvec" title="tenpy.linalg.np_conserved.Array.matvec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matvec</span></code></a>(other)</p></td>
<td><p>This function is used by the Lanczos algorithm needed for DMRG.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.norm" title="tenpy.linalg.np_conserved.Array.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([ord, convert_to_float])</p></td>
<td><p>Norm of flattened data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.permute" title="tenpy.linalg.np_conserved.Array.permute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute</span></code></a>(perm, axis)</p></td>
<td><p>Apply a permutation in the indices of an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.replace_label" title="tenpy.linalg.np_conserved.Array.replace_label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_label</span></code></a>(old_label, new_label)</p></td>
<td><p>Return a shallow copy with the leg label <cite>old_label</cite> replaced by <cite>new_label</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.replace_labels" title="tenpy.linalg.np_conserved.Array.replace_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_labels</span></code></a>(old_labels, new_labels)</p></td>
<td><p>Return a shallow copy with <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> replaced by <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.scale_axis" title="tenpy.linalg.np_conserved.Array.scale_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_axis</span></code></a>(s[, axis])</p></td>
<td><p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="tenpy.linalg.np_conserved.Array.iscale_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iscale_axis()</span></code></a>, but return a (deep) copy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_legcharge</span></code></a>([sort, bunch])</p></td>
<td><p>Return a copy with one or all legs sorted by charges.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sparse_stats" title="tenpy.linalg.np_conserved.Array.sparse_stats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_stats</span></code></a>()</p></td>
<td><p>Returns a string detailing the sparse statistics</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.split_legs" title="tenpy.linalg.np_conserved.Array.split_legs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_legs</span></code></a>([axes, cutoff])</p></td>
<td><p>Reshape: opposite of combine_legs: split (some) legs which are LegPipes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.squeeze" title="tenpy.linalg.np_conserved.Array.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>([axes])</p></td>
<td><p>Like <code class="docutils literal notranslate"><span class="pre">np.squeeze</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.take_slice" title="tenpy.linalg.np_conserved.Array.take_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take_slice</span></code></a>(indices, axes)</p></td>
<td><p>Return a copy of self fixing <cite>indices</cite> along one or multiple <cite>axes</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.test_sanity" title="tenpy.linalg.np_conserved.Array.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</p></td>
<td><p>Sanity check.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.to_ndarray" title="tenpy.linalg.np_conserved.Array.to_ndarray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_ndarray</span></code></a>()</p></td>
<td><p>Convert self to a dense numpy ndarray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.transpose" title="tenpy.linalg.np_conserved.Array.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>([axes])</p></td>
<td><p>Like <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.itranspose" title="tenpy.linalg.np_conserved.Array.itranspose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itranspose()</span></code></a>, but on a deep copy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.unary_blockwise" title="tenpy.linalg.np_conserved.Array.unary_blockwise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unary_blockwise</span></code></a>(func, *args, **kwargs)</p></td>
<td><p>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self)</span></code>, block-wise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.zeros_like" title="tenpy.linalg.np_conserved.Array.zeros_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros_like</span></code></a>()</p></td>
<td><p>Return a copy of self with only zeros as entries, containing no <cite>_data</cite>.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">deep=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a (deep or shallow) copy of self.</p>
<p><strong>Both</strong> deep and shallow copies will share <code class="docutils literal notranslate"><span class="pre">chinfo</span></code> and the <cite>LegCharges</cite> in <code class="docutils literal notranslate"><span class="pre">legs</span></code>.</p>
<p>In contrast to a deep copy, the shallow copy will also share the tensor entries,
namely the <em>same</em> instances of <code class="docutils literal notranslate"><span class="pre">_qdata</span></code> and <code class="docutils literal notranslate"><span class="pre">_data</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
(and other ‘immutable’ properties like the shape or dtype).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shallow copies are <em>not</em> recommended unless you know the consequences!
See the following examples illustrating some of the pitfalls.</p>
</div>
<p class="rubric">Examples</p>
<p>Be (very!) careful when making non-deep copies: In the following example,
the original <cite>a</cite> is changed if and only if the corresponding block existed in <cite>a</cite> before.
&gt;&gt;&gt; b = a.copy(deep=False)  # shallow copy
&gt;&gt;&gt; b[1, 2] = 4.</p>
<p>Other <cite>inplace</cite> operations might have no effect at all (although we don’t guarantee that):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># has no effect on `b`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">iconj</span><span class="p">()</span>  <span class="c1"># nor does this change `a`</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.from_ndarray_trivial">
<em class="property">classmethod </em><code class="sig-name descname">from_ndarray_trivial</code><span class="sig-paren">(</span><em class="sig-param">data_flat</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_ndarray_trivial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_ndarray_trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a flat numpy ndarray to an Array with trivial charge conservation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data_flat</strong><span class="classifier">array_like</span></dt><dd><p>The data to be converted to a Array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">np.dtype</span></code></span></dt><dd><p>The data type of the array entries. Defaults to dtype of <cite>data_flat</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>An Array with data of data_flat.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.from_ndarray">
<em class="property">classmethod </em><code class="sig-name descname">from_ndarray</code><span class="sig-paren">(</span><em class="sig-param">data_flat</em>, <em class="sig-param">legcharges</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">qtotal=None</em>, <em class="sig-param">cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_ndarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a flat (numpy) ndarray to an Array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data_flat</strong><span class="classifier">array_like</span></dt><dd><p>The flat ndarray which should be converted to a npc <cite>Array</cite>.
The shape has to be compatible with legcharges.</p>
</dd>
<dt><strong>legcharges</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></span></dt><dd><p>The leg charges for each of the legs. The <code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is read out from it.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">np.dtype</span></code></span></dt><dd><p>The data type of the array entries. Defaults to dtype of <cite>data_flat</cite>.</p>
</dd>
<dt><strong>qtotal</strong><span class="classifier">None | charges</span></dt><dd><p>The total charge of the new array.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>Blocks with <code class="docutils literal notranslate"><span class="pre">np.max(np.abs(block))</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code> are considered as zero.
Defaults to <code class="xref py py-data docutils literal notranslate"><span class="pre">QCUTOFF</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>An Array with data of <cite>data_flat</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="tenpy.linalg.np_conserved.detect_qtotal.html#tenpy.linalg.np_conserved.detect_qtotal" title="tenpy.linalg.np_conserved.detect_qtotal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_qtotal</span></code></a></dt><dd><p>used to detect <code class="docutils literal notranslate"><span class="pre">qtotal</span></code> if not given.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.from_func">
<em class="property">classmethod </em><code class="sig-name descname">from_func</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">legcharges</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">qtotal=None</em>, <em class="sig-param">func_args=()</em>, <em class="sig-param">func_kwargs={}</em>, <em class="sig-param">shape_kw=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Array from a numpy func.</p>
<p>This function creates an array and fills the blocks <em>compatible</em> with the charges
using <cite>func</cite>, where <cite>func</cite> is a function returning a <cite>array_like</cite> when given a shape,
e.g. one of <code class="docutils literal notranslate"><span class="pre">np.ones</span></code> or <code class="docutils literal notranslate"><span class="pre">np.random.standard_normal</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>A function-like object which is called to generate the data blocks.
We expect that <cite>func</cite> returns a flat array of the given <cite>shape</cite> convertible to <cite>dtype</cite>.
If no <cite>shape_kw</cite> is given, it is called like <code class="docutils literal notranslate"><span class="pre">func(shape,</span> <span class="pre">*fargs,</span> <span class="pre">**fkwargs)</span></code>,
otherwise as <code class="docutils literal notranslate"><span class="pre">func(*fargs,</span> <span class="pre">`shape_kw`=shape,</span> <span class="pre">**fkwargs)</span></code>.
<cite>shape</cite> is a tuple of int.</p>
</dd>
<dt><strong>legcharges</strong><span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></span></dt><dd><p>The leg charges for each of the legs. The <code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is read out from it.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">None | type | string</span></dt><dd><p>The data type of the output entries. Defaults to np.float64.
Defaults to <cite>None</cite>: obtain it from the return value of the function.
Note that this argument is not given to func, but rather a type conversion
is performed afterwards. You might want to set a <cite>dtype</cite> in <cite>func_kwargs</cite> as well.</p>
</dd>
<dt><strong>qtotal</strong><span class="classifier">None | charges</span></dt><dd><p>The total charge of the new array. Defaults to charge 0.</p>
</dd>
<dt><strong>func_args</strong><span class="classifier">iterable</span></dt><dd><p>Additional arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>func_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>shape_kw</strong><span class="classifier">None | str</span></dt><dd><p>If given, the keyword with which shape is given to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>An Array with blocks filled using <cite>func</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.from_func_square">
<em class="property">classmethod </em><code class="sig-name descname">from_func_square</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">leg</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">func_args=()</em>, <em class="sig-param">func_kwargs={}</em>, <em class="sig-param">shape_kw=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.from_func_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.from_func_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Array from a (numpy) function.</p>
<p>This function creates an array and fills the blocks <em>compatible</em> with the charges
using <cite>func</cite>, where <cite>func</cite> is a function returning a <cite>array_like</cite> when given a shape,
e.g. one of <code class="docutils literal notranslate"><span class="pre">np.ones</span></code> or <code class="docutils literal notranslate"><span class="pre">np.random.standard_normal</span></code> or the functions defined in
<a class="reference internal" href="tenpy.linalg.random_matrix.html#module-tenpy.linalg.random_matrix" title="tenpy.linalg.random_matrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">random_matrix</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>A function-like object which is called to generate the data blocks.
We expect that <cite>func</cite> returns a flat array of the given <cite>shape</cite> convertible to <cite>dtype</cite>.
If no <cite>shape_kw</cite> is given, it is called like <code class="docutils literal notranslate"><span class="pre">func(shape,</span> <span class="pre">*fargs,</span> <span class="pre">**fkwargs)</span></code>,
otherwise as <code class="docutils literal notranslate"><span class="pre">func(*fargs,</span> <span class="pre">`shape_kw`=shape,</span> <span class="pre">**fkwargs)</span></code>.
<cite>shape</cite> is a tuple of int.</p>
</dd>
<dt><strong>leg</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></span></dt><dd><p>The leg charges for the first leg; the second leg is set to <code class="docutils literal notranslate"><span class="pre">leg.conj()</span></code>.
The <code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> is read out from it.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">None | type | string</span></dt><dd><p>The data type of the output entries.
Defaults to <cite>None</cite>: obtain it from the return value of the function.
Note that this argument is not given to func, but rather a type conversion
is performed afterwards. You might want to set a <cite>dtype</cite> in <cite>func_kwargs</cite> as well.</p>
</dd>
<dt><strong>func_args</strong><span class="classifier">iterable</span></dt><dd><p>Additional arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>func_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword arguments given to <cite>func</cite>.</p>
</dd>
<dt><strong>shape_kw</strong><span class="classifier">None | str</span></dt><dd><p>If given, the keyword with which shape is given to <cite>func</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>An Array with blocks filled using <cite>func</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.zeros_like">
<code class="sig-name descname">zeros_like</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.zeros_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self with only zeros as entries, containing no <cite>_data</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.test_sanity">
<code class="sig-name descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of dtype-objects stored.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.stored_blocks">
<em class="property">property </em><code class="sig-name descname">stored_blocks</code><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.stored_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of (non-zero) blocks stored in <code class="xref py py-attr docutils literal notranslate"><span class="pre">_data</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg_index">
<code class="sig-name descname">get_leg_index</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg_index" title="Permalink to this definition">¶</a></dt>
<dd><p>translate a leg-index or leg-label to a leg-index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">int | string</span></dt><dd><p>The leg-index directly or a label (string) set before.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>leg_index</strong><span class="classifier">int</span></dt><dd><p>The index of the label.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_indices" title="tenpy.linalg.np_conserved.Array.get_leg_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_indices</span></code></a></dt><dd><p>calls get_leg_index for a list of labels.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="tenpy.linalg.np_conserved.Array.iset_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iset_leg_labels</span></code></a></dt><dd><p>set the labels of different legs.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg_indices">
<code class="sig-name descname">get_leg_indices</code><span class="sig-paren">(</span><em class="sig-param">labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a list of leg-indices or leg-labels to leg indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">iterable of string/int</span></dt><dd><p>The leg-labels (or directly indices) to be translated in leg-indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>leg_indices</strong><span class="classifier">list of int</span></dt><dd><p>The translated labels.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg_index" title="tenpy.linalg.np_conserved.Array.get_leg_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg_index</span></code></a></dt><dd><p>used to translate each of the single entries.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="tenpy.linalg.np_conserved.Array.iset_leg_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iset_leg_labels</span></code></a></dt><dd><p>set the labels of different legs.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iset_leg_labels">
<code class="sig-name descname">iset_leg_labels</code><span class="sig-paren">(</span><em class="sig-param">labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iset_leg_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iset_leg_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Set labels for the different axes/legs. In place.</p>
<p>Introduction to leg labeling can be found in <a class="reference internal" href="../intro_npc.html"><span class="doc">Introduction to np_conserved</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">iterable (strings | None), len=self.rank</span></dt><dd><p>One label for each of the legs.
An entry can be None for an anonymous leg.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.get_leg" title="tenpy.linalg.np_conserved.Array.get_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_leg</span></code></a></dt><dd><p>translate the labels to indices.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg_labels">
<code class="sig-name descname">get_leg_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of the leg labels, with <cite>None</cite> for anonymous legs.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.has_label">
<code class="sig-name descname">has_label</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.has_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.has_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a given label exists.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.get_leg">
<code class="sig-name descname">get_leg</code><span class="sig-paren">(</span><em class="sig-param">label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.get_leg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.get_leg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">self.legs[self.get_leg_index(label)]</span></code>.</p>
<p>Convenient function returning the leg corresponding to a leg label/index.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ireplace_label">
<code class="sig-name descname">ireplace_label</code><span class="sig-paren">(</span><em class="sig-param">old_label</em>, <em class="sig-param">new_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ireplace_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ireplace_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the leg label <cite>old_label</cite> with <cite>new_label</cite>. In place.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.replace_label">
<code class="sig-name descname">replace_label</code><span class="sig-paren">(</span><em class="sig-param">old_label</em>, <em class="sig-param">new_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.replace_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.replace_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy with the leg label <cite>old_label</cite> replaced by <cite>new_label</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ireplace_labels">
<code class="sig-name descname">ireplace_labels</code><span class="sig-paren">(</span><em class="sig-param">old_labels</em>, <em class="sig-param">new_labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ireplace_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ireplace_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace leg label <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> with <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>. In place.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.replace_labels">
<code class="sig-name descname">replace_labels</code><span class="sig-paren">(</span><em class="sig-param">old_labels</em>, <em class="sig-param">new_labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.replace_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.replace_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy with <code class="docutils literal notranslate"><span class="pre">old_labels[i]</span></code> replaced by <code class="docutils literal notranslate"><span class="pre">new_labels[i]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.idrop_labels">
<code class="sig-name descname">idrop_labels</code><span class="sig-paren">(</span><em class="sig-param">old_labels=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.idrop_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.idrop_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove leg labels from self. In place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>old_labels</strong><span class="classifier">list of str|int</span></dt><dd><p>The leg labels/indices for which the label should be removed.
By default (None), remove all labels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.sparse_stats">
<code class="sig-name descname">sparse_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.sparse_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.sparse_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string detailing the sparse statistics</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.to_ndarray">
<code class="sig-name descname">to_ndarray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.to_ndarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.to_ndarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert self to a dense numpy ndarray.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.take_slice">
<code class="sig-name descname">take_slice</code><span class="sig-paren">(</span><em class="sig-param">indices</em>, <em class="sig-param">axes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.take_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.take_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self fixing <cite>indices</cite> along one or multiple <cite>axes</cite>.</p>
<p>For a rank-4 Array <code class="docutils literal notranslate"><span class="pre">A.take_slice([i,</span> <span class="pre">j],</span> <span class="pre">[1,2])</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">A[:,</span> <span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">:]</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">(iterable of) int</span></dt><dd><p>The (flat) index for each of the legs specified by <cite>axes</cite>.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">(iterable of) str/int</span></dt><dd><p>Leg labels or indices to specify the legs for which the indices are given.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>sliced_self</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of self, equivalent to taking slices with indices inserted in axes.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.add_leg" title="tenpy.linalg.np_conserved.Array.add_leg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_leg</span></code></a></dt><dd><p>opposite action of inserting a new leg.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.add_trivial_leg">
<code class="sig-name descname">add_trivial_leg</code><span class="sig-paren">(</span><em class="sig-param">axis=0</em>, <em class="sig-param">label=None</em>, <em class="sig-param">qconj=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.add_trivial_leg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.add_trivial_leg" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trivial leg (with just one entry) to <cite>self</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>The new leg is inserted before index <cite>axis</cite>.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, use it as label for the new leg.</p>
</dd>
<dt><strong>qconj</strong><span class="classifier">+1 | -1</span></dt><dd><p>The direction of the new leg.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>extended</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A (possibly) <em>shallow</em> copy of self with an additional leg of ind_len 1 and charge 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.add_leg">
<code class="sig-name descname">add_leg</code><span class="sig-paren">(</span><em class="sig-param">leg</em>, <em class="sig-param">i</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.add_leg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.add_leg" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a leg to <cite>self</cite>, setting the current array as slice for a given index.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>leg</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></span></dt><dd><p>The charge data of the leg to be added.</p>
</dd>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Index within the leg for which the data of <cite>self</cite> should be set.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">axis</span></dt><dd><p>The new leg is inserted before this current axis.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str | <code class="docutils literal notranslate"><span class="pre">None</span></code></span></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, use it as label for the new leg.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>extended</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of self with the new <cite>leg</cite> at axis <cite>axis</cite> , such that
<code class="docutils literal notranslate"><span class="pre">extended.take_slice(i,</span> <span class="pre">axis)</span></code> returns a copy of <cite>self</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.take_slice" title="tenpy.linalg.np_conserved.Array.take_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take_slice</span></code></a></dt><dd><p>opposite action reducing the number of legs.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">extra</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.extend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase the dimension of a given axis, filling the values with zeros.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">int | str</span></dt><dd><p>The axis (or axis-label) to be extended.</p>
</dd>
<dt><strong>extra</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code> | int</span></dt><dd><p>By what to extend, i.e. the charges to be appended to the leg of <cite>axis</cite>.
An int stands for extending the length of the array by a single new block of that size
with zero charges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>extended</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of self with the specified axis increased.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.gauge_total_charge">
<code class="sig-name descname">gauge_total_charge</code><span class="sig-paren">(</span><em class="sig-param">axis</em>, <em class="sig-param">newqtotal=None</em>, <em class="sig-param">new_qconj=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.gauge_total_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.gauge_total_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the total charge by adjusting the charge on a certain leg.</p>
<p>The total charge is given by finding a nonzero entry [i1, i2, …] and calculating:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qtotal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chinfo</span><span class="o">.</span><span class="n">make_valid</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">get_charge</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">get_qindex</span><span class="p">(</span><span class="n">qi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">legs</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Thus, the total charge can be changed by redefining (= shifting) the LegCharge
of a single given leg. This is exaclty what this function does.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">int or string</span></dt><dd><p>The new leg (index or label), for which the charge is changed.</p>
</dd>
<dt><strong>newqtotal</strong><span class="classifier">charge values, defaults to 0</span></dt><dd><p>The new total charge.</p>
</dd>
<dt><strong>new_qconj: {+1, -1, None}</strong></dt><dd><p>Whether the new LegCharge points inward (+1) or outward (-1) afterwards.
By default (None) use the previous <code class="docutils literal notranslate"><span class="pre">self.legs[leg].qconj</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>copy</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A shallow copy of self with <code class="docutils literal notranslate"><span class="pre">copy.qtotal</span> <span class="pre">==</span> <span class="pre">newqtotal</span></code> and new <code class="docutils literal notranslate"><span class="pre">copy.legs[leg]</span></code>.
The new leg will be a :class`LegCharge`, even if the old leg was a <code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.add_charge">
<code class="sig-name descname">add_charge</code><span class="sig-paren">(</span><em class="sig-param">add_legs</em>, <em class="sig-param">chinfo=None</em>, <em class="sig-param">qtotal=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.add_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.add_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add charges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>add_legs</strong><span class="classifier">iterable of <code class="xref py py-class docutils literal notranslate"><span class="pre">LegCharge</span></code></span></dt><dd><p>One <cite>LegCharge</cite> for each axis of <cite>self</cite>, to be added to the one in <code class="xref py py-attr docutils literal notranslate"><span class="pre">legs</span></code>.</p>
</dd>
<dt><strong>chargeinfo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></span></dt><dd><p>The ChargeInfo for all charges; create new if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>qtotal</strong><span class="classifier">None | charges</span></dt><dd><p>The total charge with respect to <cite>add_legs</cite>.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, derive it from non-zero entries of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>charges_added</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of <cite>self</cite>, where the LegCharges <cite>add_legs</cite> where added to <cite>self.legs</cite>.
Note that the LegCharges are neither bunched or sorted;
you might want to use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.drop_charge">
<code class="sig-name descname">drop_charge</code><span class="sig-paren">(</span><em class="sig-param">charge=None</em>, <em class="sig-param">chinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.drop_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.drop_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop (one of) the charges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>charge</strong><span class="classifier">int | str</span></dt><dd><p>Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be dropped.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
<dt><strong>chinfo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></span></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> with <cite>charge</cite> dropped; create a new one if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dropped</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of <cite>self</cite>, where the specified <cite>charge</cite> has been removed.
Note that the LegCharges are neither bunched or sorted;
you might want to use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.change_charge">
<code class="sig-name descname">change_charge</code><span class="sig-paren">(</span><em class="sig-param">charge</em>, <em class="sig-param">new_qmod</em>, <em class="sig-param">new_name=''</em>, <em class="sig-param">chinfo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.change_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.change_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the <cite>qmod</cite> of one charge in <cite>chinfo</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>charge</strong><span class="classifier">int | str</span></dt><dd><p>Number or <cite>name</cite> of the charge (within <cite>chinfo</cite>) which is to be changed.
<code class="docutils literal notranslate"><span class="pre">None</span></code> means dropping all charges.</p>
</dd>
<dt><strong>new_qmod</strong><span class="classifier">int</span></dt><dd><p>The new <cite>qmod</cite> to be set.</p>
</dd>
<dt><strong>new_name</strong><span class="classifier">str</span></dt><dd><p>The new name of the charge.</p>
</dd>
<dt><strong>chinfo</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code></span></dt><dd><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ChargeInfo</span></code> with <cite>qmod</cite> of <cite>charge</cite> changed; create a new one if <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>changed</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of <cite>self</cite>, where the <cite>qmod</cite> of the specified <cite>charge</cite> has been changed.
Note that the LegCharges are neither bunched or sorted;
you might want to use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.is_completely_blocked">
<code class="sig-name descname">is_completely_blocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.is_completely_blocked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.is_completely_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return bool whether all legs are blocked by charge.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.sort_legcharge">
<code class="sig-name descname">sort_legcharge</code><span class="sig-paren">(</span><em class="sig-param">sort=True</em>, <em class="sig-param">bunch=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.sort_legcharge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy with one or all legs sorted by charges.</p>
<p>Sort/bunch one or multiple of the LegCharges.
Legs which are sorted <em>and</em> bunched are guaranteed to be blocked by charge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sort</strong><span class="classifier">True | False | list of {True, False, perm}</span></dt><dd><p>A single bool holds for all legs, default=True.
Else, <cite>sort</cite> should contain one entry for each leg, with a bool for sort/don’t sort,
or a 1D array perm for a given permuation to apply to a leg.</p>
</dd>
<dt><strong>bunch</strong><span class="classifier">True | False | list of {True, False}</span></dt><dd><p>A single bool holds for all legs, default=True.
Whether or not to bunch at each leg, i.e. combine contiguous blocks with equal charges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">tuple of 1D arrays</span></dt><dd><p>The permutation applied to each of the legs, such that
<code class="docutils literal notranslate"><span class="pre">cp.to_ndarray()</span> <span class="pre">=</span> <span class="pre">self.to_ndarray()[np.ix_(*perm)]</span></code>.</p>
</dd>
<dt><strong>result</strong><span class="classifier">Array</span></dt><dd><p>A shallow copy of self, with legs sorted/bunched.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.isort_qdata">
<code class="sig-name descname">isort_qdata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.isort_qdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.isort_qdata" title="Permalink to this definition">¶</a></dt>
<dd><p>(Lexiographically) sort <code class="docutils literal notranslate"><span class="pre">self._qdata</span></code>. In place.</p>
<p>Lexsort <code class="docutils literal notranslate"><span class="pre">self._qdata</span></code> and <code class="docutils literal notranslate"><span class="pre">self._data</span></code> and set <code class="docutils literal notranslate"><span class="pre">self._qdata_sorted</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.make_pipe">
<code class="sig-name descname">make_pipe</code><span class="sig-paren">(</span><em class="sig-param">axes</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.make_pipe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.make_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a <a class="reference internal" href="tenpy.linalg.charges.LegPipe.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a> for specified axes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">iterable of str|int</span></dt><dd><p>The leg labels for the axes which should be combined. Order matters!</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Additional keyword arguments given to <a class="reference internal" href="tenpy.linalg.charges.LegPipe.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>pipe</strong><span class="classifier"><a class="reference internal" href="tenpy.linalg.charges.LegPipe.html#tenpy.linalg.charges.LegPipe" title="tenpy.linalg.charges.LegPipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code></a></span></dt><dd><p>A pipe of the legs specified by axes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.combine_legs">
<code class="sig-name descname">combine_legs</code><span class="sig-paren">(</span><em class="sig-param">combine_legs</em>, <em class="sig-param">new_axes=None</em>, <em class="sig-param">pipes=None</em>, <em class="sig-param">qconj=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.combine_legs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape: combine multiple legs into multiple pipes. If necessary, transpose before.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>combine_legs</strong><span class="classifier">(iterable of) iterable of {str|int}</span></dt><dd><p>Bundles of leg indices or labels, which should be combined into a new output pipes.
If multiple pipes should be created, use a list fore each new pipe.</p>
</dd>
<dt><strong>new_axes</strong><span class="classifier">None | (iterable of) int</span></dt><dd><p>The leg-indices, at which the combined legs should appear in the resulting array.
Default: for each pipe the position of its first pipe in the original array,
(taking into account that some axes are ‘removed’ by combining).
Thus no transposition is perfomed if <cite>combine_legs</cite> contains only contiguous ranges.</p>
</dd>
<dt><strong>pipes</strong><span class="classifier">None | (iterable of) {<code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipes</span></code> | None}</span></dt><dd><p>Optional: provide one or multiple of the resulting LegPipes to avoid overhead of
computing new leg pipes for the same legs multiple times.
The LegPipes are conjugated, if that is necessary for compatibility with the legs.</p>
</dd>
<dt><strong>qconj</strong><span class="classifier">(iterable of) {+1, -1}</span></dt><dd><p>Specify whether new created pipes point inward or outward. Defaults to +1.
Ignored for given <cite>pipes</cite>, which are not newly calculated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>reshaped</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of self, whith some legs combined into pipes as specified by the arguments.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.split_legs" title="tenpy.linalg.np_conserved.Array.split_legs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_legs</span></code></a></dt><dd><p>inverse reshaping splitting LegPipes.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Labels are inherited from self.
New pipe labels are generated as <code class="docutils literal notranslate"><span class="pre">'('</span> <span class="pre">+</span> <span class="pre">'.'.join(*leglabels)</span> <span class="pre">+</span> <span class="pre">')'</span></code>.
For these new labels, previously unlabeled legs are replaced by <code class="docutils literal notranslate"><span class="pre">'?#'</span></code>,
where <code class="docutils literal notranslate"><span class="pre">#</span></code> is the leg-index in the original tensor <cite>self</cite>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oldarray</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">oldarray</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">qconj</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># only single output pipe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;(b.c)&#39;, &#39;d&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
<p>Indices of <cite>combine_legs</cite> refer to the original array.
If transposing is necessary, it is performed automatically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">oldarray</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">qconj</span><span class="o">=</span><span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># two output pipes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;(a.d)&#39;, &#39;c&#39;, &#39;(e.b)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">oldarray</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]],</span> <span class="n">new_axes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="n">pipes</span><span class="o">=</span><span class="p">[</span><span class="n">c2</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c2</span><span class="o">.</span><span class="n">legs</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;b&#39;, &#39;(e.b)&#39;, &#39;(a.d)&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.split_legs">
<code class="sig-name descname">split_legs</code><span class="sig-paren">(</span><em class="sig-param">axes=None</em>, <em class="sig-param">cutoff=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.split_legs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.split_legs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape: opposite of combine_legs: split (some) legs which are LegPipes.</p>
<p>Reverts <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_legs()</span></code></a> (except a possibly performed <cite>transpose</cite>).
The splited legs are replacing the LegPipes at their position, see the examples below.
Labels are split reverting what was done in <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_legs()</span></code></a>.
‘?#’ labels are replaced with <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">(iterable of) int|str</span></dt><dd><p>Leg labels or indices determining the axes to split.
The corresponding entries in self.legs must be <code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code> instances.
Defaults to all legs, which are <code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code> instances.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>Splitted data blocks with <code class="docutils literal notranslate"><span class="pre">np.max(np.abs(block))</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code> are considered as zero.
Defaults to 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>reshaped</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of self where the specified legs are splitted.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.combine_legs" title="tenpy.linalg.np_conserved.Array.combine_legs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_legs</span></code></a></dt><dd><p>this is reversed by split_legs.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Given a rank-5 Array <cite>old_array</cite>, you can combine it and split it again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_array</span><span class="o">.</span><span class="n">iset_leg_labels</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comb_array</span> <span class="o">=</span> <span class="n">old_array</span><span class="o">.</span><span class="n">combine_legs</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comb_array</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;(a.d)&#39;, &#39;b&#39;, &#39;(c.e)&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_array</span> <span class="o">=</span> <span class="n">comb_array</span><span class="o">.</span><span class="n">split_legs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_array</span><span class="o">.</span><span class="n">get_leg_labels</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.as_completely_blocked">
<code class="sig-name descname">as_completely_blocked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.as_completely_blocked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.as_completely_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a version of self which is completely blocked by charges.</p>
<p>Functions like <a class="reference internal" href="tenpy.linalg.np_conserved.svd.html#tenpy.linalg.np_conserved.svd" title="tenpy.linalg.np_conserved.svd"><code class="xref py py-func docutils literal notranslate"><span class="pre">svd()</span></code></a> or <a class="reference internal" href="tenpy.linalg.np_conserved.eigh.html#tenpy.linalg.np_conserved.eigh" title="tenpy.linalg.np_conserved.eigh"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigh()</span></code></a> require a complete blocking by charges.
This can be achieved by encapsulating each leg which is not completely blocked into a
<code class="xref py py-class docutils literal notranslate"><span class="pre">LegPipe</span></code> (containing only that single leg). The LegPipe will then contain all
necessary information to revert the blocking.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>encapsulated_axes</strong><span class="classifier">list of int</span></dt><dd><p>The leg indices which have been encapsulated into Pipes.</p>
</dd>
<dt><strong>blocked_self</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Self (if <code class="docutils literal notranslate"><span class="pre">len(encapsulated_axes)</span> <span class="pre">=</span> <span class="pre">0</span></code>) or a copy of self,
which is completely blocked.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">np.squeeze</span></code>.</p>
<p>If a squeezed leg has non-zero charge, this charge is added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">qtotal</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">None | (iterable of) {int|str}</span></dt><dd><p>Labels or indices of the legs which should be ‘squeezed’, i.e. the legs removed.
The corresponding legs must be trivial, i.e., have <cite>ind_len</cite> 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>squeezed</strong><span class="classifier">:class:Array | scalar</span></dt><dd><p>A scalar of <code class="docutils literal notranslate"><span class="pre">self.dtype</span></code>, if all axes were squeezed.
Else a copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with reduced <code class="docutils literal notranslate"><span class="pre">rank</span></code> as specified by <cite>axes</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param">dtype</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.astype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy with new dtype, upcasting all blocks in <code class="docutils literal notranslate"><span class="pre">_data</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">convertible to a np.dtype</span></dt><dd><p>The new data type.
If None, deduce the new dtype as common type of <code class="docutils literal notranslate"><span class="pre">self._data</span></code>.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool</span></dt><dd><p>Whether to make a copy of the blocks even if the type didn’t change.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>copy</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Deep copy of self with new dtype.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ipurge_zeros">
<code class="sig-name descname">ipurge_zeros</code><span class="sig-paren">(</span><em class="sig-param">cutoff=2.220446049250313e-15</em>, <em class="sig-param">norm_order=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ipurge_zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ipurge_zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">self._data</span></code> blocks with <em>norm</em> less than cutoff. In place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cutoff</strong><span class="classifier">float</span></dt><dd><p>Blocks with norm &lt;= <cite>cutoff</cite> are removed. defaults to <code class="xref py py-data docutils literal notranslate"><span class="pre">QCUTOFF</span></code>.</p>
</dd>
<dt><strong>norm_order :</strong></dt><dd><p>A valid <cite>ord</cite> argument for <cite>np.linalg.norm</cite>.
Default <code class="docutils literal notranslate"><span class="pre">None</span></code> gives the Frobenius norm/2-norm for matrices/everything else.
Note that this differs from other methods, e.g. <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.from_ndarray" title="tenpy.linalg.np_conserved.Array.from_ndarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_ndarray()</span></code></a>,
which use the maximum norm.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iproject">
<code class="sig-name descname">iproject</code><span class="sig-paren">(</span><em class="sig-param">mask</em>, <em class="sig-param">axes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iproject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iproject" title="Permalink to this definition">¶</a></dt>
<dd><p>Applying masks to one or multiple axes. In place.</p>
<p>This function is similar as <cite>np.compress</cite> with boolean arrays
For each specified axis, a boolean 1D array <cite>mask</cite> can be given,
which chooses the indices to keep.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Although it is possible to use an 1D int array as a mask, the order is ignored!
If you need to permute an axis, use <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.permute" title="tenpy.linalg.np_conserved.Array.permute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permute()</span></code></a> or <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_legcharge()</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">(list of) 1D array(bool|int)</span></dt><dd><p>For each axis specified by <cite>axes</cite> a mask, which indices of the axes should be kept.
If <cite>mask</cite> is a bool array, keep the indices where <cite>mask</cite> is True.
If <cite>mask</cite> is an int array, keep the indices listed in the mask, <em>ignoring</em> the
order or multiplicity.</p>
</dd>
<dt><strong>axes</strong><span class="classifier">(list of) int | string</span></dt><dd><p>The <cite>i`th entry in this list specifies the axis for the `i`th entry of `mask</cite>,
either as an int, or with a leg label.
If axes is just a single int/string, specify just a single mask.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>map_qind</strong><span class="classifier">list of 1D arrays</span></dt><dd><p>The mapping of qindices for each of the specified axes.</p>
</dd>
<dt><strong>block_masks: list of lists of 1D bool arrays</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">block_masks[a][qind]</span></code> is a boolen mask which indices to keep
in block <code class="docutils literal notranslate"><span class="pre">qindex</span></code> of <code class="docutils literal notranslate"><span class="pre">axes[a]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.permute">
<code class="sig-name descname">permute</code><span class="sig-paren">(</span><em class="sig-param">perm</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.permute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a permutation in the indices of an axis.</p>
<p>Similar as np.take with a 1D array.
Roughly equivalent to <code class="docutils literal notranslate"><span class="pre">res[:,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">self[perm,</span> <span class="pre">...]</span></code> for the corresponding <cite>axis</cite>.
Note: This function is quite slow, and usually not needed!</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">array_like 1D int</span></dt><dd><p>The permutation which should be applied to the leg given by <cite>axis</cite>.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">str | int</span></dt><dd><p>A leg label or index specifying on which leg to take the permutation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>res</strong><span class="classifier"><a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>A copy of self with leg <cite>axis</cite> permuted, such that
<code class="docutils literal notranslate"><span class="pre">res[i,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">self[perm[i],</span> <span class="pre">...]</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span></code> along <cite>axis</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.sort_legcharge" title="tenpy.linalg.np_conserved.Array.sort_legcharge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_legcharge</span></code></a></dt><dd><p>can also be used to perform a general permutation. Preferable, since it is faster for permutations which don’t mix charge blocks.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.itranspose">
<code class="sig-name descname">itranspose</code><span class="sig-paren">(</span><em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.itranspose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.itranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose axes like <cite>np.transpose</cite>. In place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes: iterable (int|string), len ``rank`` | None</strong></dt><dd><p>The new order of the axes. By default (None), reverse axes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param">axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.itranspose" title="tenpy.linalg.np_conserved.Array.itranspose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itranspose()</span></code></a>, but on a deep copy.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iswapaxes">
<code class="sig-name descname">iswapaxes</code><span class="sig-paren">(</span><em class="sig-param">axis1</em>, <em class="sig-param">axis2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iswapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iswapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar as <code class="docutils literal notranslate"><span class="pre">np.swapaxes</span></code>. In place.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iscale_axis">
<code class="sig-name descname">iscale_axis</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iscale_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale with varying values along an axis. In place.</p>
<p>Rescale to <code class="docutils literal notranslate"><span class="pre">new_self[i1,</span> <span class="pre">...,</span> <span class="pre">i_axis,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">s[i_axis]</span> <span class="pre">*</span> <span class="pre">self[i1,</span> <span class="pre">...,</span> <span class="pre">i_axis,</span> <span class="pre">...]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">1D array, len=self.shape[axis]</span></dt><dd><p>The vector with which the axis should be scaled.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">str|int</span></dt><dd><p>The leg label or index for the axis which should be scaled.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iproject" title="tenpy.linalg.np_conserved.Array.iproject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iproject</span></code></a></dt><dd><p>can be used to discard indices for which s is zero.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.scale_axis">
<code class="sig-name descname">scale_axis</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.scale_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.scale_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iscale_axis" title="tenpy.linalg.np_conserved.Array.iscale_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iscale_axis()</span></code></a>, but return a (deep) copy.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iunary_blockwise">
<code class="sig-name descname">iunary_blockwise</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iunary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iunary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">f(self)</span></code>, block-wise. In place.</p>
<p>Applies an unary function <cite>func</cite> to the non-zero blocks in <code class="docutils literal notranslate"><span class="pre">self._data</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumes implicitly that <code class="docutils literal notranslate"><span class="pre">func(np.zeros(...),</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> gives 0,
since we don’t let <cite>func</cite> act on zero blocks!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>A function acting on flat arrays, returning flat arrays.
It is called like <code class="docutils literal notranslate"><span class="pre">new_block</span> <span class="pre">=</span> <span class="pre">func(block,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
</dd>
<dt><strong>*args :</strong></dt><dd><p>Additional arguments given to function <em>after</em> the block.</p>
</dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Keyword arguments given to the function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">iunaray_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>  <span class="c1"># get real part</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">iunaray_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">)</span>  <span class="c1"># same data as a.iconj(), but doesn&#39;t charge conjugate.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.unary_blockwise">
<code class="sig-name descname">unary_blockwise</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.unary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.unary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self)</span></code>, block-wise. Copies.</p>
<p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.iunary_blockwise" title="tenpy.linalg.np_conserved.Array.iunary_blockwise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iunary_blockwise()</span></code></a>, but makes a <strong>shallow</strong> copy first.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iconj">
<code class="sig-name descname">iconj</code><span class="sig-paren">(</span><em class="sig-param">complex_conj=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iconj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iconj" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraper around <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.conj()</span></code> with <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.conj">
<code class="sig-name descname">conj</code><span class="sig-paren">(</span><em class="sig-param">complex_conj=True</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate: complex conjugate data, conjugate charge data.</p>
<p>Conjugate all legs, set negative qtotal.</p>
<p>Labeling: takes ‘a’ -&gt; ‘a*’, ‘a*’-&gt; ‘a’ and
‘(a,(b*,c))’ -&gt; ‘(a*, (b, c*))’</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>complex_conj</strong><span class="classifier">bool</span></dt><dd><p>Whether the data should be complex conjugated.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>Whether to apply changes to <cite>self</cite>, or to return a <em>deep</em> copy.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.complex_conj">
<code class="sig-name descname">complex_conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.complex_conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.complex_conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy which is complex conjugated <em>without</em> conjugating the charge data.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">ord=None</em>, <em class="sig-param">convert_to_float=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of flattened data.</p>
<p>See <a class="reference internal" href="tenpy.linalg.np_conserved.norm.html#tenpy.linalg.np_conserved.norm" title="tenpy.linalg.np_conserved.norm"><code class="xref py py-func docutils literal notranslate"><span class="pre">norm()</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.ibinary_blockwise">
<code class="sig-name descname">ibinary_blockwise</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.ibinary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.ibinary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">=</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise. In place.</p>
<p>Applies a binary function ‘block-wise’ to the non-zero blocks of
<code class="docutils literal notranslate"><span class="pre">self._data</span></code> and <code class="docutils literal notranslate"><span class="pre">other._data</span></code>, storing result in place.
Assumes that <cite>other</cite> is an <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> as well, with the same shape
and compatible legs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assumes implicitly that
<code class="docutils literal notranslate"><span class="pre">func(np.zeros(...),</span> <span class="pre">np.zeros(...),</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> gives 0,
since we don’t let <cite>func</cite> act on zero blocks!</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># equivalent to ``a += b``, if ``b`` is an `Array`.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ibinary_blockwise</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># overwrites ``a`` to ``a = max(a, b)``</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.binary_blockwise">
<code class="sig-name descname">binary_blockwise</code><span class="sig-paren">(</span><em class="sig-param">func</em>, <em class="sig-param">other</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.binary_blockwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.binary_blockwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Roughly <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">func(self,</span> <span class="pre">other)</span></code>, block-wise. Copies.</p>
<p>Same as <a class="reference internal" href="#tenpy.linalg.np_conserved.Array.ibinary_blockwise" title="tenpy.linalg.np_conserved.Array.ibinary_blockwise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ibinary_blockwise()</span></code></a>, but makes a <strong>shallow</strong> copy first.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.matvec">
<code class="sig-name descname">matvec</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.matvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.matvec" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used by the Lanczos algorithm needed for DMRG.</p>
<p>It is supposed to calculate the matrix - vector - product
for a rank-2 matrix <code class="docutils literal notranslate"><span class="pre">self</span></code> and a rank-1 vector <cite>other</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iadd_prefactor_other">
<code class="sig-name descname">iadd_prefactor_other</code><span class="sig-paren">(</span><em class="sig-param">prefactor</em>, <em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iadd_prefactor_other"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iadd_prefactor_other" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">+=</span> <span class="pre">prefactor</span> <span class="pre">*</span> <span class="pre">other</span></code> for scalar <cite>prefactor</cite> and <a class="reference internal" href="#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a> <cite>other</cite>.</p>
<p>Note that we allow the type of <cite>self</cite> to change if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.linalg.np_conserved.Array.iscale_prefactor">
<code class="sig-name descname">iscale_prefactor</code><span class="sig-paren">(</span><em class="sig-param">prefactor</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/linalg/np_conserved.html#Array.iscale_prefactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.linalg.np_conserved.Array.iscale_prefactor" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">*=</span> <span class="pre">prefactor</span></code> for scalar <cite>prefactor</cite>.</p>
<p>Note that we allow the type of <cite>self</cite> to change if necessary.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.linalg.np_conserved.html"
                        title="previous chapter">np_conserved</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.linalg.np_conserved.concatenate.html"
                        title="next chapter">concatenate</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference.html">Tenpy Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tenpy.algorithms.html">algorithms</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.linalg.html">linalg</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.linalg.np_conserved.html">np_conserved</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.charges.html">charges</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.svd_robust.html">svd_robust</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.random_matrix.html">random_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.sparse.html">sparse</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.lanczos.html">lanczos</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.models.html">models</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.networks.html">networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.tools.html">tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.version.html">version</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.np_conserved.concatenate.html" title="concatenate"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.linalg.np_conserved.html" title="np_conserved"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.linalg.html" >linalg</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="tenpy.linalg.np_conserved.html" >np_conserved</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Sep 23, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>