
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tenpy.models.model module &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="tenpy.models.spins module" href="tenpy.models.spins.html" />
    <link rel="prev" title="tenpy.models.lattice module" href="tenpy.models.lattice.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.models.spins.html" title="tenpy.models.spins module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.models.lattice.html" title="tenpy.models.lattice module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.models.html" accesskey="U">tenpy.models package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tenpy.models.model">
<span id="tenpy-models-model-module"></span><h1>tenpy.models.model module<a class="headerlink" href="#module-tenpy.models.model" title="Permalink to this headline">¶</a></h1>
<p>This module contains some base classes for models.</p>
<p>A ‘model’ is supposed to represent a Hamiltonian in a generalized way.
The <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a> specifies the geometry and
underlying Hilbert space, and is thus common to all models.
It is needed to intialize the common base class <a class="reference internal" href="#tenpy.models.model.Model" title="tenpy.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> of all models.</p>
<p>Different algorithms require different representations of the Hamiltonian.
For example for DMRG, the Hamiltonian needs to be given as an MPO,
while TEBD needs the Hamiltonian to be represented by ‘nearest neighbor’ bond terms.
This module contains the base classes defining these possible representations,
namley the <a class="reference internal" href="#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPOModel</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeigborModel</span></code>.</p>
<p>A particular model like the <code class="xref py py-class docutils literal notranslate"><span class="pre">XXZ_chain</span></code> should then
yet another class derived from these classes. In it’s __init__, it needs to explicitly call
the <code class="docutils literal notranslate"><span class="pre">MPOModel.__init__(self,</span> <span class="pre">lattice,</span> <span class="pre">H_MPO)</span></code>, providing an MPO representation of H,
and also the <code class="docutils literal notranslate"><span class="pre">NearestNeigborModel.__init__(self,</span> <span class="pre">lattice,</span> <span class="pre">H_bond)</span></code>,
providing a representation of H by bond terms <cite>H_bond</cite>.</p>
<p>The <a class="reference internal" href="#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> is the attempt to generalize the representation of <cite>H</cite>
by explicitly specifying the couplings in a general way, and providing functionality
for converting them into <cite>H_MPO</cite> and <cite>H_bond</cite>.
This allows to quickly generate new model classes for a very broad class of Hamiltonians.</p>
<p>For simplicity, the <a class="reference internal" href="#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> is limited to interactions involving only two sites.
Yet, we also provide the <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel" title="tenpy.models.model.MultiCouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCouplingModel</span></code></a> to generate Models for Hamiltonians
involving couplings between multiple sites.</p>
<p>The <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel" title="tenpy.models.model.CouplingMPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingMPOModel</span></code></a> aims at structuring the initialization for most models is used
as base class in (most of) the predefined models in TeNPy.</p>
<p>See also the introduction in <a class="reference internal" href="../intro_model.html"><span class="doc">Introduction to models</span></a>.</p>
<dl class="class">
<dt id="tenpy.models.model.Model">
<em class="property">class </em><code class="descclassname">tenpy.models.model.</code><code class="descname">Model</code><span class="sig-paren">(</span><em>lattice</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#Model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Base class for all models.</p>
<p>The common base to all models is the underlying Hilbert space and geometry, specified by a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>lattice</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></span></dt>
<dd><p class="first last">The lattice defining the geometry and the local Hilbert space(s).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lat</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></span></dt>
<dd><p class="first last">The lattice defining the geometry and the local Hilbert space(s).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.Model.group_sites" title="tenpy.models.model.Model.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.Model.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#Model.group_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.Model.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.models.model.NearestNeighborModel">
<em class="property">class </em><code class="descclassname">tenpy.models.model.</code><code class="descname">NearestNeighborModel</code><span class="sig-paren">(</span><em>lattice</em>, <em>H_bond</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#NearestNeighborModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.NearestNeighborModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tenpy.models.model.Model" title="tenpy.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.Model</span></code></a></p>
<p>Base class for a model of nearest neigbor interactions w.r.t. the MPS index.</p>
<p>In this class, the Hamiltonian <span class="math notranslate nohighlight">\(H = \sum_{i} H_{i,i+1}\)</span> is represented by
“bond terms” <span class="math notranslate nohighlight">\(H_{i,i+1}\)</span> acting only on two neighboring sites <cite>i</cite> and <cite>i+1</cite>,
where <cite>i</cite> is an integer.
Instances of this class are suitable for <a class="reference internal" href="tenpy.algorithms.tebd.html#module-tenpy.algorithms.tebd" title="tenpy.algorithms.tebd"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tebd</span></code></a>.</p>
<p>Note that the “nearest-neighbor” in the name referst to the MPS index, not the lattice.
In short, this works only for 1-dimensional (1D) nearest-neighbor models:
A 2D lattice is internally mapped to a 1D MPS “snake”, and even a nearest-neighbor coupling
in 2D becomes long-range in the MPS chain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>lattice</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.model.lattice.Lattice</span></code></span></dt>
<dd><p class="first last">The lattice defining the geometry and the local Hilbert space(s).</p>
</dd>
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">The Hamiltonian rewritten as <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">H_bond[i]</span></code> for MPS indices <code class="docutils literal notranslate"><span class="pre">i</span></code>.
<code class="docutils literal notranslate"><span class="pre">H_bond[i]</span></code> acts on sites <code class="docutils literal notranslate"><span class="pre">(i-1,</span> <span class="pre">i)</span></code>; we require <code class="docutils literal notranslate"><span class="pre">len(H_bond)</span> <span class="pre">==</span> <span class="pre">lat.N_sites</span></code>.
Legs of each <code class="docutils literal notranslate"><span class="pre">H_bond[i]</span></code> are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">npc.Array</span></code></span></dt>
<dd><p class="first last">The Hamiltonian rewritten as <code class="docutils literal notranslate"><span class="pre">sum_i</span> <span class="pre">H_bond[i]</span></code> for MPS indices <code class="docutils literal notranslate"><span class="pre">i</span></code>.
<code class="docutils literal notranslate"><span class="pre">H_bond[i]</span></code> acts on sites <code class="docutils literal notranslate"><span class="pre">(i-1,</span> <span class="pre">i)</span></code>.
Legs of each <code class="docutils literal notranslate"><span class="pre">H_bond[i]</span></code> are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.NearestNeighborModel.bond_energies" title="tenpy.models.model.NearestNeighborModel.bond_energies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_energies</span></code></a>(psi)</td>
<td>Calculate bond energies &lt;psi|H_bond|psi&gt;.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.NearestNeighborModel.calc_H_MPO_from_bond" title="tenpy.models.model.NearestNeighborModel.calc_H_MPO_from_bond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_MPO_from_bond</span></code></a>([tol_zero])</td>
<td>Calculate the MPO Hamiltonian from the bond Hamiltonian.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.NearestNeighborModel.group_sites" title="tenpy.models.model.NearestNeighborModel.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.NearestNeighborModel.trivial_like_NNModel" title="tenpy.models.model.NearestNeighborModel.trivial_like_NNModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trivial_like_NNModel</span></code></a>()</td>
<td>Return a NearestNeighborModel with same lattice, but trivial (H=0) bonds.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>test_sanity</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.NearestNeighborModel.bond_energies">
<code class="descname">bond_energies</code><span class="sig-paren">(</span><em>psi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#NearestNeighborModel.bond_energies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.NearestNeighborModel.bond_energies" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bond energies &lt;psi|H_bond|psi&gt;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>psi</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mps.html#tenpy.networks.mps.MPS" title="tenpy.networks.mps.MPS"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPS</span></code></a></span></dt>
<dd><p class="first last">The MPS for which the bond energies should be calculated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>E_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span></dt>
<dd><p class="first last">List of bond energies: for finite bc, <code class="docutils literal notranslate"><span class="pre">E_Bond[i]</span></code> is the energy of bond <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">i+1</span></code>.
(i.e. we omit bond 0 between sites L-1 and 0);
for infinite bc <code class="docutils literal notranslate"><span class="pre">E_bond[i]</span></code> is the energy of bond <code class="docutils literal notranslate"><span class="pre">i-1,</span> <span class="pre">i</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.NearestNeighborModel.calc_H_MPO_from_bond">
<code class="descname">calc_H_MPO_from_bond</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#NearestNeighborModel.calc_H_MPO_from_bond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.NearestNeighborModel.calc_H_MPO_from_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the MPO Hamiltonian from the bond Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Arrays with norm &lt; <cite>tol_zero</cite> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.NearestNeighborModel.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#NearestNeighborModel.group_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.NearestNeighborModel.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.NearestNeighborModel.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#NearestNeighborModel.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.NearestNeighborModel.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tenpy.models.model.NearestNeighborModel.trivial_like_NNModel">
<code class="descname">trivial_like_NNModel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#NearestNeighborModel.trivial_like_NNModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.NearestNeighborModel.trivial_like_NNModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a NearestNeighborModel with same lattice, but trivial (H=0) bonds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.models.model.MPOModel">
<em class="property">class </em><code class="descclassname">tenpy.models.model.</code><code class="descname">MPOModel</code><span class="sig-paren">(</span><em>lattice</em>, <em>H_MPO</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MPOModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MPOModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tenpy.models.model.Model" title="tenpy.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.Model</span></code></a></p>
<p>Base class for a model with an MPO representation of the Hamiltonian.</p>
<p>In this class, the Hamiltonian gets represented by an <a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a>.
Thus, instances of this class are suitable for MPO-based algorithms like DMRG
<a class="reference internal" href="tenpy.algorithms.dmrg.html#module-tenpy.algorithms.dmrg" title="tenpy.algorithms.dmrg"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dmrg</span></code></a> and MPO time evolution.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">implement MPO for time evolution…</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">The Hamiltonian rewritten as an MPO.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.networks.mpo.MPO</span></code></a></span></dt>
<dd><p class="first last">MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MPOModel.calc_H_bond_from_MPO" title="tenpy.models.model.MPOModel.calc_H_bond_from_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond_from_MPO</span></code></a>([tol_zero])</td>
<td>Calculate the bond Hamiltonian from the MPO Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MPOModel.group_sites" title="tenpy.models.model.MPOModel.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>test_sanity</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.MPOModel.calc_H_bond_from_MPO">
<code class="descname">calc_H_bond_from_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MPOModel.calc_H_bond_from_MPO"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MPOModel.calc_H_bond_from_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the bond Hamiltonian from the MPO Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Arrays with norm &lt; <cite>tol_zero</cite> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <a class="reference internal" href="#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MPOModel.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MPOModel.group_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MPOModel.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MPOModel.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MPOModel.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MPOModel.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.models.model.CouplingModel">
<em class="property">class </em><code class="descclassname">tenpy.models.model.</code><code class="descname">CouplingModel</code><span class="sig-paren">(</span><em>lattice</em>, <em>bc_coupling=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tenpy.models.model.Model" title="tenpy.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.Model</span></code></a></p>
<p>Base class for a general model of a Hamiltonian consisting of two-site couplings.</p>
<p>In this class, the terms of the Hamiltonian are specified explicitly as onsite or coupling
terms.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 0.4.0: </span><cite>bc_coupling</cite> will be removed in 1.0.0. To specify the full geometry in the lattice,
use the <cite>bc</cite> parameter of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>lattice</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></span></dt>
<dd><p class="first last">The lattice defining the geometry and the local Hilbert space(s).</p>
</dd>
<dt><strong>bc_coupling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) {<code class="docutils literal notranslate"><span class="pre">'open'</span></code> | <code class="docutils literal notranslate"><span class="pre">'periodic'</span></code> | <code class="docutils literal notranslate"><span class="pre">int</span></code>}</span></dt>
<dd><p class="first last">Boundary conditions of the couplings in each direction of the lattice. Defines how the
couplings are added in <a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>. A single string holds for all directions.
An integer <cite>shift</cite> means that we have periodic boundary conditions along this direction,
but shift/tilt by <code class="docutils literal notranslate"><span class="pre">-shift*lattice.basis[0]</span></code> (~cylinder axis for <code class="docutils literal notranslate"><span class="pre">bc_MPS='infinite'</span></code>)
when going around the boundary along this direction.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>onsite_terms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of dict</span></dt>
<dd><p class="first last">Filled by <a class="reference internal" href="#tenpy.models.model.CouplingModel.add_onsite" title="tenpy.models.model.CouplingModel.add_onsite"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_onsite()</span></code></a>.
For each MPS index <cite>i</cite> a dictionary <code class="docutils literal notranslate"><span class="pre">{'opname':</span> <span class="pre">strength}</span></code> defining the onsite terms.</p>
</dd>
<dt><strong>coupling_terms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict of dict</span></dt>
<dd><p class="first last">Filled by <a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.
Nested dictionaries of the form
<code class="docutils literal notranslate"><span class="pre">{i:</span> <span class="pre">{('opname_i',</span> <span class="pre">'opname_string'):</span> <span class="pre">{j:</span> <span class="pre">{'opname_j':</span> <span class="pre">strength}}}}</span></code>.
Note that always <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, but entries with <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">&gt;=</span> <span class="pre">lat.N_sites</span></code> are allowed for
<code class="docutils literal notranslate"><span class="pre">lat.bc_MPS</span> <span class="pre">==</span> <span class="pre">'infinite'</span></code>, in which case they indicate couplings between different
iMPS unit cells.</p>
</dd>
<dt><strong>H_onsite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">npc.Array</span></code></span></dt>
<dd><p class="first last">For each site (in MPS order) the onsite part of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling</span></code></a>(strength,&nbsp;u1,&nbsp;op1,&nbsp;u2,&nbsp;op2,&nbsp;dx)</td>
<td>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling_term" title="tenpy.models.model.CouplingModel.add_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling_term</span></code></a>(strength,&nbsp;i,&nbsp;j,&nbsp;op_i,&nbsp;op_j)</td>
<td>Add a two-site coupling term on given MPS sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.add_onsite" title="tenpy.models.model.CouplingModel.add_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite</span></code></a>(strength,&nbsp;u,&nbsp;opname)</td>
<td>Add onsite terms to self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.add_onsite_term" title="tenpy.models.model.CouplingModel.add_onsite_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite_term</span></code></a>(strength,&nbsp;i,&nbsp;op)</td>
<td>Add a onsite term on a given MPS site.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.calc_H_MPO" title="tenpy.models.model.CouplingModel.calc_H_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_MPO</span></code></a>([tol_zero])</td>
<td>Calculate MPO representation of the Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.calc_H_bond" title="tenpy.models.model.CouplingModel.calc_H_bond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond</span></code></a>([tol_zero])</td>
<td>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.calc_H_onsite" title="tenpy.models.model.CouplingModel.calc_H_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_onsite</span></code></a>([tol_zero])</td>
<td>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.coupling_strength_add_ext_flux" title="tenpy.models.model.CouplingModel.coupling_strength_add_ext_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coupling_strength_add_ext_flux</span></code></a>(strength,&nbsp;dx,&nbsp;…)</td>
<td>Add an external flux to the coupling strength.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.group_sites" title="tenpy.models.model.CouplingModel.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.plot_coupling_terms" title="tenpy.models.model.CouplingModel.plot_coupling_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_coupling_terms</span></code></a>(ax[,&nbsp;style_map])</td>
<td>“Plot coupling terms into a given lattice.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingModel.test_sanity" title="tenpy.models.model.CouplingModel.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.CouplingModel.add_coupling">
<code class="descname">add_coupling</code><span class="sig-paren">(</span><em>strength</em>, <em>u1</em>, <em>op1</em>, <em>u2</em>, <em>op2</em>, <em>dx</em>, <em>op_string=None</em>, <em>str_on_first=True</em>, <em>raise_op2_left=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.add_coupling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.add_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP1 * OP2\)</span>, where
<code class="docutils literal notranslate"><span class="pre">OP1</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u1].get_op(op1)</span></code> acts on the site <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u1)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP2</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u2].get_op(op2)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+dx[0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+dx[dim-1],</span> <span class="pre">u2)</span></code>.
Possible combinations <code class="docutils literal notranslate"><span class="pre">x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}</span></code> are determined from the boundary conditions
in <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.possible_couplings" title="tenpy.models.lattice.Lattice.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a>.</p>
<p>The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower
left corner of the hypercube containing the involved sites <span class="math notranslate nohighlight">\(\vec{x}\)</span> and
<span class="math notranslate nohighlight">\(\vec{x}+\vec{dx}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the coupling. May vary spatially (see above). If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>op1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>u2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between OP1 and OP2.
For a 1D lattice, a single int is also fine.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Name of an operator to be used between the OP1 and OP2 sites.
Typical use case is the phase for a Jordan-Wigner transformation.
The operator should be defined on all sites in the unit cell.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed, using
<a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>.</p>
</dd>
<dt><strong>str_on_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter the provided <cite>op_string</cite> should also act on the first site.
This option should be chosen as <code class="docutils literal notranslate"><span class="pre">True</span></code> for Jordan-Wigner strings.
When handling Jordan-Wigner strings we need to extend the <cite>op_string</cite> to also act on
the ‘left’, first site (in the sense of the MPS ordering of the sites given by the
lattice). In this case, there is a well-defined ordering of the operators in the
physical sense (i.e. which of <cite>op1</cite> or <cite>op2</cite> acts first on a given state).
We follow the convention that <cite>op2</cite> acts first (in the physical sense),
independent of the MPS ordering.</p>
</dd>
<dt><strong>raise_op2_left</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Raise an error when <cite>op2</cite> appears left of <cite>op1</cite>
(in the sense of the MPS ordering given by the lattice).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>When initializing a model, you can add a term :math:` J sum_{&lt;i,j&gt;} S^z_i S^z_j`
on all nearest-neighbor bonds of the lattice like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>To add the hermitian conjugate for a hopping term, you can add it in the opposite
direction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.add_coupling_term">
<code class="descname">add_coupling_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>j</em>, <em>op_i</em>, <em>op_j</em>, <em>op_string='Id'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.add_coupling_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.add_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a two-site coupling term on given MPS sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i, j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS indices of the two sites on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>  and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, i.e., <cite>op_i</cite> acts “left” of <cite>op_j</cite>.
If j &gt;= N_sites, it indicates couplings between unit cells of an infinite MPS.</p>
</dd>
<dt><strong>op1, op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the involved operators.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The operator to be inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.add_onsite">
<code class="descname">add_onsite</code><span class="sig-paren">(</span><em>strength</em>, <em>u</em>, <em>opname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.add_onsite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.add_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Add onsite terms to self.</p>
<p>Adds a term <span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[x_0, ..., x_{dim-1}] * OP\)</span>,
where the operator <code class="docutils literal notranslate"><span class="pre">OP=lat.unit_cell[u].get_op(opname)</span></code>
acts on the site given by a lattice index <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u)</span></code>,
to the represented Hamiltonian.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the onsite term. May vary spatially. If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks a <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code> out of the unit cell.</p>
</dd>
<dt><strong>opname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.add_onsite_term">
<code class="descname">add_onsite_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.add_onsite_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.add_onsite_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a onsite term on a given MPS site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS index of the site on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the involved operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.calc_H_MPO">
<code class="descname">calc_H_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.calc_H_MPO"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.calc_H_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate MPO representation of the Hamiltonian.</p>
<p>Uses <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> to build an MPO graph
(and then an MPO).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.calc_H_bond">
<code class="descname">calc_H_bond</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.calc_H_bond"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.calc_H_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self.H_onsite</span> <span class="pre">is</span> <span class="pre">None</span></code>, it is calculated with <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.calc_H_onsite()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <a class="reference internal" href="#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.calc_H_onsite">
<code class="descname">calc_H_onsite</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.calc_H_onsite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.calc_H_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_onsite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of npc.Array</span></dt>
<dd><p class="first last">onsite terms of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.coupling_strength_add_ext_flux">
<code class="descname">coupling_strength_add_ext_flux</code><span class="sig-paren">(</span><em>strength</em>, <em>dx</em>, <em>phase</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.coupling_strength_add_ext_flux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.coupling_strength_add_ext_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an external flux to the coupling strength.</p>
<p>When performing DMRG on a “cylinder” geometry, it might be useful to put an “external flux”
through the cylinder. This means that a particle hopping around the cylinder should
pick up a phase given by the external flux <a class="reference internal" href="../literature.html#resta1997" id="id1">[Resta1997]</a>.
This is also called “twisted boundary conditions” in literature.
This function adds a complex phase to the <cite>strength</cite> array on some bonds, such that
particles hopping in positive direction around the cylinder pick up <cite>exp(+i phase)</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For the sign of <cite>phase</cite> it is important that you consistently use the creation
operator as <cite>op1</cite> and the annihilation operator as <cite>op2</cite> in :meth:<a href="#id2"><span class="problematic" id="id3">`</span></a>add_coupling”.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">The strength to be used in <a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>, when no external flux would be
present.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between <cite>op1</cite> and <cite>op2</cite> in <a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</dd>
<dt><strong>phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of float</span></dt>
<dd><p class="first last">The phase of the external flux for hopping in each direction of the lattice.
E.g., if you want flux through the cylinder on which you have an infinite MPS,
you should give <code class="docutils literal notranslate"><span class="pre">phase=[0,</span> <span class="pre">phi]</span></code> souch that particles pick up a phase <cite>phi</cite> when
hopping around the cylinder.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex array</span></dt>
<dd><p class="first last">The strength array to be used as <cite>strength</cite> in <a class="reference internal" href="#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
with the given <cite>dx</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Let’s say you have an infinite MPS on a cylinder, and want to add nearest-neighbor
hopping of fermions with the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>.
The cylinder axis is the <cite>x</cite>-direction of the lattice, so to put a flux through the
cylinder, you want particles hopping <em>around</em> the cylinder to pick up a phase <cite>phi</cite>
given by the external flux.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strength</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># hopping strength without external flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span> <span class="c1"># determines the external flux strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strength_with_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_strength_add_ext_flux</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">),</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingModel.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.plot_coupling_terms">
<code class="descname">plot_coupling_terms</code><span class="sig-paren">(</span><em>ax</em>, <em>style_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.plot_coupling_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.plot_coupling_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>“Plot coupling terms into a given lattice.</p>
<p>This function plots the <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>style_map</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Get’s called with arguments <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">op_i,</span> <span class="pre">op_strength,</span> <span class="pre">op_j,</span> <span class="pre">strength</span></code> for
each two-site coupling and should return a keyword-dictionary
with the desired plot-style for this combination.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), the linecolor depends on the phase of <cite>strength</cite>,
the <cite>linewidth</cite> is given by the phase of <cite>strength</cite> (using the <cite>hsv</cite> colormap),
and the linestyle depends on the type of operators coupled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.plot_sites" title="tenpy.models.lattice.Lattice.plot_sites"><code class="xref py py-func docutils literal notranslate"><span class="pre">tenpy.models.lattice.Lattice.plot_sites()</span></code></a></dt>
<dd>plot the sites of the lattice.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingModel.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingModel.test_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingModel.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.models.model.MultiCouplingModel">
<em class="property">class </em><code class="descclassname">tenpy.models.model.</code><code class="descname">MultiCouplingModel</code><span class="sig-paren">(</span><em>lattice</em>, <em>bc_coupling=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MultiCouplingModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.CouplingModel</span></code></a></p>
<p>Generalizes <a class="reference internal" href="#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> to allow couplings involving more than two sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coupling_terms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict of dict</span></dt>
<dd><p class="first">Generalization of the coupling_terms of a <a class="reference internal" href="#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> for M-site couplings.
Filled by <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a> or <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_multi_coupling()</span></code></a>.
Nested dictionaries of the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">{(</span><span class="s1">&#39;opname_i&#39;</span><span class="p">,</span> <span class="s1">&#39;opname_string_ij&#39;</span><span class="p">):</span>
     <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="p">{(</span><span class="s1">&#39;opname_j&#39;</span><span class="p">,</span> <span class="s1">&#39;opname_string_jk&#39;</span><span class="p">):</span>
          <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">{(</span><span class="s1">&#39;opname_k&#39;</span><span class="p">,</span> <span class="s1">&#39;opname_string_kl&#39;</span><span class="p">):</span>
               <span class="o">...</span>
               <span class="p">{</span><span class="n">l</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;opname_l&#39;</span><span class="p">:</span> <span class="n">strength</span>
               <span class="p">}</span>   <span class="p">}</span>
          <span class="p">}</span>   <span class="p">}</span>
     <span class="p">}</span>   <span class="p">}</span>
<span class="p">}</span>   <span class="p">}</span>
</pre></div>
</div>
<p class="last">For a M-site coupling, this involves a nesting depth of 2*M dictionaries.
Note that always <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">...</span> <span class="pre">&lt;</span> <span class="pre">l</span></code>, but entries with <code class="docutils literal notranslate"><span class="pre">j,k,l</span> <span class="pre">&gt;=</span> <span class="pre">lat.N_sites</span></code>
are allowed for <code class="docutils literal notranslate"><span class="pre">lat.bc_MPS</span> <span class="pre">==</span> <span class="pre">'infinite'</span></code>, in which case they indicate couplings
between different iMPS unit cells.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling</span></code></a>(strength,&nbsp;u1,&nbsp;op1,&nbsp;u2,&nbsp;op2,&nbsp;dx)</td>
<td>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling_term" title="tenpy.models.model.MultiCouplingModel.add_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling_term</span></code></a>(strength,&nbsp;i,&nbsp;j,&nbsp;op_i,&nbsp;op_j)</td>
<td>Add a two-site coupling term on given MPS sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_multi_coupling</span></code></a>(strength,&nbsp;u0,&nbsp;op0,&nbsp;other_ops)</td>
<td>Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling_term" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_multi_coupling_term</span></code></a>(strength,&nbsp;ijkl,&nbsp;…)</td>
<td>Add a multi-site coupling term on given MPS sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_onsite" title="tenpy.models.model.MultiCouplingModel.add_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite</span></code></a>(strength,&nbsp;u,&nbsp;opname)</td>
<td>Add onsite terms to self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_onsite_term" title="tenpy.models.model.MultiCouplingModel.add_onsite_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite_term</span></code></a>(strength,&nbsp;i,&nbsp;op)</td>
<td>Add a onsite term on a given MPS site.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.calc_H_MPO" title="tenpy.models.model.MultiCouplingModel.calc_H_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_MPO</span></code></a>([tol_zero])</td>
<td>Calculate MPO representation of the Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.calc_H_bond" title="tenpy.models.model.MultiCouplingModel.calc_H_bond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond</span></code></a>([tol_zero])</td>
<td>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.calc_H_onsite" title="tenpy.models.model.MultiCouplingModel.calc_H_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_onsite</span></code></a>([tol_zero])</td>
<td>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux" title="tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coupling_strength_add_ext_flux</span></code></a>(strength,&nbsp;dx,&nbsp;…)</td>
<td>Add an external flux to the coupling strength.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.group_sites" title="tenpy.models.model.MultiCouplingModel.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.plot_coupling_terms" title="tenpy.models.model.MultiCouplingModel.plot_coupling_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_coupling_terms</span></code></a>(ax[,&nbsp;style_map])</td>
<td>“Plot coupling terms into a given lattice.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.test_sanity" title="tenpy.models.model.MultiCouplingModel.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_coupling">
<code class="descname">add_coupling</code><span class="sig-paren">(</span><em>strength</em>, <em>u1</em>, <em>op1</em>, <em>u2</em>, <em>op2</em>, <em>dx</em>, <em>op_string=None</em>, <em>str_on_first=True</em>, <em>raise_op2_left=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP1 * OP2\)</span>, where
<code class="docutils literal notranslate"><span class="pre">OP1</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u1].get_op(op1)</span></code> acts on the site <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u1)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP2</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u2].get_op(op2)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+dx[0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+dx[dim-1],</span> <span class="pre">u2)</span></code>.
Possible combinations <code class="docutils literal notranslate"><span class="pre">x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}</span></code> are determined from the boundary conditions
in <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.possible_couplings" title="tenpy.models.lattice.Lattice.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a>.</p>
<p>The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower
left corner of the hypercube containing the involved sites <span class="math notranslate nohighlight">\(\vec{x}\)</span> and
<span class="math notranslate nohighlight">\(\vec{x}+\vec{dx}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the coupling. May vary spatially (see above). If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>op1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>u2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between OP1 and OP2.
For a 1D lattice, a single int is also fine.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Name of an operator to be used between the OP1 and OP2 sites.
Typical use case is the phase for a Jordan-Wigner transformation.
The operator should be defined on all sites in the unit cell.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed, using
<a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>.</p>
</dd>
<dt><strong>str_on_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter the provided <cite>op_string</cite> should also act on the first site.
This option should be chosen as <code class="docutils literal notranslate"><span class="pre">True</span></code> for Jordan-Wigner strings.
When handling Jordan-Wigner strings we need to extend the <cite>op_string</cite> to also act on
the ‘left’, first site (in the sense of the MPS ordering of the sites given by the
lattice). In this case, there is a well-defined ordering of the operators in the
physical sense (i.e. which of <cite>op1</cite> or <cite>op2</cite> acts first on a given state).
We follow the convention that <cite>op2</cite> acts first (in the physical sense),
independent of the MPS ordering.</p>
</dd>
<dt><strong>raise_op2_left</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Raise an error when <cite>op2</cite> appears left of <cite>op1</cite>
(in the sense of the MPS ordering given by the lattice).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>When initializing a model, you can add a term :math:` J sum_{&lt;i,j&gt;} S^z_i S^z_j`
on all nearest-neighbor bonds of the lattice like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>To add the hermitian conjugate for a hopping term, you can add it in the opposite
direction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_coupling_term">
<code class="descname">add_coupling_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>j</em>, <em>op_i</em>, <em>op_j</em>, <em>op_string='Id'</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a two-site coupling term on given MPS sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i, j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS indices of the two sites on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>  and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, i.e., <cite>op_i</cite> acts “left” of <cite>op_j</cite>.
If j &gt;= N_sites, it indicates couplings between unit cells of an infinite MPS.</p>
</dd>
<dt><strong>op1, op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the involved operators.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The operator to be inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_multi_coupling">
<code class="descname">add_multi_coupling</code><span class="sig-paren">(</span><em>strength</em>, <em>u0</em>, <em>op0</em>, <em>other_ops</em>, <em>op_string=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MultiCouplingModel.add_multi_coupling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP0 * OP1 * ... * OPM\)</span>,
where <code class="docutils literal notranslate"><span class="pre">OP_0</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u0].get_op(op0)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u0)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP_m</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[other_u[m]].get_op(other_op[m])</span></code>, m=1…M, acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+other_dx[m][0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+other_dx[m][dim-1],</span> <span class="pre">other_u[m])</span></code>.
For periodic boundary conditions along direction <cite>a</cite> (<code class="docutils literal notranslate"><span class="pre">lat.bc[a]</span> <span class="pre">==</span> <span class="pre">False</span></code>)
the index <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is taken modulo <code class="docutils literal notranslate"><span class="pre">lat.Ls[a]</span></code> and runs through <code class="docutils literal notranslate"><span class="pre">range(lat.Ls[a])</span></code>.
For open boundary conditions, <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is limited to <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a</span> <span class="pre">&lt;</span> <span class="pre">Ls[a]</span></code> and
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a+other_dx[m,a]</span> <span class="pre">&lt;</span> <span class="pre">lat.Ls[a]</span></code>.
The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower left
corner of the hypercube containing all the involved sites
<span class="math notranslate nohighlight">\(\vec{x}, \vec{x}+\vec{other_dx[m, :]}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the coupling. May vary spatially and is tiled to the required shape.</p>
</dd>
<dt><strong>u0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u0]</span></code> for OP0.</p>
</dd>
<dt><strong>op0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u0]</span></code> for OP0.</p>
</dd>
<dt><strong>other_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">op_m,</span> <span class="pre">dx)</span></code></span></dt>
<dd><p class="first last">One tuple for each of the other operators <code class="docutils literal notranslate"><span class="pre">OP1,</span> <span class="pre">OP2,</span> <span class="pre">...</span> <span class="pre">OPM</span></code> involved.
<cite>u</cite> picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>, <cite>op_name</cite> is a valid operator acting on that
site, and <cite>dx</cite> gives the translation vector between <code class="docutils literal notranslate"><span class="pre">OP0</span></code> and the specified operator.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first">Name of an operator to be used inbetween the operators, excluding the sites on which
the operators act. This operator should be defined on all sites in the unit cell.</p>
<p class="last">Special case: If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed
(using <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>), for each of the segments
inbetween the operators and also on the sites of the left operators.
Note that in this case the ordering of the operators <em>is</em> important and handled in the
usual convention that <code class="docutils literal notranslate"><span class="pre">OPM</span></code> acts first and <code class="docutils literal notranslate"><span class="pre">OP0</span></code> last on a physical state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_multi_coupling_term">
<code class="descname">add_multi_coupling_term</code><span class="sig-paren">(</span><em>strength</em>, <em>ijkl</em>, <em>ops_ijkl</em>, <em>op_string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MultiCouplingModel.add_multi_coupling_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a multi-site coupling term on given MPS sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>ijkl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">The MPS indices of the sites on which the operators acts. With <cite>i, j, k, … = ijkl</cite>,
we require that they are ordered ascending, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">...</span></code> and
that <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>.
Inidces &gt;= N_sites indicate couplings between different unit cells of an infinite MPS.</p>
</dd>
<dt><strong>ops_ijkl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">Names of the involved operators on sites <cite>i, j, k, …</cite>.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">Names of the operator to be inserted between the operators,
e.g., op_string[0] is inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_onsite">
<code class="descname">add_onsite</code><span class="sig-paren">(</span><em>strength</em>, <em>u</em>, <em>opname</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Add onsite terms to self.</p>
<p>Adds a term <span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[x_0, ..., x_{dim-1}] * OP\)</span>,
where the operator <code class="docutils literal notranslate"><span class="pre">OP=lat.unit_cell[u].get_op(opname)</span></code>
acts on the site given by a lattice index <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u)</span></code>,
to the represented Hamiltonian.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the onsite term. May vary spatially. If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks a <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code> out of the unit cell.</p>
</dd>
<dt><strong>opname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_onsite_term">
<code class="descname">add_onsite_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_onsite_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a onsite term on a given MPS site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS index of the site on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the involved operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.calc_H_MPO">
<code class="descname">calc_H_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.calc_H_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate MPO representation of the Hamiltonian.</p>
<p>Uses <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> to build an MPO graph
(and then an MPO).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.calc_H_bond">
<code class="descname">calc_H_bond</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.calc_H_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self.H_onsite</span> <span class="pre">is</span> <span class="pre">None</span></code>, it is calculated with <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.calc_H_onsite()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <a class="reference internal" href="#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.calc_H_onsite">
<code class="descname">calc_H_onsite</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.calc_H_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_onsite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of npc.Array</span></dt>
<dd><p class="first last">onsite terms of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux">
<code class="descname">coupling_strength_add_ext_flux</code><span class="sig-paren">(</span><em>strength</em>, <em>dx</em>, <em>phase</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an external flux to the coupling strength.</p>
<p>When performing DMRG on a “cylinder” geometry, it might be useful to put an “external flux”
through the cylinder. This means that a particle hopping around the cylinder should
pick up a phase given by the external flux <a class="reference internal" href="../literature.html#resta1997" id="id4">[Resta1997]</a>.
This is also called “twisted boundary conditions” in literature.
This function adds a complex phase to the <cite>strength</cite> array on some bonds, such that
particles hopping in positive direction around the cylinder pick up <cite>exp(+i phase)</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For the sign of <cite>phase</cite> it is important that you consistently use the creation
operator as <cite>op1</cite> and the annihilation operator as <cite>op2</cite> in :meth:<a href="#id5"><span class="problematic" id="id6">`</span></a>add_coupling”.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">The strength to be used in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>, when no external flux would be
present.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between <cite>op1</cite> and <cite>op2</cite> in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</dd>
<dt><strong>phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of float</span></dt>
<dd><p class="first last">The phase of the external flux for hopping in each direction of the lattice.
E.g., if you want flux through the cylinder on which you have an infinite MPS,
you should give <code class="docutils literal notranslate"><span class="pre">phase=[0,</span> <span class="pre">phi]</span></code> souch that particles pick up a phase <cite>phi</cite> when
hopping around the cylinder.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex array</span></dt>
<dd><p class="first last">The strength array to be used as <cite>strength</cite> in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
with the given <cite>dx</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Let’s say you have an infinite MPS on a cylinder, and want to add nearest-neighbor
hopping of fermions with the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>.
The cylinder axis is the <cite>x</cite>-direction of the lattice, so to put a flux through the
cylinder, you want particles hopping <em>around</em> the cylinder to pick up a phase <cite>phi</cite>
given by the external flux.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strength</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># hopping strength without external flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span> <span class="c1"># determines the external flux strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strength_with_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_strength_add_ext_flux</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">),</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.plot_coupling_terms">
<code class="descname">plot_coupling_terms</code><span class="sig-paren">(</span><em>ax</em>, <em>style_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.plot_coupling_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>“Plot coupling terms into a given lattice.</p>
<p>This function plots the <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>style_map</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Get’s called with arguments <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">op_i,</span> <span class="pre">op_strength,</span> <span class="pre">op_j,</span> <span class="pre">strength</span></code> for
each two-site coupling and should return a keyword-dictionary
with the desired plot-style for this combination.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), the linecolor depends on the phase of <cite>strength</cite>,
the <cite>linewidth</cite> is given by the phase of <cite>strength</cite> (using the <cite>hsv</cite> colormap),
and the linestyle depends on the type of operators coupled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.plot_sites" title="tenpy.models.lattice.Lattice.plot_sites"><code class="xref py py-func docutils literal notranslate"><span class="pre">tenpy.models.lattice.Lattice.plot_sites()</span></code></a></dt>
<dd>plot the sites of the lattice.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.models.model.CouplingMPOModel">
<em class="property">class </em><code class="descclassname">tenpy.models.model.</code><code class="descname">CouplingMPOModel</code><span class="sig-paren">(</span><em>model_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingMPOModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.CouplingModel</span></code></a>, <a class="reference internal" href="#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.MPOModel</span></code></a></p>
<p>Combination of the CouplingModel and MPOModel.</p>
<p>This class provides the interface for most of the model classes in <cite>tenpy</cite>.
Examples based on this class are given in <a class="reference internal" href="tenpy.models.xxz_chain.html#module-tenpy.models.xxz_chain" title="tenpy.models.xxz_chain"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xxz_chain</span></code></a>
and <a class="reference internal" href="tenpy.models.tf_ising.html#module-tenpy.models.tf_ising" title="tenpy.models.tf_ising"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tf_ising</span></code></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__init__</span></code> of this function performs the standard initialization explained
in <a class="reference internal" href="../intro_model.html"><span class="doc">Introduction to models</span></a>, by calling the methods <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_lattice" title="tenpy.models.model.CouplingMPOModel.init_lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_lattice()</span></code></a> (step 1-4)
to initialize a lattice (which in turn calls <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_sites" title="tenpy.models.model.CouplingMPOModel.init_sites"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_sites()</span></code></a>) and
<a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_terms" title="tenpy.models.model.CouplingMPOModel.init_terms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_terms()</span></code></a>. The latter should be overwritten by subclasses to add the
desired terms.</p>
<p>As shown in <a class="reference internal" href="tenpy.models.tf_ising.html#module-tenpy.models.tf_ising" title="tenpy.models.tf_ising"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tf_ising</span></code></a>, you can get a 1D version suitable
for TEBD from a general-lattice model by subclassing it once more, only
redefining the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">):</span>
    <span class="n">CouplingMPOModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_params</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary with all the model parameters.
These parameters are given to the different <code class="docutils literal notranslate"><span class="pre">init_...()</span></code> methods, and
should be read out using <a class="reference internal" href="tenpy.tools.params.html#tenpy.tools.params.get_parameter" title="tenpy.tools.params.get_parameter"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_parameter()</span></code></a>.
This may happen in any of the <code class="docutils literal notranslate"><span class="pre">init_...()</span></code> methods.
The parameter <code class="docutils literal notranslate"><span class="pre">'verbose'</span></code> is read out in the <cite>__init__</cite> of this function
and specifies how much status information should be printed during initialization.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the model, e.g. <code class="docutils literal notranslate"><span class="pre">&quot;XXZChain&quot;</span> <span class="pre">or</span> <span class="pre">``&quot;SpinModel&quot;</span></code>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Level of verbosity (i.e. how much status information to print); higher=more output.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_coupling" title="tenpy.models.model.CouplingMPOModel.add_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling</span></code></a>(strength,&nbsp;u1,&nbsp;op1,&nbsp;u2,&nbsp;op2,&nbsp;dx)</td>
<td>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_coupling_term" title="tenpy.models.model.CouplingMPOModel.add_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling_term</span></code></a>(strength,&nbsp;i,&nbsp;j,&nbsp;op_i,&nbsp;op_j)</td>
<td>Add a two-site coupling term on given MPS sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_onsite" title="tenpy.models.model.CouplingMPOModel.add_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite</span></code></a>(strength,&nbsp;u,&nbsp;opname)</td>
<td>Add onsite terms to self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_onsite_term" title="tenpy.models.model.CouplingMPOModel.add_onsite_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite_term</span></code></a>(strength,&nbsp;i,&nbsp;op)</td>
<td>Add a onsite term on a given MPS site.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.calc_H_MPO" title="tenpy.models.model.CouplingMPOModel.calc_H_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_MPO</span></code></a>([tol_zero])</td>
<td>Calculate MPO representation of the Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.calc_H_bond" title="tenpy.models.model.CouplingMPOModel.calc_H_bond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond</span></code></a>([tol_zero])</td>
<td>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.calc_H_bond_from_MPO" title="tenpy.models.model.CouplingMPOModel.calc_H_bond_from_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond_from_MPO</span></code></a>([tol_zero])</td>
<td>Calculate the bond Hamiltonian from the MPO Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.calc_H_onsite" title="tenpy.models.model.CouplingMPOModel.calc_H_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_onsite</span></code></a>([tol_zero])</td>
<td>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.coupling_strength_add_ext_flux" title="tenpy.models.model.CouplingMPOModel.coupling_strength_add_ext_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coupling_strength_add_ext_flux</span></code></a>(strength,&nbsp;dx,&nbsp;…)</td>
<td>Add an external flux to the coupling strength.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.group_sites" title="tenpy.models.model.CouplingMPOModel.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_lattice" title="tenpy.models.model.CouplingMPOModel.init_lattice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_lattice</span></code></a>(model_params)</td>
<td>Initialize a lattice for the given model parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_sites" title="tenpy.models.model.CouplingMPOModel.init_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_sites</span></code></a>(model_params)</td>
<td>Define the local Hilbert space and operators; needs to be implemented in subclasses.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_terms" title="tenpy.models.model.CouplingMPOModel.init_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_terms</span></code></a>(model_params)</td>
<td>Add the onsite and coupling terms to the model; subclasses should implement this.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.plot_coupling_terms" title="tenpy.models.model.CouplingMPOModel.plot_coupling_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_coupling_terms</span></code></a>(ax[,&nbsp;style_map])</td>
<td>“Plot coupling terms into a given lattice.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.test_sanity" title="tenpy.models.model.CouplingMPOModel.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.add_coupling">
<code class="descname">add_coupling</code><span class="sig-paren">(</span><em>strength</em>, <em>u1</em>, <em>op1</em>, <em>u2</em>, <em>op2</em>, <em>dx</em>, <em>op_string=None</em>, <em>str_on_first=True</em>, <em>raise_op2_left=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.add_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP1 * OP2\)</span>, where
<code class="docutils literal notranslate"><span class="pre">OP1</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u1].get_op(op1)</span></code> acts on the site <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u1)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP2</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u2].get_op(op2)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+dx[0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+dx[dim-1],</span> <span class="pre">u2)</span></code>.
Possible combinations <code class="docutils literal notranslate"><span class="pre">x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}</span></code> are determined from the boundary conditions
in <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.possible_couplings" title="tenpy.models.lattice.Lattice.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a>.</p>
<p>The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower
left corner of the hypercube containing the involved sites <span class="math notranslate nohighlight">\(\vec{x}\)</span> and
<span class="math notranslate nohighlight">\(\vec{x}+\vec{dx}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the coupling. May vary spatially (see above). If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>op1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>u2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between OP1 and OP2.
For a 1D lattice, a single int is also fine.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Name of an operator to be used between the OP1 and OP2 sites.
Typical use case is the phase for a Jordan-Wigner transformation.
The operator should be defined on all sites in the unit cell.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed, using
<a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>.</p>
</dd>
<dt><strong>str_on_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter the provided <cite>op_string</cite> should also act on the first site.
This option should be chosen as <code class="docutils literal notranslate"><span class="pre">True</span></code> for Jordan-Wigner strings.
When handling Jordan-Wigner strings we need to extend the <cite>op_string</cite> to also act on
the ‘left’, first site (in the sense of the MPS ordering of the sites given by the
lattice). In this case, there is a well-defined ordering of the operators in the
physical sense (i.e. which of <cite>op1</cite> or <cite>op2</cite> acts first on a given state).
We follow the convention that <cite>op2</cite> acts first (in the physical sense),
independent of the MPS ordering.</p>
</dd>
<dt><strong>raise_op2_left</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Raise an error when <cite>op2</cite> appears left of <cite>op1</cite>
(in the sense of the MPS ordering given by the lattice).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>When initializing a model, you can add a term :math:` J sum_{&lt;i,j&gt;} S^z_i S^z_j`
on all nearest-neighbor bonds of the lattice like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sm&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sp&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>To add the hermitian conjugate for a hopping term, you can add it in the opposite
direction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.add_coupling_term">
<code class="descname">add_coupling_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>j</em>, <em>op_i</em>, <em>op_j</em>, <em>op_string='Id'</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.add_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a two-site coupling term on given MPS sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i, j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS indices of the two sites on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>  and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, i.e., <cite>op_i</cite> acts “left” of <cite>op_j</cite>.
If j &gt;= N_sites, it indicates couplings between unit cells of an infinite MPS.</p>
</dd>
<dt><strong>op1, op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the involved operators.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The operator to be inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.add_onsite">
<code class="descname">add_onsite</code><span class="sig-paren">(</span><em>strength</em>, <em>u</em>, <em>opname</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.add_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Add onsite terms to self.</p>
<p>Adds a term <span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[x_0, ..., x_{dim-1}] * OP\)</span>,
where the operator <code class="docutils literal notranslate"><span class="pre">OP=lat.unit_cell[u].get_op(opname)</span></code>
acts on the site given by a lattice index <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u)</span></code>,
to the represented Hamiltonian.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the onsite term. May vary spatially. If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks a <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code> out of the unit cell.</p>
</dd>
<dt><strong>opname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.add_onsite_term">
<code class="descname">add_onsite_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.add_onsite_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a onsite term on a given MPS site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS index of the site on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the involved operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.calc_H_MPO">
<code class="descname">calc_H_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.calc_H_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate MPO representation of the Hamiltonian.</p>
<p>Uses <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> to build an MPO graph
(and then an MPO).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.calc_H_bond">
<code class="descname">calc_H_bond</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.calc_H_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self.H_onsite</span> <span class="pre">is</span> <span class="pre">None</span></code>, it is calculated with <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.calc_H_onsite()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <a class="reference internal" href="#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.calc_H_bond_from_MPO">
<code class="descname">calc_H_bond_from_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.calc_H_bond_from_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the bond Hamiltonian from the MPO Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Arrays with norm &lt; <cite>tol_zero</cite> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <a class="reference internal" href="#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.calc_H_onsite">
<code class="descname">calc_H_onsite</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.calc_H_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_onsite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of npc.Array</span></dt>
<dd><p class="first last">onsite terms of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.coupling_strength_add_ext_flux">
<code class="descname">coupling_strength_add_ext_flux</code><span class="sig-paren">(</span><em>strength</em>, <em>dx</em>, <em>phase</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.coupling_strength_add_ext_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an external flux to the coupling strength.</p>
<p>When performing DMRG on a “cylinder” geometry, it might be useful to put an “external flux”
through the cylinder. This means that a particle hopping around the cylinder should
pick up a phase given by the external flux <a class="reference internal" href="../literature.html#resta1997" id="id7">[Resta1997]</a>.
This is also called “twisted boundary conditions” in literature.
This function adds a complex phase to the <cite>strength</cite> array on some bonds, such that
particles hopping in positive direction around the cylinder pick up <cite>exp(+i phase)</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For the sign of <cite>phase</cite> it is important that you consistently use the creation
operator as <cite>op1</cite> and the annihilation operator as <cite>op2</cite> in :meth:<a href="#id8"><span class="problematic" id="id9">`</span></a>add_coupling”.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">The strength to be used in <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_coupling" title="tenpy.models.model.CouplingMPOModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>, when no external flux would be
present.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between <cite>op1</cite> and <cite>op2</cite> in <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_coupling" title="tenpy.models.model.CouplingMPOModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</dd>
<dt><strong>phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of float</span></dt>
<dd><p class="first last">The phase of the external flux for hopping in each direction of the lattice.
E.g., if you want flux through the cylinder on which you have an infinite MPS,
you should give <code class="docutils literal notranslate"><span class="pre">phase=[0,</span> <span class="pre">phi]</span></code> souch that particles pick up a phase <cite>phi</cite> when
hopping around the cylinder.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex array</span></dt>
<dd><p class="first last">The strength array to be used as <cite>strength</cite> in <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.add_coupling" title="tenpy.models.model.CouplingMPOModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
with the given <cite>dx</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Let’s say you have an infinite MPS on a cylinder, and want to add nearest-neighbor
hopping of fermions with the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>.
The cylinder axis is the <cite>x</cite>-direction of the lattice, so to put a flux through the
cylinder, you want particles hopping <em>around</em> the cylinder to pick up a phase <cite>phi</cite>
given by the external flux.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strength</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># hopping strength without external flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span> <span class="c1"># determines the external flux strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strength_with_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_strength_add_ext_flux</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">),</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.init_lattice">
<code class="descname">init_lattice</code><span class="sig-paren">(</span><em>model_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingMPOModel.init_lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.init_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a lattice for the given model parameters.</p>
<p>This function reads out the model parameter <cite>lattice</cite>.
This can be a full <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a> instance,
in which case it is just returned without further action.
Alternatively, the <cite>lattice</cite> parameter can be a string giving the name
of one of the predefined lattices, which then gets initialized.
Depending on the dimensionality of the lattice, this requires different model parameters.</p>
<p>The following model parameters get read out.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="10%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">key</th>
<th class="head">type</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lattice</td>
<td>str |
Lattice</td>
<td>The name of a lattice pre-defined in TeNPy to be initialized.
Alternatively, a (possibly self-defined) Lattice instance.
In the latter case, no further parameters are read out.</td>
</tr>
<tr class="row-odd"><td>bc_MPS</td>
<td>str</td>
<td>Boundary conditions for the MPS</td>
</tr>
<tr class="row-even"><td>order</td>
<td>str</td>
<td>The order of sites within the lattice for non-trivial lattices.</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>int</td>
<td>The length in x-direction (or lenght of the unit cell for
infinite systems).
Only read out for 1D lattices.</td>
</tr>
<tr class="row-even"><td>Lx, Ly</td>
<td>int</td>
<td>The length in x- and y-direction.
For <code class="docutils literal notranslate"><span class="pre">&quot;infinite&quot;</span></code> <cite>bc_MPS</cite>, the system is infinite in
x-direction and <cite>Lx</cite> is the number of “rings” in the infinite
MPS unit cell, while <cite>Ly</cite> gives the circumference around the
cylinder or width of th the rung for a ladder (depending on
<cite>bc_y</cite>.
Only read out for 2D lattices.</td>
</tr>
<tr class="row-odd"><td>bc_y</td>
<td>str</td>
<td><code class="docutils literal notranslate"><span class="pre">&quot;cylinder&quot;</span> <span class="pre">|</span> <span class="pre">&quot;ladder&quot;</span></code>.
The boundary conditions in y-direction.
Only read out for 2D lattices.</td>
</tr>
<tr class="row-even"><td>bc_x</td>
<td>str</td>
<td><code class="docutils literal notranslate"><span class="pre">&quot;open&quot;</span> <span class="pre">|</span> <span class="pre">&quot;periodic&quot;</span></code>.
Can be used to force “periodic” boundaries for the lattice,
i.e., for the couplings in the Hamiltonian,
even if the MPS is finite.
Defaults to <code class="docutils literal notranslate"><span class="pre">&quot;open&quot;</span></code> for <code class="docutils literal notranslate"><span class="pre">bc_MPS=&quot;finite&quot;</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;periodic&quot;</span></code> for <code class="docutils literal notranslate"><span class="pre">bc_MPS=&quot;infinite</span></code>.
If you are not aware of the consequences, you should probably
<em>not</em> use “periodic” boundary conditions.
(The MPS is still “open”, so this will introduce long-range
couplings between the first and last sites of the MPS!)</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The model parameters given to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lat</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a></span></dt>
<dd><p class="first last">An initialized lattice.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.init_sites">
<code class="descname">init_sites</code><span class="sig-paren">(</span><em>model_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingMPOModel.init_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.init_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the local Hilbert space and operators; needs to be implemented in subclasses.</p>
<p>This function gets called by <a class="reference internal" href="#tenpy.models.model.CouplingMPOModel.init_lattice" title="tenpy.models.model.CouplingMPOModel.init_lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">init_lattice()</span></code></a> to get the
<a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a> for the lattice unit cell.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Initializing the sites requires to define the conserved quantum numbers.
All pre-defined sites accept <code class="docutils literal notranslate"><span class="pre">conserve=None</span></code> to disable using quantum numbers.
Many models in TeNPy read out the <cite>conserve</cite> model parameter, which can be set
to <code class="docutils literal notranslate"><span class="pre">&quot;best&quot;</span></code> to indicate the optimal parameters.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>model_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The model parameters given to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(tuple of) <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The local sites of the lattice, defining the local basis states and operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.init_terms">
<code class="descname">init_terms</code><span class="sig-paren">(</span><em>model_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#CouplingMPOModel.init_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.init_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the onsite and coupling terms to the model; subclasses should implement this.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.plot_coupling_terms">
<code class="descname">plot_coupling_terms</code><span class="sig-paren">(</span><em>ax</em>, <em>style_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.plot_coupling_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>“Plot coupling terms into a given lattice.</p>
<p>This function plots the <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>style_map</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Get’s called with arguments <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">op_i,</span> <span class="pre">op_strength,</span> <span class="pre">op_j,</span> <span class="pre">strength</span></code> for
each two-site coupling and should return a keyword-dictionary
with the desired plot-style for this combination.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), the linecolor depends on the phase of <cite>strength</cite>,
the <cite>linewidth</cite> is given by the phase of <cite>strength</cite> (using the <cite>hsv</cite> colormap),
and the linestyle depends on the type of operators coupled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.plot_sites" title="tenpy.models.lattice.Lattice.plot_sites"><code class="xref py py-func docutils literal notranslate"><span class="pre">tenpy.models.lattice.Lattice.plot_sites()</span></code></a></dt>
<dd>plot the sites of the lattice.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.CouplingMPOModel.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.CouplingMPOModel.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.models.lattice.html"
                        title="previous chapter">tenpy.models.lattice module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.models.spins.html"
                        title="next chapter">tenpy.models.spins module</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tenpy.html">Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.algorithms.html">tenpy.algorithms package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.html">tenpy.linalg package</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.models.html">tenpy.models package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.html">tenpy.networks package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.tools.html">tenpy.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#module-tenpy">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.models.spins.html" title="tenpy.models.spins module"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.models.lattice.html" title="tenpy.models.lattice module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.models.html" >tenpy.models package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 17, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>