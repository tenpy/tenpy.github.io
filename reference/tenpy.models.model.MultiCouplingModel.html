
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>MultiCouplingModel &#8212; TeNPy 0.4.1 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="NearestNeighborModel" href="tenpy.models.model.NearestNeighborModel.html" />
    <link rel="prev" title="Model" href="tenpy.models.model.Model.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.models.model.NearestNeighborModel.html" title="NearestNeighborModel"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.models.model.Model.html" title="Model"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.models.html" >models</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="tenpy.models.model.html" accesskey="U">model</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="multicouplingmodel">
<h1>MultiCouplingModel<a class="headerlink" href="#multicouplingmodel" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p>full name: tenpy.models.model.MultiCouplingModel</p></li>
<li><p>parent module: <a class="reference internal" href="tenpy.models.model.html#module-tenpy.models.model" title="tenpy.models.model"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tenpy.models.model</span></code></a></p></li>
<li><p>type: class</p></li>
</ul>
<dl class="class">
<dt id="tenpy.models.model.MultiCouplingModel">
<em class="property">class </em><code class="sig-prename descclassname">tenpy.models.model.</code><code class="sig-name descname">MultiCouplingModel</code><span class="sig-paren">(</span><em class="sig-param">lattice</em>, <em class="sig-param">bc_coupling=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MultiCouplingModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.CouplingModel</span></code></a></p>
<p>Generalizes <a class="reference internal" href="tenpy.models.model.CouplingModel.html#tenpy.models.model.CouplingModel" title="tenpy.models.model.CouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouplingModel</span></code></a> to allow couplings involving more than two sites.</p>
<p>The corresponding couplings can be added with <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_multi_coupling()</span></code></a> and
<a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling_term" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling_term"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_multi_coupling_term()</span></code></a> and are saved in <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>, which can now contain
instances of <a class="reference internal" href="tenpy.networks.terms.MultiCouplingTerms.html#tenpy.networks.terms.MultiCouplingTerms" title="tenpy.networks.terms.MultiCouplingTerms"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiCouplingTerms</span></code></a>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling</span></code></a>(strength, u1, op1, u2, op2, dx)</p></td>
<td><p>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling_term" title="tenpy.models.model.MultiCouplingModel.add_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling_term</span></code></a>(strength, i, j, op_i, op_j)</p></td>
<td><p>Add a two-site coupling term on given MPS sites.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_multi_coupling</span></code></a>(strength, u0, op0, other_ops)</p></td>
<td><p>Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling_term" title="tenpy.models.model.MultiCouplingModel.add_multi_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_multi_coupling_term</span></code></a>(strength, ijkl, …)</p></td>
<td><p>Add a general M-site coupling term on given MPS sites.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_onsite" title="tenpy.models.model.MultiCouplingModel.add_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite</span></code></a>(strength, u, opname[, category])</p></td>
<td><p>Add onsite terms to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_onsite_term" title="tenpy.models.model.MultiCouplingModel.add_onsite_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite_term</span></code></a>(strength, i, op[, category])</p></td>
<td><p>Add an onsite term on a given MPS site.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.all_coupling_terms" title="tenpy.models.model.MultiCouplingModel.all_coupling_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_coupling_terms</span></code></a>()</p></td>
<td><p>Sum of all <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.all_onsite_terms" title="tenpy.models.model.MultiCouplingModel.all_onsite_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_onsite_terms</span></code></a>()</p></td>
<td><p>Sum of all <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.calc_H_MPO" title="tenpy.models.model.MultiCouplingModel.calc_H_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_MPO</span></code></a>([tol_zero])</p></td>
<td><p>Calculate MPO representation of the Hamiltonian.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.calc_H_bond" title="tenpy.models.model.MultiCouplingModel.calc_H_bond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond</span></code></a>([tol_zero])</p></td>
<td><p>calculate <cite>H_bond</cite> from <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.calc_H_onsite" title="tenpy.models.model.MultiCouplingModel.calc_H_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_onsite</span></code></a>([tol_zero])</p></td>
<td><p>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux" title="tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coupling_strength_add_ext_flux</span></code></a>(strength, dx, …)</p></td>
<td><p>Add an external flux to the coupling strength.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.group_sites" title="tenpy.models.model.MultiCouplingModel.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n, grouped_sites])</p></td>
<td><p>Modify <cite>self</cite> in place to group sites.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.test_sanity" title="tenpy.models.model.MultiCouplingModel.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</p></td>
<td><p>Sanity check.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_multi_coupling">
<code class="sig-name descname">add_multi_coupling</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">u0</em>, <em class="sig-param">op0</em>, <em class="sig-param">other_ops</em>, <em class="sig-param">op_string=None</em>, <em class="sig-param">category=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MultiCouplingModel.add_multi_coupling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP0 * OP1 * ... * OPM\)</span>,
where <code class="docutils literal notranslate"><span class="pre">OP_0</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u0].get_op(op0)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u0)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP_m</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[other_u[m]].get_op(other_op[m])</span></code>, m=1…M, acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+other_dx[m][0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+other_dx[m][dim-1],</span> <span class="pre">other_u[m])</span></code>.
For periodic boundary conditions along direction <cite>a</cite> (<code class="docutils literal notranslate"><span class="pre">lat.bc[a]</span> <span class="pre">==</span> <span class="pre">False</span></code>)
the index <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is taken modulo <code class="docutils literal notranslate"><span class="pre">lat.Ls[a]</span></code> and runs through <code class="docutils literal notranslate"><span class="pre">range(lat.Ls[a])</span></code>.
For open boundary conditions, <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is limited to <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a</span> <span class="pre">&lt;</span> <span class="pre">Ls[a]</span></code> and
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a+other_dx[m,a]</span> <span class="pre">&lt;</span> <span class="pre">lat.Ls[a]</span></code>.
The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower left
corner of the hypercube containing all the involved sites
<span class="math notranslate nohighlight">\(\vec{x}, \vec{x}+\vec{other_dx[m, :]}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>strength</strong><span class="classifier">scalar | array</span></dt><dd><p>Prefactor of the coupling. May vary spatially and is tiled to the required shape.</p>
</dd>
<dt><strong>u0</strong><span class="classifier">int</span></dt><dd><p>Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u0]</span></code> for OP0.</p>
</dd>
<dt><strong>op0</strong><span class="classifier">str</span></dt><dd><p>Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u0]</span></code> for OP0.</p>
</dd>
<dt><strong>other_ops</strong><span class="classifier">list of <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">op_m,</span> <span class="pre">dx)</span></code></span></dt><dd><p>One tuple for each of the other operators <code class="docutils literal notranslate"><span class="pre">OP1,</span> <span class="pre">OP2,</span> <span class="pre">...</span> <span class="pre">OPM</span></code> involved.
<cite>u</cite> picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>, <cite>op_name</cite> is a valid operator acting on that
site, and <cite>dx</cite> gives the translation vector between <code class="docutils literal notranslate"><span class="pre">OP0</span></code> and the specified operator.</p>
</dd>
<dt><strong>op_string</strong><span class="classifier">str | None</span></dt><dd><p>Name of an operator to be used inbetween the operators, excluding the sites on which
the operators act. This operator should be defined on all sites in the unit cell.</p>
<p>Special case: If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed
(using <a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>), for each of the segments
inbetween the operators and also on the sites of the left operators.
Note that in this case the ordering of the operators <em>is</em> important and handled in the
usual convention that <code class="docutils literal notranslate"><span class="pre">OPM</span></code> acts first and <code class="docutils literal notranslate"><span class="pre">OP0</span></code> last on a physical state.</p>
</dd>
<dt><strong>category</strong><span class="classifier">str</span></dt><dd><p>Descriptive name used as key for <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>.
Defaults to a string of the form <code class="docutils literal notranslate"><span class="pre">&quot;{op0}_i</span> <span class="pre">{other_ops[0]}_j</span> <span class="pre">{other_ops[1]}_k</span> <span class="pre">...&quot;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_multi_coupling_term">
<code class="sig-name descname">add_multi_coupling_term</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">ijkl</em>, <em class="sig-param">ops_ijkl</em>, <em class="sig-param">op_string</em>, <em class="sig-param">category=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/model.html#MultiCouplingModel.add_multi_coupling_term"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_multi_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a general M-site coupling term on given MPS sites.</p>
<p>Wrapper for <code class="docutils literal notranslate"><span class="pre">self.coupling_terms[category].add_multi_coupling_term(...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">float</span></dt><dd><p>The strength of the coupling term.</p>
</dd>
<dt><strong>ijkl</strong><span class="classifier">list of int</span></dt><dd><p>The MPS indices of the sites on which the operators acts. With <cite>i, j, k, … = ijkl</cite>,
we require that they are ordered ascending, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">...</span></code> and
that <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>.
Inidces &gt;= N_sites indicate couplings between different unit cells of an infinite MPS.</p>
</dd>
<dt><strong>ops_ijkl</strong><span class="classifier">list of str</span></dt><dd><p>Names of the involved operators on sites <cite>i, j, k, …</cite>.</p>
</dd>
<dt><strong>op_string</strong><span class="classifier">list of str</span></dt><dd><p>Names of the operator to be inserted between the operators,
e.g., op_string[0] is inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
<dt><strong>category</strong><span class="classifier">str</span></dt><dd><p>Descriptive name used as key for <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>.
Defaults to a string of the form <code class="docutils literal notranslate"><span class="pre">&quot;{op0}_i</span> <span class="pre">{other_ops[0]}_j</span> <span class="pre">{other_ops[1]}_k</span> <span class="pre">...&quot;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_coupling">
<code class="sig-name descname">add_coupling</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">u1</em>, <em class="sig-param">op1</em>, <em class="sig-param">u2</em>, <em class="sig-param">op2</em>, <em class="sig-param">dx</em>, <em class="sig-param">op_string=None</em>, <em class="sig-param">str_on_first=True</em>, <em class="sig-param">raise_op2_left=False</em>, <em class="sig-param">category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP1 * OP2\)</span>, where
<code class="docutils literal notranslate"><span class="pre">OP1</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u1].get_op(op1)</span></code> acts on the site <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u1)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP2</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u2].get_op(op2)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+dx[0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+dx[dim-1],</span> <span class="pre">u2)</span></code>.
Possible combinations <code class="docutils literal notranslate"><span class="pre">x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}</span></code> are determined from the boundary conditions
in <a class="reference internal" href="tenpy.models.lattice.Lattice.html#tenpy.models.lattice.Lattice.possible_couplings" title="tenpy.models.lattice.Lattice.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a>.</p>
<p>The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower
left corner of the hypercube containing the involved sites <span class="math notranslate nohighlight">\(\vec{x}\)</span> and
<span class="math notranslate nohighlight">\(\vec{x}+\vec{dx}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t (re)build the MPO.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.4.0: </span>The arguments <cite>str_on_first</cite> and <cite>raise_op2_left</cite> will be removed in version 1.0.0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">scalar | array</span></dt><dd><p>Prefactor of the coupling. May vary spatially (see above). If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u1</strong><span class="classifier">int</span></dt><dd><p>Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>op1</strong><span class="classifier">str</span></dt><dd><p>Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>u2</strong><span class="classifier">int</span></dt><dd><p>Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>op2</strong><span class="classifier">str</span></dt><dd><p>Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>dx</strong><span class="classifier">iterable of int</span></dt><dd><p>Translation vector (of the unit cell) between OP1 and OP2.
For a 1D lattice, a single int is also fine.</p>
</dd>
<dt><strong>op_string</strong><span class="classifier">str | None</span></dt><dd><p>Name of an operator to be used between the OP1 and OP2 sites.
Typical use case is the phase for a Jordan-Wigner transformation.
The operator should be defined on all sites in the unit cell.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed, using
<a class="reference internal" href="tenpy.networks.site.Site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>.</p>
</dd>
<dt><strong>str_on_first</strong><span class="classifier">bool</span></dt><dd><p>Whether the provided <cite>op_string</cite> should also act on the first site.
This option should be chosen as <code class="docutils literal notranslate"><span class="pre">True</span></code> for Jordan-Wigner strings.
When handling Jordan-Wigner strings we need to extend the <cite>op_string</cite> to also act on
the ‘left’, first site (in the sense of the MPS ordering of the sites given by the
lattice). In this case, there is a well-defined ordering of the operators in the
physical sense (i.e. which of <cite>op1</cite> or <cite>op2</cite> acts first on a given state).
We follow the convention that <cite>op2</cite> acts first (in the physical sense),
independent of the MPS ordering.
Deprecated.</p>
</dd>
<dt><strong>raise_op2_left</strong><span class="classifier">bool</span></dt><dd><p>Raise an error when <cite>op2</cite> appears left of <cite>op1</cite>
(in the sense of the MPS ordering given by the lattice). Deprecated.</p>
</dd>
<dt><strong>category</strong><span class="classifier">str</span></dt><dd><p>Descriptive name used as key for <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>.
Defaults to a string of the form <code class="docutils literal notranslate"><span class="pre">&quot;{op1}_i</span> <span class="pre">{op2}_j&quot;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>When initializing a model, you can add a term <span class="math notranslate nohighlight">\(J \sum_{&lt;i,j&gt;} S^z_i S^z_j\)</span>
on all nearest-neighbor bonds of the lattice like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>The strength can be an array, which get’s tiled to the correct shape.
For example, in a 1D <a class="reference internal" href="tenpy.models.lattice.Chain.html#tenpy.models.lattice.Chain" title="tenpy.models.lattice.Chain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chain</span></code></a> with an even number of sites and
periodic (or infinite) boundary conditions, you can add alternating strong and weak
couplings with a line like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>To add the hermitian conjugate, e.g. for a hopping term, you should add it in the opposite
direction <code class="docutils literal notranslate"><span class="pre">-dx</span></code>, complex conjugate the strength, and take the hermitian conjugate
of the operators in swapped order (including a swap of <cite>u1</cite> &lt;-&gt; <cite>u2</cite>).
For spin-less fermions (<a class="reference internal" href="tenpy.networks.site.FermionSite.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>), this would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># hopping strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># h.c.</span>
</pre></div>
</div>
<p>With spin-full fermions (<code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHalfFermions</span></code>), it could be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cdu&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>  <span class="c1"># Cdagger_up C_down</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cdd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># h.c. Cdagger_down C_up</span>
</pre></div>
</div>
<p>Note that the Jordan-Wigner strings are figured out automatically!</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_coupling_term">
<code class="sig-name descname">add_coupling_term</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">op_i</em>, <em class="sig-param">op_j</em>, <em class="sig-param">op_string='Id'</em>, <em class="sig-param">category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a two-site coupling term on given MPS sites.</p>
<p>Wrapper for <code class="docutils literal notranslate"><span class="pre">self.coupling_terms[category].add_coupling_term(...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">float</span></dt><dd><p>The strength of the coupling term.</p>
</dd>
<dt><strong>i, j</strong><span class="classifier">int</span></dt><dd><p>The MPS indices of the two sites on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>  and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, i.e., <cite>op_i</cite> acts “left” of <cite>op_j</cite>.
If j &gt;= N_sites, it indicates couplings between unit cells of an infinite MPS.</p>
</dd>
<dt><strong>op1, op2</strong><span class="classifier">str</span></dt><dd><p>Names of the involved operators.</p>
</dd>
<dt><strong>op_string</strong><span class="classifier">str</span></dt><dd><p>The operator to be inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
<dt><strong>category</strong><span class="classifier">str</span></dt><dd><p>Descriptive name used as key for <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>.
Defaults to a string of the form <code class="docutils literal notranslate"><span class="pre">&quot;{op1}_i</span> <span class="pre">{op2}_j&quot;</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_onsite">
<code class="sig-name descname">add_onsite</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">u</em>, <em class="sig-param">opname</em>, <em class="sig-param">category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Add onsite terms to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>.</p>
<p>Adds a term <span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[x_0, ..., x_{dim-1}] * OP\)</span>,
where the operator <code class="docutils literal notranslate"><span class="pre">OP=lat.unit_cell[u].get_op(opname)</span></code>
acts on the site given by a lattice index <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u)</span></code>,
to the represented Hamiltonian.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>; doesn’t rebuild the MPO.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">scalar | array</span></dt><dd><p>Prefactor of the onsite term. May vary spatially. If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u</strong><span class="classifier">int</span></dt><dd><p>Picks a <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code> out of the unit cell.</p>
</dd>
<dt><strong>opname</strong><span class="classifier">str</span></dt><dd><p>valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>.</p>
</dd>
<dt><strong>category</strong><span class="classifier">str</span></dt><dd><p>Descriptive name used as key for <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>. Defaults to <cite>opname</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.add_onsite_term">
<code class="sig-name descname">add_onsite_term</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">i</em>, <em class="sig-param">op</em>, <em class="sig-param">category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.add_onsite_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an onsite term on a given MPS site.</p>
<p>Wrapper for <code class="docutils literal notranslate"><span class="pre">self.onsite_terms[category].add_onsite_term(...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">float</span></dt><dd><p>The strength of the term.</p>
</dd>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>The MPS index of the site on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">L</span></code>.</p>
</dd>
<dt><strong>op</strong><span class="classifier">str</span></dt><dd><p>Name of the involved operator.</p>
</dd>
<dt><strong>category</strong><span class="classifier">str</span></dt><dd><p>Descriptive name used as key for <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>. Defaults to <cite>op</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.all_coupling_terms">
<code class="sig-name descname">all_coupling_terms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.all_coupling_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of all <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.all_onsite_terms">
<code class="sig-name descname">all_onsite_terms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.all_onsite_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of all <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.calc_H_MPO">
<code class="sig-name descname">calc_H_MPO</code><span class="sig-paren">(</span><em class="sig-param">tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.calc_H_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate MPO representation of the Hamiltonian.</p>
<p>Uses <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> to build an MPO graph
(and then an MPO).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tol_zero</strong><span class="classifier">float</span></dt><dd><p>Prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>H_MPO</strong><span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.MPO.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt><dd><p>MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.calc_H_bond">
<code class="sig-name descname">calc_H_bond</code><span class="sig-paren">(</span><em class="sig-param">tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.calc_H_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate <cite>H_bond</cite> from <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tol_zero</strong><span class="classifier">float</span></dt><dd><p>prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>H_bond</strong><span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.Array.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt><dd><p>Bond terms as required by the constructor of <a class="reference internal" href="tenpy.models.model.NearestNeighborModel.html#tenpy.models.model.NearestNeighborModel" title="tenpy.models.model.NearestNeighborModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code></a>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong><span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.calc_H_onsite">
<code class="sig-name descname">calc_H_onsite</code><span class="sig-paren">(</span><em class="sig-param">tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.calc_H_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.4.0: </span>This function will be removed in 1.0.0.
Replace calls to this function by
<code class="docutils literal notranslate"><span class="pre">self.all_onsite_terms().remove_zeros(tol_zero).to_Arrays(self.lat.mps_sites())</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tol_zero</strong><span class="classifier">float</span></dt><dd><p>prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>H_onsite</strong><span class="classifier">list of npc.Array</span></dt><dd><p>onsite terms of the Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux">
<code class="sig-name descname">coupling_strength_add_ext_flux</code><span class="sig-paren">(</span><em class="sig-param">strength</em>, <em class="sig-param">dx</em>, <em class="sig-param">phase</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.coupling_strength_add_ext_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an external flux to the coupling strength.</p>
<p>When performing DMRG on a “cylinder” geometry, it might be useful to put an “external flux”
through the cylinder. This means that a particle hopping around the cylinder should
pick up a phase given by the external flux <a class="reference internal" href="../literature.html#resta1997" id="id1"><span>[Resta1997]</span></a>.
This is also called “twisted boundary conditions” in literature.
This function adds a complex phase to the <cite>strength</cite> array on some bonds, such that
particles hopping in positive direction around the cylinder pick up <cite>exp(+i phase)</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For the sign of <cite>phase</cite> it is important that you consistently use the creation
operator as <cite>op1</cite> and the annihilation operator as <cite>op2</cite> in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">scalar | array</span></dt><dd><p>The strength to be used in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>, when no external flux would be
present.</p>
</dd>
<dt><strong>dx</strong><span class="classifier">iterable of int</span></dt><dd><p>Translation vector (of the unit cell) between <cite>op1</cite> and <cite>op2</cite> in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</dd>
<dt><strong>phase</strong><span class="classifier">iterable of float</span></dt><dd><p>The phase of the external flux for hopping in each direction of the lattice.
E.g., if you want flux through the cylinder on which you have an infinite MPS,
you should give <code class="docutils literal notranslate"><span class="pre">phase=[0,</span> <span class="pre">phi]</span></code> souch that particles pick up a phase <cite>phi</cite> when
hopping around the cylinder.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>strength</strong><span class="classifier">complex array</span></dt><dd><p>The strength array to be used as <cite>strength</cite> in <a class="reference internal" href="#tenpy.models.model.MultiCouplingModel.add_coupling" title="tenpy.models.model.MultiCouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
with the given <cite>dx</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Let’s say you have an infinite MPS on a cylinder, and want to add nearest-neighbor
hopping of fermions with the <a class="reference internal" href="tenpy.networks.site.FermionSite.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>.
The cylinder axis is the <cite>x</cite>-direction of the lattice, so to put a flux through the
cylinder, you want particles hopping <em>around</em> the cylinder to pick up a phase <cite>phi</cite>
given by the external flux.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strength</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># hopping strength without external flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span> <span class="c1"># determines the external flux strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strength_with_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_strength_add_ext_flux</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.group_sites">
<code class="sig-name descname">group_sites</code><span class="sig-paren">(</span><em class="sig-param">n=2</em>, <em class="sig-param">grouped_sites=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong><span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt><dd><p>The sites grouped together.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>grouped_sites</strong><span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.GroupedSite.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt><dd><p>The sites grouped together.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.model.MultiCouplingModel.test_sanity">
<code class="sig-name descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.model.MultiCouplingModel.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.models.model.Model.html"
                        title="previous chapter">Model</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.models.model.NearestNeighborModel.html"
                        title="next chapter">NearestNeighborModel</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference.html">Tenpy Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tenpy.algorithms.html">algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.linalg.html">linalg</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.models.html">models</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.lattice.html">lattice</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.models.model.html">model</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.tf_ising.html">tf_ising</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.xxz_chain.html">xxz_chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.spins.html">spins</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.spins_nnn.html">spins_nnn</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.fermions_spinless.html">fermions_spinless</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.hubbard.html">hubbard</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.hofstadter.html">hofstadter</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.haldane.html">haldane</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.models.toric_code.html">toric_code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.networks.html">networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.tools.html">tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.version.html">version</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.models.model.NearestNeighborModel.html" title="NearestNeighborModel"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.models.model.Model.html" title="Model"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../reference.html" >Tenpy Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.models.html" >models</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="tenpy.models.model.html" >model</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Sep 26, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>