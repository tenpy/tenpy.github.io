
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tenpy.models.toric_code module &#8212; TeNPy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="shortcut icon" href="../_static/logo.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="tenpy.models.xxz_chain module" href="tenpy.models.xxz_chain.html" />
    <link rel="prev" title="tenpy.models.tf_ising module" href="tenpy.models.tf_ising.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.models.xxz_chain.html" title="tenpy.models.xxz_chain module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tenpy.models.tf_ising.html" title="tenpy.models.tf_ising module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.models.html" accesskey="U">tenpy.models package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-tenpy.models.toric_code">
<span id="tenpy-models-toric-code-module"></span><h1>tenpy.models.toric_code module<a class="headerlink" href="#module-tenpy.models.toric_code" title="Permalink to this headline">¶</a></h1>
<p>Kitaev’s exactly solvable toric code model.</p>
<p>As we put the model on a cylinder, the name “toric code” is a bit misleading,
but it is the established name for this model…</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">switch to using the CouplingMPOModel</p>
</div>
<dl class="class">
<dt id="tenpy.models.toric_code.DualSquare">
<em class="property">class </em><code class="descclassname">tenpy.models.toric_code.</code><code class="descname">DualSquare</code><span class="sig-paren">(</span><em>Lx</em>, <em>Ly</em>, <em>sites</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/toric_code.html#DualSquare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.toric_code.DualSquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice" title="tenpy.models.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.lattice.Lattice</span></code></a></p>
<p>The dual lattice of the square lattice (again square).</p>
<p>The sites in this lattice correspond to the vertical and horizontal (nearest neighbor) bonds
of a common <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Square" title="tenpy.models.lattice.Square"><code class="xref py py-class docutils literal notranslate"><span class="pre">Square</span></code></a> lattice with the same dimensions <cite>Lx, Ly</cite>.</p>
<img alt="../_images/DualSquare.png" src="../_images/DualSquare.png" />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Lx, Ly</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimensions of the original lattice. This lattice has <cite>2*Lx*Ly</cite> sites.</p>
</dd>
<dt><strong>sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site" title="tenpy.networks.site.Site"><code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code></a></span></dt>
<dd><p class="first last">The sites for the horizontal (first entry) and vertical (second entry) bonds.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Additional keyword arguments given to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code>.
<cite>basis</cite>, <cite>pos</cite> and <cite>[[next_]next_]nearest_neighbors</cite> are set accordingly.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.dim" title="tenpy.models.toric_code.DualSquare.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a></dt>
<dd><p class="first last">The dimension of the lattice.</p>
</dd>
<dt><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.order" title="tenpy.models.toric_code.DualSquare.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a></dt>
<dd><p class="first last">Defines an ordering of the lattice sites, thus mapping the lattice to a 1D chain.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.lat2mps_idx" title="tenpy.models.toric_code.DualSquare.lat2mps_idx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lat2mps_idx</span></code></a>(lat_idx)</td>
<td>translate lattice indices <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{D-1},</span> <span class="pre">u)</span></code> to MPS index <cite>i</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps2lat_idx" title="tenpy.models.toric_code.DualSquare.mps2lat_idx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mps2lat_idx</span></code></a>(i)</td>
<td>translate MPS index <cite>i</cite> to lattice indices <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{D_1},</span> <span class="pre">u)</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps2lat_values" title="tenpy.models.toric_code.DualSquare.mps2lat_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mps2lat_values</span></code></a>(A[,&nbsp;axes,&nbsp;u])</td>
<td>reshape/reorder A to replace an MPS index by lattice indices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_idx_fix_u" title="tenpy.models.toric_code.DualSquare.mps_idx_fix_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mps_idx_fix_u</span></code></a>([u])</td>
<td>return an index array of MPS indices for which the site within the unit cell is <cite>u</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_lat_idx_fix_u" title="tenpy.models.toric_code.DualSquare.mps_lat_idx_fix_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mps_lat_idx_fix_u</span></code></a>([u])</td>
<td>Similar as <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_idx_fix_u" title="tenpy.models.toric_code.DualSquare.mps_idx_fix_u"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps_idx_fix_u()</span></code></a>, but return also the corresponding lattice indices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_sites" title="tenpy.models.toric_code.DualSquare.mps_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mps_sites</span></code></a>()</td>
<td>Return a list [self.site(i) for i in range(self.N_sites)].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.number_nearest_neighbors" title="tenpy.models.toric_code.DualSquare.number_nearest_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_nearest_neighbors</span></code></a>([u])</td>
<td>Count the number of nearest neighbors for a site in the bulk.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.number_next_nearest_neighbors" title="tenpy.models.toric_code.DualSquare.number_next_nearest_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_next_nearest_neighbors</span></code></a>([u])</td>
<td>Count the number of next nearest neighbors for a site in the bulk.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.ordering" title="tenpy.models.toric_code.DualSquare.ordering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ordering</span></code></a>(order)</td>
<td>Provide possible orderings of the <cite>N</cite> lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.plot_basis" title="tenpy.models.toric_code.DualSquare.plot_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_basis</span></code></a>(ax,&nbsp;**kwargs)</td>
<td>Plot arrows indicating the basis vectors of the lattice</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.plot_bc_identified" title="tenpy.models.toric_code.DualSquare.plot_bc_identified"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_bc_identified</span></code></a>(ax[,&nbsp;direction,&nbsp;shift])</td>
<td>Mark two sites indified by periodic boundary conditions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.plot_coupling" title="tenpy.models.toric_code.DualSquare.plot_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_coupling</span></code></a>(ax[,&nbsp;coupling])</td>
<td>Plot lines connecting nearest neighbors of the lattice.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.plot_order" title="tenpy.models.toric_code.DualSquare.plot_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_order</span></code></a>(ax[,&nbsp;order,&nbsp;textkwargs])</td>
<td>Plot a line connecting sites in the specified “order” and text labels enumerating them.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.plot_sites" title="tenpy.models.toric_code.DualSquare.plot_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_sites</span></code></a>(ax[,&nbsp;markers])</td>
<td>Plot the sites of the lattice with markers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.position" title="tenpy.models.toric_code.DualSquare.position"><code class="xref py py-obj docutils literal notranslate"><span class="pre">position</span></code></a>(lat_idx)</td>
<td>return ‘space’ position of one or multiple sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.possible_couplings" title="tenpy.models.toric_code.DualSquare.possible_couplings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">possible_couplings</span></code></a>(u1,&nbsp;u2,&nbsp;dx)</td>
<td>Find possible MPS indices for two-site couplings.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.possible_multi_couplings" title="tenpy.models.toric_code.DualSquare.possible_multi_couplings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">possible_multi_couplings</span></code></a>(u0,&nbsp;other_us,&nbsp;dx)</td>
<td>Generalization of <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.possible_couplings" title="tenpy.models.toric_code.DualSquare.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a> to couplings with more than 2 sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.site" title="tenpy.models.toric_code.DualSquare.site"><code class="xref py py-obj docutils literal notranslate"><span class="pre">site</span></code></a>(i)</td>
<td>return <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> instance corresponding to an MPS index <cite>i</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.test_sanity" title="tenpy.models.toric_code.DualSquare.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="tenpy.models.toric_code.DualSquare.dim">
<code class="descname">dim</code><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the lattice.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.lat2mps_idx">
<code class="descname">lat2mps_idx</code><span class="sig-paren">(</span><em>lat_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.lat2mps_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>translate lattice indices <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{D-1},</span> <span class="pre">u)</span></code> to MPS index <cite>i</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.mps2lat_idx">
<code class="descname">mps2lat_idx</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.mps2lat_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>translate MPS index <cite>i</cite> to lattice indices <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{D_1},</span> <span class="pre">u)</span></code></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.mps2lat_values">
<code class="descname">mps2lat_values</code><span class="sig-paren">(</span><em>A</em>, <em>axes=0</em>, <em>u=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.mps2lat_values" title="Permalink to this definition">¶</a></dt>
<dd><p>reshape/reorder A to replace an MPS index by lattice indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">some values. Must have <code class="docutils literal notranslate"><span class="pre">A.shape[axes]</span> <span class="pre">=</span> <span class="pre">self.N_sites</span></code> if <cite>u</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, or
<code class="docutils literal notranslate"><span class="pre">A.shape[axes]</span> <span class="pre">=</span> <span class="pre">self.N_cells</span></code> if <cite>u</cite> is an int.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(iterable of) int</span></dt>
<dd><p class="first last">chooses the axis which should be replaced.</p>
</dd>
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="docutils literal notranslate"><span class="pre">None</span></code> | int</span></dt>
<dd><p class="first last">Optionally choose a subset of MPS indices present in the axes of <cite>A</cite>, namely the
indices corresponding to <code class="docutils literal notranslate"><span class="pre">self.unit_cell[u]</span></code>, as returned by <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_idx_fix_u" title="tenpy.models.toric_code.DualSquare.mps_idx_fix_u"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps_idx_fix_u()</span></code></a>.
The resulting array will not have the additional dimension(s) of <cite>u</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res_A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">reshaped and reordered verions of A. Such that an MPS index <cite>j</cite> is replaced by
<code class="docutils literal notranslate"><span class="pre">res_A[...,</span> <span class="pre">self.order,</span> <span class="pre">...]</span> <span class="pre">=</span> <span class="pre">A[...,</span> <span class="pre">np.arange(self.N_sites),</span> <span class="pre">...]</span></code></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Say you measure expection values of an onsite term for an MPS, which gives you an 1D array
<cite>A</cite>, where <cite>A[i]</cite> is the expectation value of the site given by <code class="docutils literal notranslate"><span class="pre">self.mps2lat_idx(i)</span></code>.
Then this function gives you the expectation values ordered by the lattice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(10, 3, 2) (60,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_res</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">mps2lat_values</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_res</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_res</span><span class="p">[</span><span class="n">lat</span><span class="o">.</span><span class="n">mps2lat_idx</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span> <span class="o">==</span> <span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you have a correlation function <code class="docutils literal notranslate"><span class="pre">C[i,</span> <span class="pre">j]</span></code>, it gets just slightly more complicated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(10, 3, 2) (60, 60)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span><span class="o">.</span><span class="n">mps2lat_values</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3, 2, 10, 3, 2)</span>
</pre></div>
</div>
<p>If the unit cell consists of different physical sites, an onsite operator might be defined
only on one of the sites in the unit cell. Then you can use <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_idx_fix_u" title="tenpy.models.toric_code.DualSquare.mps_idx_fix_u"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps_idx_fix_u()</span></code></a> to get
the indices of sites it is defined on, measure the operator on these sites, and use
the argument <cite>u</cite> of this function. say y</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx_subset</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">mps_idx_fix_u</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_u</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx_subset</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_u_res</span> <span class="o">=</span> <span class="n">lat</span><span class="o">.</span><span class="n">mps2lat_values</span><span class="p">(</span><span class="n">A_u</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_u_res</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">A_res</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">A_u_res</span><span class="p">[:,</span> <span class="p">:])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">make sure this function is used for expectation values…</p>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.mps_idx_fix_u">
<code class="descname">mps_idx_fix_u</code><span class="sig-paren">(</span><em>u=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.mps_idx_fix_u" title="Permalink to this definition">¶</a></dt>
<dd><p>return an index array of MPS indices for which the site within the unit cell is <cite>u</cite>.</p>
<p>If you have multiple sites in your unit-cell, an onsite operator is in general not defined
for all sites. This functions returns an index array of the mps indices which belong to
sites given by <code class="docutils literal notranslate"><span class="pre">self.unit_cell[u]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | int</span></dt>
<dd><p class="first last">Selects a site of the unit cell. <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) means all sites.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mps_idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">MPS indices for which <code class="docutils literal notranslate"><span class="pre">self.site(i)</span> <span class="pre">is</span> <span class="pre">self.unit_cell[u]</span></code>. Ordered ascending.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.mps_lat_idx_fix_u">
<code class="descname">mps_lat_idx_fix_u</code><span class="sig-paren">(</span><em>u=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.mps_lat_idx_fix_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar as <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.mps_idx_fix_u" title="tenpy.models.toric_code.DualSquare.mps_idx_fix_u"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mps_idx_fix_u()</span></code></a>, but return also the corresponding lattice indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | int</span></dt>
<dd><p class="first last">Selects a site of the unit cell. <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) means all sites.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mps_idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">MPS indices <cite>i</cite> for which <code class="docutils literal notranslate"><span class="pre">self.site(i)</span> <span class="pre">is</span> <span class="pre">self.unit_cell[u]</span></code>.</p>
</dd>
<dt><strong>lat_idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">The row <cite>j</cite> contains the lattice index (without <cite>u</cite>) corresponding to <code class="docutils literal notranslate"><span class="pre">mps_idx[j]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.mps_sites">
<code class="descname">mps_sites</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.mps_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list [self.site(i) for i in range(self.N_sites)].</p>
<p>This should be used for <cite>sites</cite> of 1D tensor networks (MPS, MPO,…).</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.number_nearest_neighbors">
<code class="descname">number_nearest_neighbors</code><span class="sig-paren">(</span><em>u=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.number_nearest_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of nearest neighbors for a site in the bulk.</p>
<p>Requires <code class="xref py py-attr docutils literal notranslate"><span class="pre">nearest_neighbors</span></code> to be set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Specifies the site in the unit cell.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>number_NN</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of nearest neighbors of the <cite>u</cite>-th site in the unit cell in the bulk of the
lattice. Note that it might be different at the edges of the lattice for open boundary
conditions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.number_next_nearest_neighbors">
<code class="descname">number_next_nearest_neighbors</code><span class="sig-paren">(</span><em>u=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.number_next_nearest_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of next nearest neighbors for a site in the bulk.</p>
<p>Requires <code class="xref py py-attr docutils literal notranslate"><span class="pre">next_nearest_neighbors</span></code> to be set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Specifies the site in the unit cell.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>number_NNN</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of next nearest neighbors of the <cite>u</cite>-th site in the unit cell in the bulk of the
lattice. Note that it might be different at the edges of the lattice for open boundary
conditions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tenpy.models.toric_code.DualSquare.order">
<code class="descname">order</code><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an ordering of the lattice sites, thus mapping the lattice to a 1D chain.</p>
<p>This order defines how an MPS/MPO winds through the lattice.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.ordering">
<code class="descname">ordering</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.ordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide possible orderings of the <cite>N</cite> lattice sites.</p>
<p>This function can be overwritten by derived lattices to define additional orderings.
The following orders are defined in this method:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="36%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><cite>order</cite></th>
<th class="head">equivalent <cite>priority</cite></th>
<th class="head">equivalent <code class="docutils literal notranslate"><span class="pre">snake_winding</span></code></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'Cstyle'</span></code></td>
<td>(0, 1, …, dim-1, dim)</td>
<td>(False, …, False, False)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'default'</span></code></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'snake'</span></code></td>
<td>(0, 1, …, dim-1, dim)</td>
<td>(True, …, True, True)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'snakeCstyle'</span></code></td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'Fstyle'</span></code></td>
<td>(dim-1, …, 1, 0, dim)</td>
<td>(False, …, False, False)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'snakeFstyle'</span></code></td>
<td>(dim-1, …, 1, 0, dim)</td>
<td>(False, …, False, False)</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | <code class="docutils literal notranslate"><span class="pre">('standard',</span> <span class="pre">snake_winding,</span> <span class="pre">priority)</span></code> | <code class="docutils literal notranslate"><span class="pre">('grouped',</span> <span class="pre">groups)</span></code></span></dt>
<dd><p class="first last">Specifies the desired ordering using one of the strings of the above tables.
Alternatively, an ordering is specified by a tuple with first entry specifying a
function, <code class="docutils literal notranslate"><span class="pre">'standard'</span></code> for <code class="xref py py-func docutils literal notranslate"><span class="pre">get_order()</span></code> and <code class="docutils literal notranslate"><span class="pre">'grouped'</span></code> for
<code class="xref py py-func docutils literal notranslate"><span class="pre">get_order_grouped()</span></code>, and other arguments in the tuple as specified in the
documentation of these functions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N, D+1), dtype np.intp</span></dt>
<dd><p class="first last">the order to be used for <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.order" title="tenpy.models.toric_code.DualSquare.order"><code class="xref py py-attr docutils literal notranslate"><span class="pre">order</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">get_order()</span></code></dt>
<dd>generates the <cite>order</cite> from equivalent <cite>priority</cite> and <cite>snake_winding</cite>.</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">get_order_grouped()</span></code></dt>
<dd>variant of <cite>get_order</cite>.</dd>
<dt><a class="reference internal" href="#tenpy.models.toric_code.DualSquare.plot_order" title="tenpy.models.toric_code.DualSquare.plot_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_order()</span></code></a></dt>
<dd>visualizes the resulting <cite>order</cite>.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.plot_basis">
<code class="descname">plot_basis</code><span class="sig-paren">(</span><em>ax</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.plot_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot arrows indicating the basis vectors of the lattice</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Keyword arguments specifying the “arrowprops” of <code class="docutils literal notranslate"><span class="pre">ax.annotate</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.plot_bc_identified">
<code class="descname">plot_bc_identified</code><span class="sig-paren">(</span><em>ax</em>, <em>direction=-1</em>, <em>shift=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.plot_bc_identified" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark two sites indified by periodic boundary conditions</p>
<p>Works only for lattice with a 2-dimensional basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>direction</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The direction of the lattice along which we should mark the idenitified sites.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, mark it along all directions with periodic boundary conditions.</p>
</dd>
<dt><strong>shift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | np.ndarray</span></dt>
<dd><p class="first last">The origin starting from where we mark the identified sites.
Defaults to the first entry of <code class="xref py py-attr docutils literal notranslate"><span class="pre">unit_cell_positions</span></code>.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Keyword arguments for the used <code class="docutils literal notranslate"><span class="pre">ax.plot</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.plot_coupling">
<code class="descname">plot_coupling</code><span class="sig-paren">(</span><em>ax</em>, <em>coupling=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.plot_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot lines connecting nearest neighbors of the lattice.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>coupling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of (u1, u2, dx)</span></dt>
<dd><p class="first last">By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), use :attr:<code class="docutils literal notranslate"><span class="pre">nearest_neighbors</span></code>.
Specifies the connections to be plotted; iteating over lattice indices <cite>(i0, i1, …)</cite>,
we plot a connection from the site <code class="docutils literal notranslate"><span class="pre">(i0,</span> <span class="pre">i1,</span> <span class="pre">...,</span> <span class="pre">u1)</span></code> to the site
<code class="docutils literal notranslate"><span class="pre">(i0+dx[0],</span> <span class="pre">i1+dx[1],</span> <span class="pre">...,</span> <span class="pre">u2)</span></code>, taking into account the boundary conditions.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Further keyword arguments given to <code class="docutils literal notranslate"><span class="pre">ax.plot()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.plot_order">
<code class="descname">plot_order</code><span class="sig-paren">(</span><em>ax</em>, <em>order=None</em>, <em>textkwargs={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.plot_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a line connecting sites in the specified “order” and text labels enumerating them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | 2D array (self.N_sites, self.dim+1)</span></dt>
<dd><p class="first last">The order as returned by <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.ordering" title="tenpy.models.toric_code.DualSquare.ordering"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ordering()</span></code></a>; by default (<code class="docutils literal notranslate"><span class="pre">None</span></code>) use <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.order" title="tenpy.models.toric_code.DualSquare.order"><code class="xref py py-attr docutils literal notranslate"><span class="pre">order</span></code></a>.</p>
</dd>
<dt><strong>textkwargs: ``None`` | dict</strong></dt>
<dd><p class="first last">If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, we add text labels enumerating the sites in the plot. The dictionary
can contain keyword arguments for <code class="docutils literal notranslate"><span class="pre">ax.text()</span></code>.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Further keyword arguments given to <code class="docutils literal notranslate"><span class="pre">ax.plot()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.plot_sites">
<code class="descname">plot_sites</code><span class="sig-paren">(</span><em>ax, markers=['o', '^', 's', 'p', 'h', 'D'], **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.plot_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the sites of the lattice with markers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>markers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of values for the keywork <cite>marker</cite> of <code class="docutils literal notranslate"><span class="pre">ax.plot()</span></code> to distinguish the different
sites in the unit cell, a site <cite>u</cite> in the unit cell is plotted with a marker
<code class="docutils literal notranslate"><span class="pre">markers[u</span> <span class="pre">%</span> <span class="pre">len(markers)]</span></code>.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Further keyword arguments given to <code class="docutils literal notranslate"><span class="pre">ax.plot()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>lat_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.position" title="Permalink to this definition">¶</a></dt>
<dd><p>return ‘space’ position of one or multiple sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>lat_idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, <code class="docutils literal notranslate"><span class="pre">(...</span> <span class="pre">,</span> <span class="pre">dim+1)</span></code></span></dt>
<dd><p class="first last">Lattice indices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, <code class="docutils literal notranslate"><span class="pre">(...,</span> <span class="pre">dim)</span></code></span></dt>
<dd><p class="first last">The position of the lattice sites specified by <cite>lat_idx</cite> in real-space.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.possible_couplings">
<code class="descname">possible_couplings</code><span class="sig-paren">(</span><em>u1</em>, <em>u2</em>, <em>dx</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.possible_couplings" title="Permalink to this definition">¶</a></dt>
<dd><p>Find possible MPS indices for two-site couplings.</p>
<p>For periodic boundary conditions (<code class="docutils literal notranslate"><span class="pre">bc[a]</span> <span class="pre">==</span> <span class="pre">False</span></code>)
the index <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is taken modulo <code class="docutils literal notranslate"><span class="pre">Ls[a]</span></code> and runs through <code class="docutils literal notranslate"><span class="pre">range(Ls[a])</span></code>.
For open boundary conditions, <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is limited to <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a</span> <span class="pre">&lt;</span> <span class="pre">Ls[a]</span></code> and
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a+dx[a]</span> <span class="pre">&lt;</span> <span class="pre">lat.Ls[a]</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>u1, u2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Indices within the unit cell; the <cite>u1</cite> and <cite>u2</cite> of
<a class="reference internal" href="tenpy.models.model.html#tenpy.models.model.CouplingModel.add_coupling" title="tenpy.models.model.CouplingModel.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a></p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Length <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.dim" title="tenpy.models.toric_code.DualSquare.dim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code></a>. The translation in terms of basis vectors for the coupling.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mps1, mps2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">For each possible two-site coupling the MPS indices for the <cite>u1</cite> and <cite>u2</cite>.
MPS indices for to be connected by the coupling.</p>
</dd>
<dt><strong>lat_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape = (len(mps1), dim)</span></dt>
<dd><p class="first last">Corresponding indices in the lattice. The entries are in the “bottom left corner”.</p>
</dd>
<dt><strong>coupling_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span></dt>
<dd><p class="first last">Len <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.dim" title="tenpy.models.toric_code.DualSquare.dim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dim</span></code></a>. The correct shape for an array specifying the coupling strength.
<cite>lat_indices</cite> has only rows within this shape.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.possible_multi_couplings">
<code class="descname">possible_multi_couplings</code><span class="sig-paren">(</span><em>u0</em>, <em>other_us</em>, <em>dx</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.possible_multi_couplings" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalization of <a class="reference internal" href="#tenpy.models.toric_code.DualSquare.possible_couplings" title="tenpy.models.toric_code.DualSquare.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a> to couplings with more than 2 sites.</p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.site">
<code class="descname">site</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.site" title="Permalink to this definition">¶</a></dt>
<dd><p>return <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> instance corresponding to an MPS index <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.DualSquare.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.DualSquare.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tenpy.models.toric_code.ToricCode">
<em class="property">class </em><code class="descclassname">tenpy.models.toric_code.</code><code class="descname">ToricCode</code><span class="sig-paren">(</span><em>model_params</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tenpy/models/toric_code.html#ToricCode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tenpy.models.toric_code.ToricCode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tenpy.models.model.html#tenpy.models.model.MultiCouplingModel" title="tenpy.models.model.MultiCouplingModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.MultiCouplingModel</span></code></a>, <a class="reference internal" href="tenpy.models.model.html#tenpy.models.model.MPOModel" title="tenpy.models.model.MPOModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">tenpy.models.model.MPOModel</span></code></a></p>
<p>Spin-S sites coupled by nearest neighbour interactions.</p>
<p>The Hamiltonian reads:</p>
<div class="math notranslate nohighlight">
\[H = - \mathtt{Jv} \sum_{vertices v} \prod_{i \in v}  \sigma^x_i
    - \mathtt{Jp} \sum_{plaquettes p} \prod_{i \in p} \sigma^z_i\]</div>
<p>(Note that this are Pauli matrices, not spin-1/2 operators.)
All parameters are collected in a single dictionary <cite>model_params</cite> and read out with
<a class="reference internal" href="tenpy.tools.params.html#tenpy.tools.params.get_parameter" title="tenpy.tools.params.get_parameter"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_parameter()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Lx, Ly</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of the lattice, number of plaquettes around the cylinder.</p>
</dd>
<dt><strong>conserve</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘parity’ | None</span></dt>
<dd><p class="first last">What should be conserved. See <code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHalfSite</span></code>.</p>
</dd>
<dt><strong>Jc, Jp: float | array</strong></dt>
<dd><p class="first last">Couplings as defined for the Hamiltonian above.</p>
</dd>
<dt><strong>bc_MPS</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘finite’ | ‘infinte’}</span></dt>
<dd><p class="first last">MPS boundary conditions. Coupling boundary conditions are chosen appropriately.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The order of the lattice sites in the lattice, see <a class="reference internal" href="#tenpy.models.toric_code.DualSquare" title="tenpy.models.toric_code.DualSquare"><code class="xref py py-class docutils literal notranslate"><span class="pre">DualSquare</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_coupling" title="tenpy.models.toric_code.ToricCode.add_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling</span></code></a>(strength,&nbsp;u1,&nbsp;op1,&nbsp;u2,&nbsp;op2,&nbsp;dx)</td>
<td>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_coupling_term" title="tenpy.models.toric_code.ToricCode.add_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_coupling_term</span></code></a>(strength,&nbsp;i,&nbsp;j,&nbsp;op_i,&nbsp;op_j)</td>
<td>Add a two-site coupling term on given MPS sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_multi_coupling" title="tenpy.models.toric_code.ToricCode.add_multi_coupling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_multi_coupling</span></code></a>(strength,&nbsp;u0,&nbsp;op0,&nbsp;other_ops)</td>
<td>Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_multi_coupling_term" title="tenpy.models.toric_code.ToricCode.add_multi_coupling_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_multi_coupling_term</span></code></a>(strength,&nbsp;ijkl,&nbsp;…)</td>
<td>Add a multi-site coupling term on given MPS sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_onsite" title="tenpy.models.toric_code.ToricCode.add_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite</span></code></a>(strength,&nbsp;u,&nbsp;opname)</td>
<td>Add onsite terms to self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_onsite_term" title="tenpy.models.toric_code.ToricCode.add_onsite_term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_onsite_term</span></code></a>(strength,&nbsp;i,&nbsp;op)</td>
<td>Add a onsite term on a given MPS site.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.calc_H_MPO" title="tenpy.models.toric_code.ToricCode.calc_H_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_MPO</span></code></a>([tol_zero])</td>
<td>Calculate MPO representation of the Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.calc_H_bond" title="tenpy.models.toric_code.ToricCode.calc_H_bond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond</span></code></a>([tol_zero])</td>
<td>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.calc_H_bond_from_MPO" title="tenpy.models.toric_code.ToricCode.calc_H_bond_from_MPO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_bond_from_MPO</span></code></a>([tol_zero])</td>
<td>Calculate the bond Hamiltonian from the MPO Hamiltonian.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.calc_H_onsite" title="tenpy.models.toric_code.ToricCode.calc_H_onsite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_H_onsite</span></code></a>([tol_zero])</td>
<td>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.coupling_strength_add_ext_flux" title="tenpy.models.toric_code.ToricCode.coupling_strength_add_ext_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coupling_strength_add_ext_flux</span></code></a>(strength,&nbsp;dx,&nbsp;…)</td>
<td>Add an external flux to the coupling strength.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.group_sites" title="tenpy.models.toric_code.ToricCode.group_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_sites</span></code></a>([n,&nbsp;grouped_sites])</td>
<td>Modify <cite>self</cite> in place to group sites.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.plot_coupling_terms" title="tenpy.models.toric_code.ToricCode.plot_coupling_terms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_coupling_terms</span></code></a>(ax[,&nbsp;style_map])</td>
<td>“Plot coupling terms into a given lattice.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tenpy.models.toric_code.ToricCode.test_sanity" title="tenpy.models.toric_code.ToricCode.test_sanity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_sanity</span></code></a>()</td>
<td>Sanity check.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.add_coupling">
<code class="descname">add_coupling</code><span class="sig-paren">(</span><em>strength</em>, <em>u1</em>, <em>op1</em>, <em>u2</em>, <em>op2</em>, <em>dx</em>, <em>op_string=None</em>, <em>str_on_first=True</em>, <em>raise_op2_left=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.add_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add twosite coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP1 * OP2\)</span>, where
<code class="docutils literal notranslate"><span class="pre">OP1</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u1].get_op(op1)</span></code> acts on the site <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u1)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP2</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u2].get_op(op2)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+dx[0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+dx[dim-1],</span> <span class="pre">u2)</span></code>.
Possible combinations <code class="docutils literal notranslate"><span class="pre">x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}</span></code> are determined from the boundary conditions
in <a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.possible_couplings" title="tenpy.models.lattice.Lattice.possible_couplings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">possible_couplings()</span></code></a>.</p>
<p>The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower
left corner of the hypercube containing the involved sites <span class="math notranslate nohighlight">\(\vec{x}\)</span> and
<span class="math notranslate nohighlight">\(\vec{x}+\vec{dx}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the coupling. May vary spatially (see above). If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>op1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u1]</span></code> for OP1.</p>
</dd>
<dt><strong>u2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u2]</span></code> for OP2.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between OP1 and OP2.
For a 1D lattice, a single int is also fine.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Name of an operator to be used between the OP1 and OP2 sites.
Typical use case is the phase for a Jordan-Wigner transformation.
The operator should be defined on all sites in the unit cell.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed, using
<a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>.</p>
</dd>
<dt><strong>str_on_first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Wheter the provided <cite>op_string</cite> should also act on the first site.
This option should be chosen as <code class="docutils literal notranslate"><span class="pre">True</span></code> for Jordan-Wigner strings.
When handling Jordan-Wigner strings we need to extend the <cite>op_string</cite> to also act on
the ‘left’, first site (in the sense of the MPS ordering of the sites given by the
lattice). In this case, there is a well-defined ordering of the operators in the
physical sense (i.e. which of <cite>op1</cite> or <cite>op2</cite> acts first on a given state).
We follow the convention that <cite>op2</cite> acts first (in the physical sense),
independent of the MPS ordering.</p>
</dd>
<dt><strong>raise_op2_left</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Raise an error when <cite>op2</cite> appears left of <cite>op1</cite>
(in the sense of the MPS ordering given by the lattice).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>When initializing a model, you can add a term :math:` J sum_{&lt;i,j&gt;} S^z_i S^z_j`
on all nearest-neighbor bonds of the lattice like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># the strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>The strength can be an array, which get’s tiled to the correct shape.
For example, in a 1D :class`~tenpy.models.lattice.Chain` with an even number of sites and
periodic (or infinite) boundary conditions, you can add alternating strong and weak
couplings with a line like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Sz&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
<p>To add the hermitian conjugate, e.g. for a hopping term, you should add it in the opposite
direction <code class="docutils literal notranslate"><span class="pre">-dx</span></code>, complex conjugate the strength, and take the hermitian conjugate
of the operators in swapped order (including a swap of <cite>u1</cite> &lt;-&gt; <cite>u2</cite>).
For spin-less fermions (<a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>), this would be</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># hopping strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># h.c.</span>
</pre></div>
</div>
<p>With spin-full fermions (<code class="xref py py-class docutils literal notranslate"><span class="pre">SpinHalfFermions</span></code>), it could be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cdu&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>  <span class="c1"># Cdagger_up C_down</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cdd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># h.c. Cdagger_down C_up</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.add_coupling_term">
<code class="descname">add_coupling_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>j</em>, <em>op_i</em>, <em>op_j</em>, <em>op_string='Id'</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.add_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a two-site coupling term on given MPS sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>i, j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS indices of the two sites on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>  and <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>, i.e., <cite>op_i</cite> acts “left” of <cite>op_j</cite>.
If j &gt;= N_sites, it indicates couplings between unit cells of an infinite MPS.</p>
</dd>
<dt><strong>op1, op2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the involved operators.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The operator to be inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.add_multi_coupling">
<code class="descname">add_multi_coupling</code><span class="sig-paren">(</span><em>strength</em>, <em>u0</em>, <em>op0</em>, <em>other_ops</em>, <em>op_string=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.add_multi_coupling" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multi-site coupling terms to the Hamiltonian, summing over lattice sites.</p>
<p>Represents couplings of the form
<span class="math notranslate nohighlight">\(sum_{x_0, ..., x_{dim-1}} strength[loc(\vec{x})] * OP0 * OP1 * ... * OPM\)</span>,
where <code class="docutils literal notranslate"><span class="pre">OP_0</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[u0].get_op(op0)</span></code> acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u0)</span></code>,
and <code class="docutils literal notranslate"><span class="pre">OP_m</span> <span class="pre">:=</span> <span class="pre">lat.unit_cell[other_u[m]].get_op(other_op[m])</span></code>, m=1…M, acts on the site
<code class="docutils literal notranslate"><span class="pre">(x_0+other_dx[m][0],</span> <span class="pre">...,</span> <span class="pre">x_{dim-1}+other_dx[m][dim-1],</span> <span class="pre">other_u[m])</span></code>.
For periodic boundary conditions along direction <cite>a</cite> (<code class="docutils literal notranslate"><span class="pre">lat.bc[a]</span> <span class="pre">==</span> <span class="pre">False</span></code>)
the index <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is taken modulo <code class="docutils literal notranslate"><span class="pre">lat.Ls[a]</span></code> and runs through <code class="docutils literal notranslate"><span class="pre">range(lat.Ls[a])</span></code>.
For open boundary conditions, <code class="docutils literal notranslate"><span class="pre">x_a</span></code> is limited to <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a</span> <span class="pre">&lt;</span> <span class="pre">Ls[a]</span></code> and
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x_a+other_dx[m,a]</span> <span class="pre">&lt;</span> <span class="pre">lat.Ls[a]</span></code>.
The coupling <cite>strength</cite> may vary spatially, <span class="math notranslate nohighlight">\(loc(\vec{x})\)</span> indicates the lower left
corner of the hypercube containing all the involved sites
<span class="math notranslate nohighlight">\(\vec{x}, \vec{x}+\vec{other_dx[m, :]}\)</span>.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the coupling. May vary spatially and is tiled to the required shape.</p>
</dd>
<dt><strong>u0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u0]</span></code> for OP0.</p>
</dd>
<dt><strong>op0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u0]</span></code> for OP0.</p>
</dd>
<dt><strong>other_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">op_m,</span> <span class="pre">dx)</span></code></span></dt>
<dd><p class="first last">One tuple for each of the other operators <code class="docutils literal notranslate"><span class="pre">OP1,</span> <span class="pre">OP2,</span> <span class="pre">...</span> <span class="pre">OPM</span></code> involved.
<cite>u</cite> picks the site <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>, <cite>op_name</cite> is a valid operator acting on that
site, and <cite>dx</cite> gives the translation vector between <code class="docutils literal notranslate"><span class="pre">OP0</span></code> and the specified operator.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first">Name of an operator to be used inbetween the operators, excluding the sites on which
the operators act. This operator should be defined on all sites in the unit cell.</p>
<p class="last">Special case: If <code class="docutils literal notranslate"><span class="pre">None</span></code>, auto-determine whether a Jordan-Wigner string is needed
(using <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.Site.op_needs_JW" title="tenpy.networks.site.Site.op_needs_JW"><code class="xref py py-meth docutils literal notranslate"><span class="pre">op_needs_JW()</span></code></a>), for each of the segments
inbetween the operators and also on the sites of the left operators.
Note that in this case the ordering of the operators <em>is</em> important and handled in the
usual convention that <code class="docutils literal notranslate"><span class="pre">OPM</span></code> acts first and <code class="docutils literal notranslate"><span class="pre">OP0</span></code> last on a physical state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.add_multi_coupling_term">
<code class="descname">add_multi_coupling_term</code><span class="sig-paren">(</span><em>strength</em>, <em>ijkl</em>, <em>ops_ijkl</em>, <em>op_string</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.add_multi_coupling_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a multi-site coupling term on given MPS sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the coupling term.</p>
</dd>
<dt><strong>ijkl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">The MPS indices of the sites on which the operators acts. With <cite>i, j, k, … = ijkl</cite>,
we require that they are ordered ascending, <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">j</span> <span class="pre">&lt;</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">...</span></code> and
that <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">N_sites</span></code>.
Inidces &gt;= N_sites indicate couplings between different unit cells of an infinite MPS.</p>
</dd>
<dt><strong>ops_ijkl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">Names of the involved operators on sites <cite>i, j, k, …</cite>.</p>
</dd>
<dt><strong>op_string</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">Names of the operator to be inserted between the operators,
e.g., op_string[0] is inserted between <cite>i</cite> and <cite>j</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.add_onsite">
<code class="descname">add_onsite</code><span class="sig-paren">(</span><em>strength</em>, <em>u</em>, <em>opname</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.add_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Add onsite terms to self.</p>
<p>Adds a term <span class="math notranslate nohighlight">\(\sum_{x_0, ..., x_{dim-1}} strength[x_0, ..., x_{dim-1}] * OP\)</span>,
where the operator <code class="docutils literal notranslate"><span class="pre">OP=lat.unit_cell[u].get_op(opname)</span></code>
acts on the site given by a lattice index <code class="docutils literal notranslate"><span class="pre">(x_0,</span> <span class="pre">...,</span> <span class="pre">x_{dim-1},</span> <span class="pre">u)</span></code>,
to the represented Hamiltonian.</p>
<p>The necessary terms are just added to <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code>; doesn’t rebuild the MPO.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">Prefactor of the onsite term. May vary spatially. If an array of smaller size
is provided, it gets tiled to the required shape.</p>
</dd>
<dt><strong>u</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Picks a <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code> out of the unit cell.</p>
</dd>
<dt><strong>opname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">valid operator name of an onsite operator in <code class="docutils literal notranslate"><span class="pre">lat.unit_cell[u]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.add_onsite_term">
<code class="descname">add_onsite_term</code><span class="sig-paren">(</span><em>strength</em>, <em>i</em>, <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.add_onsite_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a onsite term on a given MPS site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The strength of the term.</p>
</dd>
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The MPS index of the site on which the operator acts.
We require <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">L</span></code>.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the involved operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.calc_H_MPO">
<code class="descname">calc_H_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.calc_H_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate MPO representation of the Hamiltonian.</p>
<p>Uses <code class="xref py py-attr docutils literal notranslate"><span class="pre">onsite_terms</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code> to build an MPO graph
(and then an MPO).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_MPO</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="tenpy.networks.mpo.html#tenpy.networks.mpo.MPO" title="tenpy.networks.mpo.MPO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPO</span></code></a></span></dt>
<dd><p class="first last">MPO representation of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.calc_H_bond">
<code class="descname">calc_H_bond</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.calc_H_bond" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate <cite>H_bond</cite> from <cite>self.coupling_terms</cite> and <cite>self.H_onsite</cite>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self.H_onsite</span> <span class="pre">is</span> <span class="pre">None</span></code>, it is calculated with <code class="xref py py-meth docutils literal notranslate"><span class="pre">self.calc_H_onsite()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.calc_H_bond_from_MPO">
<code class="descname">calc_H_bond_from_MPO</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.calc_H_bond_from_MPO" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the bond Hamiltonian from the MPO Hamiltonian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Arrays with norm &lt; <cite>tol_zero</cite> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_bond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.linalg.np_conserved.html#tenpy.linalg.np_conserved.Array" title="tenpy.linalg.np_conserved.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a></span></dt>
<dd><p class="first last">Bond terms as required by the constructor of <code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighborModel</span></code>.
Legs are <code class="docutils literal notranslate"><span class="pre">['p0',</span> <span class="pre">'p0*',</span> <span class="pre">'p1',</span> <span class="pre">'p1*']</span></code></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the Hamiltonian contains longer-range terms.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.calc_H_onsite">
<code class="descname">calc_H_onsite</code><span class="sig-paren">(</span><em>tol_zero=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.calc_H_onsite" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <cite>H_onsite</cite> from <cite>self.onsite_terms</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tol_zero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">prefactors with <code class="docutils literal notranslate"><span class="pre">abs(strength)</span> <span class="pre">&lt;</span> <span class="pre">tol_zero</span></code> are considered to be zero.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_onsite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of npc.Array</span></dt>
<dd><p class="first last">onsite terms of the Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.coupling_strength_add_ext_flux">
<code class="descname">coupling_strength_add_ext_flux</code><span class="sig-paren">(</span><em>strength</em>, <em>dx</em>, <em>phase</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.coupling_strength_add_ext_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an external flux to the coupling strength.</p>
<p>When performing DMRG on a “cylinder” geometry, it might be useful to put an “external flux”
through the cylinder. This means that a particle hopping around the cylinder should
pick up a phase given by the external flux <a class="reference internal" href="../literature.html#resta1997" id="id1">[Resta1997]</a>.
This is also called “twisted boundary conditions” in literature.
This function adds a complex phase to the <cite>strength</cite> array on some bonds, such that
particles hopping in positive direction around the cylinder pick up <cite>exp(+i phase)</cite>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For the sign of <cite>phase</cite> it is important that you consistently use the creation
operator as <cite>op1</cite> and the annihilation operator as <cite>op2</cite> in :meth:<a href="#id2"><span class="problematic" id="id3">`</span></a>add_coupling”.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | array</span></dt>
<dd><p class="first last">The strength to be used in <a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_coupling" title="tenpy.models.toric_code.ToricCode.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>, when no external flux would be
present.</p>
</dd>
<dt><strong>dx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of int</span></dt>
<dd><p class="first last">Translation vector (of the unit cell) between <cite>op1</cite> and <cite>op2</cite> in <a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_coupling" title="tenpy.models.toric_code.ToricCode.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>.</p>
</dd>
<dt><strong>phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of float</span></dt>
<dd><p class="first last">The phase of the external flux for hopping in each direction of the lattice.
E.g., if you want flux through the cylinder on which you have an infinite MPS,
you should give <code class="docutils literal notranslate"><span class="pre">phase=[0,</span> <span class="pre">phi]</span></code> souch that particles pick up a phase <cite>phi</cite> when
hopping around the cylinder.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex array</span></dt>
<dd><p class="first last">The strength array to be used as <cite>strength</cite> in <a class="reference internal" href="#tenpy.models.toric_code.ToricCode.add_coupling" title="tenpy.models.toric_code.ToricCode.add_coupling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_coupling()</span></code></a>
with the given <cite>dx</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Let’s say you have an infinite MPS on a cylinder, and want to add nearest-neighbor
hopping of fermions with the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.FermionSite" title="tenpy.networks.site.FermionSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">FermionSite</span></code></a>.
The cylinder axis is the <cite>x</cite>-direction of the lattice, so to put a flux through the
cylinder, you want particles hopping <em>around</em> the cylinder to pick up a phase <cite>phi</cite>
given by the external flux.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strength</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1"># hopping strength without external flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span> <span class="c1"># determines the external flux strength</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strength_with_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling_strength_add_ext_flux</span><span class="p">(</span><span class="n">strength</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">:</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">add_coupling</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">strength_with_flux</span><span class="p">),</span> <span class="n">u2</span><span class="p">,</span> <span class="s1">&#39;Cd&#39;</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">dx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.group_sites">
<code class="descname">group_sites</code><span class="sig-paren">(</span><em>n=2</em>, <em>grouped_sites=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.group_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <cite>self</cite> in place to group sites.</p>
<p>Group each <cite>n</cite> sites together using the <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a>.
This might allow to do TEBD with a Trotter decomposition,
or help the convergence of DMRG (in case of too long range interactions).</p>
<p>This has to be done after finishing initialization and can not be reverted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sites to be grouped together.</p>
</dd>
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grouped_sites</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="tenpy.networks.site.html#tenpy.networks.site.GroupedSite" title="tenpy.networks.site.GroupedSite"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupedSite</span></code></a></span></dt>
<dd><p class="first last">The sites grouped together.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.plot_coupling_terms">
<code class="descname">plot_coupling_terms</code><span class="sig-paren">(</span><em>ax</em>, <em>style_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.plot_coupling_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>“Plot coupling terms into a given lattice.</p>
<p>This function plots the <code class="xref py py-attr docutils literal notranslate"><span class="pre">coupling_terms</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a></span></dt>
<dd><p class="first last">The axes on which we should plot.</p>
</dd>
<dt><strong>style_map</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Get’s called with arguments <code class="docutils literal notranslate"><span class="pre">i,</span> <span class="pre">j,</span> <span class="pre">op_i,</span> <span class="pre">op_strength,</span> <span class="pre">op_j,</span> <span class="pre">strength</span></code> for
each two-site coupling and should return a keyword-dictionary
with the desired plot-style for this combination.
By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), the linecolor depends on the phase of <cite>strength</cite>,
the <cite>linewidth</cite> is given by the phase of <cite>strength</cite> (using the <cite>hsv</cite> colormap),
and the linestyle depends on the type of operators coupled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="tenpy.models.lattice.html#tenpy.models.lattice.Lattice.plot_sites" title="tenpy.models.lattice.Lattice.plot_sites"><code class="xref py py-func docutils literal notranslate"><span class="pre">tenpy.models.lattice.Lattice.plot_sites()</span></code></a></dt>
<dd>plot the sites of the lattice.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tenpy.models.toric_code.ToricCode.test_sanity">
<code class="descname">test_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tenpy.models.toric_code.ToricCode.test_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sanity check. Raises ValueErrors, if something is wrong.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tenpy.models.tf_ising.html"
                        title="previous chapter">tenpy.models.tf_ising module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tenpy.models.xxz_chain.html"
                        title="next chapter">tenpy.models.xxz_chain module</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../userguide.html">User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tenpy.html">Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tenpy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tenpy.algorithms.html">tenpy.algorithms package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.linalg.html">tenpy.linalg package</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tenpy.models.html">tenpy.models package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.networks.html">tenpy.networks package</a></li>
<li class="toctree-l3"><a class="reference internal" href="tenpy.tools.html">tenpy.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="tenpy.html#module-tenpy">Module contents</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tenpy.models.xxz_chain.html" title="tenpy.models.xxz_chain module"
             >next</a> |</li>
        <li class="right" >
          <a href="tenpy.models.tf_ising.html" title="tenpy.models.tf_ising module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TeNPy 0.3.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="tenpy.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="tenpy.models.html" >tenpy.models package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016-2019, TeNPy Developers.
      Last updated on Mar 24, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>